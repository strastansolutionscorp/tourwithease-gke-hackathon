"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/oidc-client-ts";
exports.ids = ["vendor-chunks/oidc-client-ts"];
exports.modules = {

/***/ "(ssr)/../../node_modules/oidc-client-ts/dist/esm/oidc-client-ts.js":
/*!********************************************************************!*\
  !*** ../../node_modules/oidc-client-ts/dist/esm/oidc-client-ts.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AccessTokenEvents: () => (/* binding */ AccessTokenEvents),\n/* harmony export */   CheckSessionIFrame: () => (/* binding */ CheckSessionIFrame),\n/* harmony export */   DPoPState: () => (/* binding */ DPoPState),\n/* harmony export */   ErrorResponse: () => (/* binding */ ErrorResponse),\n/* harmony export */   ErrorTimeout: () => (/* binding */ ErrorTimeout),\n/* harmony export */   InMemoryWebStorage: () => (/* binding */ InMemoryWebStorage),\n/* harmony export */   IndexedDbDPoPStore: () => (/* binding */ IndexedDbDPoPStore),\n/* harmony export */   Log: () => (/* binding */ Log),\n/* harmony export */   Logger: () => (/* binding */ Logger),\n/* harmony export */   MetadataService: () => (/* binding */ MetadataService),\n/* harmony export */   OidcClient: () => (/* binding */ OidcClient),\n/* harmony export */   OidcClientSettingsStore: () => (/* binding */ OidcClientSettingsStore),\n/* harmony export */   SessionMonitor: () => (/* binding */ SessionMonitor),\n/* harmony export */   SigninResponse: () => (/* binding */ SigninResponse),\n/* harmony export */   SigninState: () => (/* binding */ SigninState),\n/* harmony export */   SignoutResponse: () => (/* binding */ SignoutResponse),\n/* harmony export */   State: () => (/* binding */ State),\n/* harmony export */   User: () => (/* binding */ User),\n/* harmony export */   UserManager: () => (/* binding */ UserManager),\n/* harmony export */   UserManagerSettingsStore: () => (/* binding */ UserManagerSettingsStore),\n/* harmony export */   Version: () => (/* binding */ Version),\n/* harmony export */   WebStorageStateStore: () => (/* binding */ WebStorageStateStore)\n/* harmony export */ });\n/* harmony import */ var jwt_decode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jwt-decode */ \"(ssr)/../../node_modules/jwt-decode/build/esm/index.js\");\n// src/utils/Logger.ts\nvar nopLogger = {\n  debug: () => void 0,\n  info: () => void 0,\n  warn: () => void 0,\n  error: () => void 0\n};\nvar level;\nvar logger;\nvar Log = /* @__PURE__ */ ((Log2) => {\n  Log2[Log2[\"NONE\"] = 0] = \"NONE\";\n  Log2[Log2[\"ERROR\"] = 1] = \"ERROR\";\n  Log2[Log2[\"WARN\"] = 2] = \"WARN\";\n  Log2[Log2[\"INFO\"] = 3] = \"INFO\";\n  Log2[Log2[\"DEBUG\"] = 4] = \"DEBUG\";\n  return Log2;\n})(Log || {});\n((Log2) => {\n  function reset() {\n    level = 3 /* INFO */;\n    logger = nopLogger;\n  }\n  Log2.reset = reset;\n  function setLevel(value) {\n    if (!(0 /* NONE */ <= value && value <= 4 /* DEBUG */)) {\n      throw new Error(\"Invalid log level\");\n    }\n    level = value;\n  }\n  Log2.setLevel = setLevel;\n  function setLogger(value) {\n    logger = value;\n  }\n  Log2.setLogger = setLogger;\n})(Log || (Log = {}));\nvar Logger = class _Logger {\n  constructor(_name) {\n    this._name = _name;\n  }\n  /* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */\n  debug(...args) {\n    if (level >= 4 /* DEBUG */) {\n      logger.debug(_Logger._format(this._name, this._method), ...args);\n    }\n  }\n  info(...args) {\n    if (level >= 3 /* INFO */) {\n      logger.info(_Logger._format(this._name, this._method), ...args);\n    }\n  }\n  warn(...args) {\n    if (level >= 2 /* WARN */) {\n      logger.warn(_Logger._format(this._name, this._method), ...args);\n    }\n  }\n  error(...args) {\n    if (level >= 1 /* ERROR */) {\n      logger.error(_Logger._format(this._name, this._method), ...args);\n    }\n  }\n  /* eslint-enable @typescript-eslint/no-unsafe-enum-comparison */\n  throw(err) {\n    this.error(err);\n    throw err;\n  }\n  create(method) {\n    const methodLogger = Object.create(this);\n    methodLogger._method = method;\n    methodLogger.debug(\"begin\");\n    return methodLogger;\n  }\n  static createStatic(name, staticMethod) {\n    const staticLogger = new _Logger(`${name}.${staticMethod}`);\n    staticLogger.debug(\"begin\");\n    return staticLogger;\n  }\n  static _format(name, method) {\n    const prefix = `[${name}]`;\n    return method ? `${prefix} ${method}:` : prefix;\n  }\n  /* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */\n  // helpers for static class methods\n  static debug(name, ...args) {\n    if (level >= 4 /* DEBUG */) {\n      logger.debug(_Logger._format(name), ...args);\n    }\n  }\n  static info(name, ...args) {\n    if (level >= 3 /* INFO */) {\n      logger.info(_Logger._format(name), ...args);\n    }\n  }\n  static warn(name, ...args) {\n    if (level >= 2 /* WARN */) {\n      logger.warn(_Logger._format(name), ...args);\n    }\n  }\n  static error(name, ...args) {\n    if (level >= 1 /* ERROR */) {\n      logger.error(_Logger._format(name), ...args);\n    }\n  }\n  /* eslint-enable @typescript-eslint/no-unsafe-enum-comparison */\n};\nLog.reset();\n\n// src/utils/JwtUtils.ts\n\nvar JwtUtils = class {\n  // IMPORTANT: doesn't validate the token\n  static decode(token) {\n    try {\n      return (0,jwt_decode__WEBPACK_IMPORTED_MODULE_0__.jwtDecode)(token);\n    } catch (err) {\n      Logger.error(\"JwtUtils.decode\", err);\n      throw err;\n    }\n  }\n  static async generateSignedJwt(header, payload, privateKey) {\n    const encodedHeader = CryptoUtils.encodeBase64Url(new TextEncoder().encode(JSON.stringify(header)));\n    const encodedPayload = CryptoUtils.encodeBase64Url(new TextEncoder().encode(JSON.stringify(payload)));\n    const encodedToken = `${encodedHeader}.${encodedPayload}`;\n    const signature = await window.crypto.subtle.sign(\n      {\n        name: \"ECDSA\",\n        hash: { name: \"SHA-256\" }\n      },\n      privateKey,\n      new TextEncoder().encode(encodedToken)\n    );\n    const encodedSignature = CryptoUtils.encodeBase64Url(new Uint8Array(signature));\n    return `${encodedToken}.${encodedSignature}`;\n  }\n};\n\n// src/utils/CryptoUtils.ts\nvar UUID_V4_TEMPLATE = \"10000000-1000-4000-8000-100000000000\";\nvar toBase64 = (val) => btoa([...new Uint8Array(val)].map((chr) => String.fromCharCode(chr)).join(\"\"));\nvar _CryptoUtils = class _CryptoUtils {\n  static _randomWord() {\n    const arr = new Uint32Array(1);\n    crypto.getRandomValues(arr);\n    return arr[0];\n  }\n  /**\n   * Generates RFC4122 version 4 guid\n   */\n  static generateUUIDv4() {\n    const uuid = UUID_V4_TEMPLATE.replace(\n      /[018]/g,\n      (c) => (+c ^ _CryptoUtils._randomWord() & 15 >> +c / 4).toString(16)\n    );\n    return uuid.replace(/-/g, \"\");\n  }\n  /**\n   * PKCE: Generate a code verifier\n   */\n  static generateCodeVerifier() {\n    return _CryptoUtils.generateUUIDv4() + _CryptoUtils.generateUUIDv4() + _CryptoUtils.generateUUIDv4();\n  }\n  /**\n   * PKCE: Generate a code challenge\n   */\n  static async generateCodeChallenge(code_verifier) {\n    if (!crypto.subtle) {\n      throw new Error(\"Crypto.subtle is available only in secure contexts (HTTPS).\");\n    }\n    try {\n      const encoder = new TextEncoder();\n      const data = encoder.encode(code_verifier);\n      const hashed = await crypto.subtle.digest(\"SHA-256\", data);\n      return toBase64(hashed).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n    } catch (err) {\n      Logger.error(\"CryptoUtils.generateCodeChallenge\", err);\n      throw err;\n    }\n  }\n  /**\n   * Generates a base64-encoded string for a basic auth header\n   */\n  static generateBasicAuth(client_id, client_secret) {\n    const encoder = new TextEncoder();\n    const data = encoder.encode([client_id, client_secret].join(\":\"));\n    return toBase64(data);\n  }\n  /**\n   * Generates a hash of a string using a given algorithm\n   * @param alg\n   * @param message\n   */\n  static async hash(alg, message) {\n    const msgUint8 = new TextEncoder().encode(message);\n    const hashBuffer = await crypto.subtle.digest(alg, msgUint8);\n    return new Uint8Array(hashBuffer);\n  }\n  /**\n   * Generates a rfc7638 compliant jwk thumbprint\n   * @param jwk\n   */\n  static async customCalculateJwkThumbprint(jwk) {\n    let jsonObject;\n    switch (jwk.kty) {\n      case \"RSA\":\n        jsonObject = {\n          \"e\": jwk.e,\n          \"kty\": jwk.kty,\n          \"n\": jwk.n\n        };\n        break;\n      case \"EC\":\n        jsonObject = {\n          \"crv\": jwk.crv,\n          \"kty\": jwk.kty,\n          \"x\": jwk.x,\n          \"y\": jwk.y\n        };\n        break;\n      case \"OKP\":\n        jsonObject = {\n          \"crv\": jwk.crv,\n          \"kty\": jwk.kty,\n          \"x\": jwk.x\n        };\n        break;\n      case \"oct\":\n        jsonObject = {\n          \"crv\": jwk.k,\n          \"kty\": jwk.kty\n        };\n        break;\n      default:\n        throw new Error(\"Unknown jwk type\");\n    }\n    const utf8encodedAndHashed = await _CryptoUtils.hash(\"SHA-256\", JSON.stringify(jsonObject));\n    return _CryptoUtils.encodeBase64Url(utf8encodedAndHashed);\n  }\n  static async generateDPoPProof({\n    url,\n    accessToken,\n    httpMethod,\n    keyPair,\n    nonce\n  }) {\n    let hashedToken;\n    let encodedHash;\n    const payload = {\n      \"jti\": window.crypto.randomUUID(),\n      \"htm\": httpMethod != null ? httpMethod : \"GET\",\n      \"htu\": url,\n      \"iat\": Math.floor(Date.now() / 1e3)\n    };\n    if (accessToken) {\n      hashedToken = await _CryptoUtils.hash(\"SHA-256\", accessToken);\n      encodedHash = _CryptoUtils.encodeBase64Url(hashedToken);\n      payload.ath = encodedHash;\n    }\n    if (nonce) {\n      payload.nonce = nonce;\n    }\n    try {\n      const publicJwk = await crypto.subtle.exportKey(\"jwk\", keyPair.publicKey);\n      const header = {\n        \"alg\": \"ES256\",\n        \"typ\": \"dpop+jwt\",\n        \"jwk\": {\n          \"crv\": publicJwk.crv,\n          \"kty\": publicJwk.kty,\n          \"x\": publicJwk.x,\n          \"y\": publicJwk.y\n        }\n      };\n      return await JwtUtils.generateSignedJwt(header, payload, keyPair.privateKey);\n    } catch (err) {\n      if (err instanceof TypeError) {\n        throw new Error(`Error exporting dpop public key: ${err.message}`);\n      } else {\n        throw err;\n      }\n    }\n  }\n  static async generateDPoPJkt(keyPair) {\n    try {\n      const publicJwk = await crypto.subtle.exportKey(\"jwk\", keyPair.publicKey);\n      return await _CryptoUtils.customCalculateJwkThumbprint(publicJwk);\n    } catch (err) {\n      if (err instanceof TypeError) {\n        throw new Error(`Could not retrieve dpop keys from storage: ${err.message}`);\n      } else {\n        throw err;\n      }\n    }\n  }\n  static async generateDPoPKeys() {\n    return await window.crypto.subtle.generateKey(\n      {\n        name: \"ECDSA\",\n        namedCurve: \"P-256\"\n      },\n      false,\n      [\"sign\", \"verify\"]\n    );\n  }\n};\n/**\n * Generates a base64url encoded string\n */\n_CryptoUtils.encodeBase64Url = (input) => {\n  return toBase64(input).replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n};\nvar CryptoUtils = _CryptoUtils;\n\n// src/utils/Event.ts\nvar Event = class {\n  constructor(_name) {\n    this._name = _name;\n    this._callbacks = [];\n    this._logger = new Logger(`Event('${this._name}')`);\n  }\n  addHandler(cb) {\n    this._callbacks.push(cb);\n    return () => this.removeHandler(cb);\n  }\n  removeHandler(cb) {\n    const idx = this._callbacks.lastIndexOf(cb);\n    if (idx >= 0) {\n      this._callbacks.splice(idx, 1);\n    }\n  }\n  async raise(...ev) {\n    this._logger.debug(\"raise:\", ...ev);\n    for (const cb of this._callbacks) {\n      await cb(...ev);\n    }\n  }\n};\n\n// src/utils/PopupUtils.ts\nvar PopupUtils = class {\n  /**\n   * Populates a map of window features with a placement centered in front of\n   * the current window. If no explicit width is given, a default value is\n   * binned into [800, 720, 600, 480, 360] based on the current window's width.\n   */\n  static center({ ...features }) {\n    var _a, _b, _c;\n    if (features.width == null)\n      features.width = (_a = [800, 720, 600, 480].find((width) => width <= window.outerWidth / 1.618)) != null ? _a : 360;\n    (_b = features.left) != null ? _b : features.left = Math.max(0, Math.round(window.screenX + (window.outerWidth - features.width) / 2));\n    if (features.height != null)\n      (_c = features.top) != null ? _c : features.top = Math.max(0, Math.round(window.screenY + (window.outerHeight - features.height) / 2));\n    return features;\n  }\n  static serialize(features) {\n    return Object.entries(features).filter(([, value]) => value != null).map(([key, value]) => `${key}=${typeof value !== \"boolean\" ? value : value ? \"yes\" : \"no\"}`).join(\",\");\n  }\n};\n\n// src/utils/Timer.ts\nvar Timer = class _Timer extends Event {\n  constructor() {\n    super(...arguments);\n    this._logger = new Logger(`Timer('${this._name}')`);\n    this._timerHandle = null;\n    this._expiration = 0;\n    this._callback = () => {\n      const diff = this._expiration - _Timer.getEpochTime();\n      this._logger.debug(\"timer completes in\", diff);\n      if (this._expiration <= _Timer.getEpochTime()) {\n        this.cancel();\n        void super.raise();\n      }\n    };\n  }\n  // get the time\n  static getEpochTime() {\n    return Math.floor(Date.now() / 1e3);\n  }\n  init(durationInSeconds) {\n    const logger2 = this._logger.create(\"init\");\n    durationInSeconds = Math.max(Math.floor(durationInSeconds), 1);\n    const expiration = _Timer.getEpochTime() + durationInSeconds;\n    if (this.expiration === expiration && this._timerHandle) {\n      logger2.debug(\"skipping since already initialized for expiration at\", this.expiration);\n      return;\n    }\n    this.cancel();\n    logger2.debug(\"using duration\", durationInSeconds);\n    this._expiration = expiration;\n    const timerDurationInSeconds = Math.min(durationInSeconds, 5);\n    this._timerHandle = setInterval(this._callback, timerDurationInSeconds * 1e3);\n  }\n  get expiration() {\n    return this._expiration;\n  }\n  cancel() {\n    this._logger.create(\"cancel\");\n    if (this._timerHandle) {\n      clearInterval(this._timerHandle);\n      this._timerHandle = null;\n    }\n  }\n};\n\n// src/utils/UrlUtils.ts\nvar UrlUtils = class {\n  static readParams(url, responseMode = \"query\") {\n    if (!url) throw new TypeError(\"Invalid URL\");\n    const parsedUrl = new URL(url, \"http://127.0.0.1\");\n    const params = parsedUrl[responseMode === \"fragment\" ? \"hash\" : \"search\"];\n    return new URLSearchParams(params.slice(1));\n  }\n};\nvar URL_STATE_DELIMITER = \";\";\n\n// src/errors/ErrorResponse.ts\nvar ErrorResponse = class extends Error {\n  constructor(args, form) {\n    var _a, _b, _c;\n    super(args.error_description || args.error || \"\");\n    this.form = form;\n    /** Marker to detect class: \"ErrorResponse\" */\n    this.name = \"ErrorResponse\";\n    if (!args.error) {\n      Logger.error(\"ErrorResponse\", \"No error passed\");\n      throw new Error(\"No error passed\");\n    }\n    this.error = args.error;\n    this.error_description = (_a = args.error_description) != null ? _a : null;\n    this.error_uri = (_b = args.error_uri) != null ? _b : null;\n    this.state = args.userState;\n    this.session_state = (_c = args.session_state) != null ? _c : null;\n    this.url_state = args.url_state;\n  }\n};\n\n// src/errors/ErrorTimeout.ts\nvar ErrorTimeout = class extends Error {\n  constructor(message) {\n    super(message);\n    /** Marker to detect class: \"ErrorTimeout\" */\n    this.name = \"ErrorTimeout\";\n  }\n};\n\n// src/AccessTokenEvents.ts\nvar AccessTokenEvents = class {\n  constructor(args) {\n    this._logger = new Logger(\"AccessTokenEvents\");\n    this._expiringTimer = new Timer(\"Access token expiring\");\n    this._expiredTimer = new Timer(\"Access token expired\");\n    this._expiringNotificationTimeInSeconds = args.expiringNotificationTimeInSeconds;\n  }\n  async load(container) {\n    const logger2 = this._logger.create(\"load\");\n    if (container.access_token && container.expires_in !== void 0) {\n      const duration = container.expires_in;\n      logger2.debug(\"access token present, remaining duration:\", duration);\n      if (duration > 0) {\n        let expiring = duration - this._expiringNotificationTimeInSeconds;\n        if (expiring <= 0) {\n          expiring = 1;\n        }\n        logger2.debug(\"registering expiring timer, raising in\", expiring, \"seconds\");\n        this._expiringTimer.init(expiring);\n      } else {\n        logger2.debug(\"canceling existing expiring timer because we're past expiration.\");\n        this._expiringTimer.cancel();\n      }\n      const expired = duration + 1;\n      logger2.debug(\"registering expired timer, raising in\", expired, \"seconds\");\n      this._expiredTimer.init(expired);\n    } else {\n      this._expiringTimer.cancel();\n      this._expiredTimer.cancel();\n    }\n  }\n  async unload() {\n    this._logger.debug(\"unload: canceling existing access token timers\");\n    this._expiringTimer.cancel();\n    this._expiredTimer.cancel();\n  }\n  /**\n   * Add callback: Raised prior to the access token expiring.\n   */\n  addAccessTokenExpiring(cb) {\n    return this._expiringTimer.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised prior to the access token expiring.\n   */\n  removeAccessTokenExpiring(cb) {\n    this._expiringTimer.removeHandler(cb);\n  }\n  /**\n   * Add callback: Raised after the access token has expired.\n   */\n  addAccessTokenExpired(cb) {\n    return this._expiredTimer.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised after the access token has expired.\n   */\n  removeAccessTokenExpired(cb) {\n    this._expiredTimer.removeHandler(cb);\n  }\n};\n\n// src/CheckSessionIFrame.ts\nvar CheckSessionIFrame = class {\n  constructor(_callback, _client_id, url, _intervalInSeconds, _stopOnError) {\n    this._callback = _callback;\n    this._client_id = _client_id;\n    this._intervalInSeconds = _intervalInSeconds;\n    this._stopOnError = _stopOnError;\n    this._logger = new Logger(\"CheckSessionIFrame\");\n    this._timer = null;\n    this._session_state = null;\n    this._message = (e) => {\n      if (e.origin === this._frame_origin && e.source === this._frame.contentWindow) {\n        if (e.data === \"error\") {\n          this._logger.error(\"error message from check session op iframe\");\n          if (this._stopOnError) {\n            this.stop();\n          }\n        } else if (e.data === \"changed\") {\n          this._logger.debug(\"changed message from check session op iframe\");\n          this.stop();\n          void this._callback();\n        } else {\n          this._logger.debug(e.data + \" message from check session op iframe\");\n        }\n      }\n    };\n    const parsedUrl = new URL(url);\n    this._frame_origin = parsedUrl.origin;\n    this._frame = window.document.createElement(\"iframe\");\n    this._frame.style.visibility = \"hidden\";\n    this._frame.style.position = \"fixed\";\n    this._frame.style.left = \"-1000px\";\n    this._frame.style.top = \"0\";\n    this._frame.width = \"0\";\n    this._frame.height = \"0\";\n    this._frame.src = parsedUrl.href;\n  }\n  load() {\n    return new Promise((resolve) => {\n      this._frame.onload = () => {\n        resolve();\n      };\n      window.document.body.appendChild(this._frame);\n      window.addEventListener(\"message\", this._message, false);\n    });\n  }\n  start(session_state) {\n    if (this._session_state === session_state) {\n      return;\n    }\n    this._logger.create(\"start\");\n    this.stop();\n    this._session_state = session_state;\n    const send = () => {\n      if (!this._frame.contentWindow || !this._session_state) {\n        return;\n      }\n      this._frame.contentWindow.postMessage(this._client_id + \" \" + this._session_state, this._frame_origin);\n    };\n    send();\n    this._timer = setInterval(send, this._intervalInSeconds * 1e3);\n  }\n  stop() {\n    this._logger.create(\"stop\");\n    this._session_state = null;\n    if (this._timer) {\n      clearInterval(this._timer);\n      this._timer = null;\n    }\n  }\n};\n\n// src/InMemoryWebStorage.ts\nvar InMemoryWebStorage = class {\n  constructor() {\n    this._logger = new Logger(\"InMemoryWebStorage\");\n    this._data = {};\n  }\n  clear() {\n    this._logger.create(\"clear\");\n    this._data = {};\n  }\n  getItem(key) {\n    this._logger.create(`getItem('${key}')`);\n    return this._data[key];\n  }\n  setItem(key, value) {\n    this._logger.create(`setItem('${key}')`);\n    this._data[key] = value;\n  }\n  removeItem(key) {\n    this._logger.create(`removeItem('${key}')`);\n    delete this._data[key];\n  }\n  get length() {\n    return Object.getOwnPropertyNames(this._data).length;\n  }\n  key(index) {\n    return Object.getOwnPropertyNames(this._data)[index];\n  }\n};\n\n// src/errors/ErrorDPoPNonce.ts\nvar ErrorDPoPNonce = class extends Error {\n  constructor(nonce, message) {\n    super(message);\n    /** Marker to detect class: \"ErrorDPoPNonce\" */\n    this.name = \"ErrorDPoPNonce\";\n    this.nonce = nonce;\n  }\n};\n\n// src/JsonService.ts\nvar JsonService = class {\n  constructor(additionalContentTypes = [], _jwtHandler = null, _extraHeaders = {}) {\n    this._jwtHandler = _jwtHandler;\n    this._extraHeaders = _extraHeaders;\n    this._logger = new Logger(\"JsonService\");\n    this._contentTypes = [];\n    this._contentTypes.push(...additionalContentTypes, \"application/json\");\n    if (_jwtHandler) {\n      this._contentTypes.push(\"application/jwt\");\n    }\n  }\n  async fetchWithTimeout(input, init = {}) {\n    const { timeoutInSeconds, ...initFetch } = init;\n    if (!timeoutInSeconds) {\n      return await fetch(input, initFetch);\n    }\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeoutInSeconds * 1e3);\n    try {\n      const response = await fetch(input, {\n        ...init,\n        signal: controller.signal\n      });\n      return response;\n    } catch (err) {\n      if (err instanceof DOMException && err.name === \"AbortError\") {\n        throw new ErrorTimeout(\"Network timed out\");\n      }\n      throw err;\n    } finally {\n      clearTimeout(timeoutId);\n    }\n  }\n  async getJson(url, {\n    token,\n    credentials,\n    timeoutInSeconds\n  } = {}) {\n    const logger2 = this._logger.create(\"getJson\");\n    const headers = {\n      \"Accept\": this._contentTypes.join(\", \")\n    };\n    if (token) {\n      logger2.debug(\"token passed, setting Authorization header\");\n      headers[\"Authorization\"] = \"Bearer \" + token;\n    }\n    this._appendExtraHeaders(headers);\n    let response;\n    try {\n      logger2.debug(\"url:\", url);\n      response = await this.fetchWithTimeout(url, { method: \"GET\", headers, timeoutInSeconds, credentials });\n    } catch (err) {\n      logger2.error(\"Network Error\");\n      throw err;\n    }\n    logger2.debug(\"HTTP response received, status\", response.status);\n    const contentType = response.headers.get(\"Content-Type\");\n    if (contentType && !this._contentTypes.find((item) => contentType.startsWith(item))) {\n      logger2.throw(new Error(`Invalid response Content-Type: ${contentType != null ? contentType : \"undefined\"}, from URL: ${url}`));\n    }\n    if (response.ok && this._jwtHandler && (contentType == null ? void 0 : contentType.startsWith(\"application/jwt\"))) {\n      return await this._jwtHandler(await response.text());\n    }\n    let json;\n    try {\n      json = await response.json();\n    } catch (err) {\n      logger2.error(\"Error parsing JSON response\", err);\n      if (response.ok) throw err;\n      throw new Error(`${response.statusText} (${response.status})`);\n    }\n    if (!response.ok) {\n      logger2.error(\"Error from server:\", json);\n      if (json.error) {\n        throw new ErrorResponse(json);\n      }\n      throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);\n    }\n    return json;\n  }\n  async postForm(url, {\n    body,\n    basicAuth,\n    timeoutInSeconds,\n    initCredentials,\n    extraHeaders\n  }) {\n    const logger2 = this._logger.create(\"postForm\");\n    const headers = {\n      \"Accept\": this._contentTypes.join(\", \"),\n      \"Content-Type\": \"application/x-www-form-urlencoded\",\n      ...extraHeaders\n    };\n    if (basicAuth !== void 0) {\n      headers[\"Authorization\"] = \"Basic \" + basicAuth;\n    }\n    this._appendExtraHeaders(headers);\n    let response;\n    try {\n      logger2.debug(\"url:\", url);\n      response = await this.fetchWithTimeout(url, { method: \"POST\", headers, body, timeoutInSeconds, credentials: initCredentials });\n    } catch (err) {\n      logger2.error(\"Network error\");\n      throw err;\n    }\n    logger2.debug(\"HTTP response received, status\", response.status);\n    const contentType = response.headers.get(\"Content-Type\");\n    if (contentType && !this._contentTypes.find((item) => contentType.startsWith(item))) {\n      throw new Error(`Invalid response Content-Type: ${contentType != null ? contentType : \"undefined\"}, from URL: ${url}`);\n    }\n    const responseText = await response.text();\n    let json = {};\n    if (responseText) {\n      try {\n        json = JSON.parse(responseText);\n      } catch (err) {\n        logger2.error(\"Error parsing JSON response\", err);\n        if (response.ok) throw err;\n        throw new Error(`${response.statusText} (${response.status})`);\n      }\n    }\n    if (!response.ok) {\n      logger2.error(\"Error from server:\", json);\n      if (response.headers.has(\"dpop-nonce\")) {\n        const nonce = response.headers.get(\"dpop-nonce\");\n        throw new ErrorDPoPNonce(nonce, `${JSON.stringify(json)}`);\n      }\n      if (json.error) {\n        throw new ErrorResponse(json, body);\n      }\n      throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);\n    }\n    return json;\n  }\n  _appendExtraHeaders(headers) {\n    const logger2 = this._logger.create(\"appendExtraHeaders\");\n    const customKeys = Object.keys(this._extraHeaders);\n    const protectedHeaders = [\n      \"accept\",\n      \"content-type\"\n    ];\n    const preventOverride = [\n      \"authorization\"\n    ];\n    if (customKeys.length === 0) {\n      return;\n    }\n    customKeys.forEach((headerName) => {\n      if (protectedHeaders.includes(headerName.toLocaleLowerCase())) {\n        logger2.warn(\"Protected header could not be set\", headerName, protectedHeaders);\n        return;\n      }\n      if (preventOverride.includes(headerName.toLocaleLowerCase()) && Object.keys(headers).includes(headerName)) {\n        logger2.warn(\"Header could not be overridden\", headerName, preventOverride);\n        return;\n      }\n      const content = typeof this._extraHeaders[headerName] === \"function\" ? this._extraHeaders[headerName]() : this._extraHeaders[headerName];\n      if (content && content !== \"\") {\n        headers[headerName] = content;\n      }\n    });\n  }\n};\n\n// src/MetadataService.ts\nvar MetadataService = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"MetadataService\");\n    this._signingKeys = null;\n    this._metadata = null;\n    this._metadataUrl = this._settings.metadataUrl;\n    this._jsonService = new JsonService(\n      [\"application/jwk-set+json\"],\n      null,\n      this._settings.extraHeaders\n    );\n    if (this._settings.signingKeys) {\n      this._logger.debug(\"using signingKeys from settings\");\n      this._signingKeys = this._settings.signingKeys;\n    }\n    if (this._settings.metadata) {\n      this._logger.debug(\"using metadata from settings\");\n      this._metadata = this._settings.metadata;\n    }\n    if (this._settings.fetchRequestCredentials) {\n      this._logger.debug(\"using fetchRequestCredentials from settings\");\n      this._fetchRequestCredentials = this._settings.fetchRequestCredentials;\n    }\n  }\n  resetSigningKeys() {\n    this._signingKeys = null;\n  }\n  async getMetadata() {\n    const logger2 = this._logger.create(\"getMetadata\");\n    if (this._metadata) {\n      logger2.debug(\"using cached values\");\n      return this._metadata;\n    }\n    if (!this._metadataUrl) {\n      logger2.throw(new Error(\"No authority or metadataUrl configured on settings\"));\n      throw null;\n    }\n    logger2.debug(\"getting metadata from\", this._metadataUrl);\n    const metadata = await this._jsonService.getJson(this._metadataUrl, { credentials: this._fetchRequestCredentials, timeoutInSeconds: this._settings.requestTimeoutInSeconds });\n    logger2.debug(\"merging remote JSON with seed metadata\");\n    this._metadata = Object.assign({}, metadata, this._settings.metadataSeed);\n    return this._metadata;\n  }\n  getIssuer() {\n    return this._getMetadataProperty(\"issuer\");\n  }\n  getAuthorizationEndpoint() {\n    return this._getMetadataProperty(\"authorization_endpoint\");\n  }\n  getUserInfoEndpoint() {\n    return this._getMetadataProperty(\"userinfo_endpoint\");\n  }\n  getTokenEndpoint(optional = true) {\n    return this._getMetadataProperty(\"token_endpoint\", optional);\n  }\n  getCheckSessionIframe() {\n    return this._getMetadataProperty(\"check_session_iframe\", true);\n  }\n  getEndSessionEndpoint() {\n    return this._getMetadataProperty(\"end_session_endpoint\", true);\n  }\n  getRevocationEndpoint(optional = true) {\n    return this._getMetadataProperty(\"revocation_endpoint\", optional);\n  }\n  getKeysEndpoint(optional = true) {\n    return this._getMetadataProperty(\"jwks_uri\", optional);\n  }\n  async _getMetadataProperty(name, optional = false) {\n    const logger2 = this._logger.create(`_getMetadataProperty('${name}')`);\n    const metadata = await this.getMetadata();\n    logger2.debug(\"resolved\");\n    if (metadata[name] === void 0) {\n      if (optional === true) {\n        logger2.warn(\"Metadata does not contain optional property\");\n        return void 0;\n      }\n      logger2.throw(new Error(\"Metadata does not contain property \" + name));\n    }\n    return metadata[name];\n  }\n  async getSigningKeys() {\n    const logger2 = this._logger.create(\"getSigningKeys\");\n    if (this._signingKeys) {\n      logger2.debug(\"returning signingKeys from cache\");\n      return this._signingKeys;\n    }\n    const jwks_uri = await this.getKeysEndpoint(false);\n    logger2.debug(\"got jwks_uri\", jwks_uri);\n    const keySet = await this._jsonService.getJson(jwks_uri, { timeoutInSeconds: this._settings.requestTimeoutInSeconds });\n    logger2.debug(\"got key set\", keySet);\n    if (!Array.isArray(keySet.keys)) {\n      logger2.throw(new Error(\"Missing keys on keyset\"));\n      throw null;\n    }\n    this._signingKeys = keySet.keys;\n    return this._signingKeys;\n  }\n};\n\n// src/WebStorageStateStore.ts\nvar WebStorageStateStore = class {\n  constructor({\n    prefix = \"oidc.\",\n    store = localStorage\n  } = {}) {\n    this._logger = new Logger(\"WebStorageStateStore\");\n    this._store = store;\n    this._prefix = prefix;\n  }\n  async set(key, value) {\n    this._logger.create(`set('${key}')`);\n    key = this._prefix + key;\n    await this._store.setItem(key, value);\n  }\n  async get(key) {\n    this._logger.create(`get('${key}')`);\n    key = this._prefix + key;\n    const item = await this._store.getItem(key);\n    return item;\n  }\n  async remove(key) {\n    this._logger.create(`remove('${key}')`);\n    key = this._prefix + key;\n    const item = await this._store.getItem(key);\n    await this._store.removeItem(key);\n    return item;\n  }\n  async getAllKeys() {\n    this._logger.create(\"getAllKeys\");\n    const len = await this._store.length;\n    const keys = [];\n    for (let index = 0; index < len; index++) {\n      const key = await this._store.key(index);\n      if (key && key.indexOf(this._prefix) === 0) {\n        keys.push(key.substr(this._prefix.length));\n      }\n    }\n    return keys;\n  }\n};\n\n// src/OidcClientSettings.ts\nvar DefaultResponseType = \"code\";\nvar DefaultScope = \"openid\";\nvar DefaultClientAuthentication = \"client_secret_post\";\nvar DefaultStaleStateAgeInSeconds = 60 * 15;\nvar OidcClientSettingsStore = class {\n  constructor({\n    // metadata related\n    authority,\n    metadataUrl,\n    metadata,\n    signingKeys,\n    metadataSeed,\n    // client related\n    client_id,\n    client_secret,\n    response_type = DefaultResponseType,\n    scope = DefaultScope,\n    redirect_uri,\n    post_logout_redirect_uri,\n    client_authentication = DefaultClientAuthentication,\n    // optional protocol\n    prompt,\n    display,\n    max_age,\n    ui_locales,\n    acr_values,\n    resource,\n    response_mode,\n    // behavior flags\n    filterProtocolClaims = true,\n    loadUserInfo = false,\n    requestTimeoutInSeconds,\n    staleStateAgeInSeconds = DefaultStaleStateAgeInSeconds,\n    mergeClaimsStrategy = { array: \"replace\" },\n    disablePKCE = false,\n    // other behavior\n    stateStore,\n    revokeTokenAdditionalContentTypes,\n    fetchRequestCredentials,\n    refreshTokenAllowedScope,\n    // extra\n    extraQueryParams = {},\n    extraTokenParams = {},\n    extraHeaders = {},\n    dpop,\n    omitScopeWhenRequesting = false\n  }) {\n    var _a;\n    this.authority = authority;\n    if (metadataUrl) {\n      this.metadataUrl = metadataUrl;\n    } else {\n      this.metadataUrl = authority;\n      if (authority) {\n        if (!this.metadataUrl.endsWith(\"/\")) {\n          this.metadataUrl += \"/\";\n        }\n        this.metadataUrl += \".well-known/openid-configuration\";\n      }\n    }\n    this.metadata = metadata;\n    this.metadataSeed = metadataSeed;\n    this.signingKeys = signingKeys;\n    this.client_id = client_id;\n    this.client_secret = client_secret;\n    this.response_type = response_type;\n    this.scope = scope;\n    this.redirect_uri = redirect_uri;\n    this.post_logout_redirect_uri = post_logout_redirect_uri;\n    this.client_authentication = client_authentication;\n    this.prompt = prompt;\n    this.display = display;\n    this.max_age = max_age;\n    this.ui_locales = ui_locales;\n    this.acr_values = acr_values;\n    this.resource = resource;\n    this.response_mode = response_mode;\n    this.filterProtocolClaims = filterProtocolClaims != null ? filterProtocolClaims : true;\n    this.loadUserInfo = !!loadUserInfo;\n    this.staleStateAgeInSeconds = staleStateAgeInSeconds;\n    this.mergeClaimsStrategy = mergeClaimsStrategy;\n    this.omitScopeWhenRequesting = omitScopeWhenRequesting;\n    this.disablePKCE = !!disablePKCE;\n    this.revokeTokenAdditionalContentTypes = revokeTokenAdditionalContentTypes;\n    this.fetchRequestCredentials = fetchRequestCredentials ? fetchRequestCredentials : \"same-origin\";\n    this.requestTimeoutInSeconds = requestTimeoutInSeconds;\n    if (stateStore) {\n      this.stateStore = stateStore;\n    } else {\n      const store = typeof window !== \"undefined\" ? window.localStorage : new InMemoryWebStorage();\n      this.stateStore = new WebStorageStateStore({ store });\n    }\n    this.refreshTokenAllowedScope = refreshTokenAllowedScope;\n    this.extraQueryParams = extraQueryParams;\n    this.extraTokenParams = extraTokenParams;\n    this.extraHeaders = extraHeaders;\n    this.dpop = dpop;\n    if (this.dpop && !((_a = this.dpop) == null ? void 0 : _a.store)) {\n      throw new Error(\"A DPoPStore is required when dpop is enabled\");\n    }\n  }\n};\n\n// src/UserInfoService.ts\nvar UserInfoService = class {\n  constructor(_settings, _metadataService) {\n    this._settings = _settings;\n    this._metadataService = _metadataService;\n    this._logger = new Logger(\"UserInfoService\");\n    this._getClaimsFromJwt = async (responseText) => {\n      const logger2 = this._logger.create(\"_getClaimsFromJwt\");\n      try {\n        const payload = JwtUtils.decode(responseText);\n        logger2.debug(\"JWT decoding successful\");\n        return payload;\n      } catch (err) {\n        logger2.error(\"Error parsing JWT response\");\n        throw err;\n      }\n    };\n    this._jsonService = new JsonService(\n      void 0,\n      this._getClaimsFromJwt,\n      this._settings.extraHeaders\n    );\n  }\n  async getClaims(token) {\n    const logger2 = this._logger.create(\"getClaims\");\n    if (!token) {\n      this._logger.throw(new Error(\"No token passed\"));\n    }\n    const url = await this._metadataService.getUserInfoEndpoint();\n    logger2.debug(\"got userinfo url\", url);\n    const claims = await this._jsonService.getJson(url, {\n      token,\n      credentials: this._settings.fetchRequestCredentials,\n      timeoutInSeconds: this._settings.requestTimeoutInSeconds\n    });\n    logger2.debug(\"got claims\", claims);\n    return claims;\n  }\n};\n\n// src/TokenClient.ts\nvar TokenClient = class {\n  constructor(_settings, _metadataService) {\n    this._settings = _settings;\n    this._metadataService = _metadataService;\n    this._logger = new Logger(\"TokenClient\");\n    this._jsonService = new JsonService(\n      this._settings.revokeTokenAdditionalContentTypes,\n      null,\n      this._settings.extraHeaders\n    );\n  }\n  /**\n   * Exchange code.\n   *\n   * @see https://www.rfc-editor.org/rfc/rfc6749#section-4.1.3\n   */\n  async exchangeCode({\n    grant_type = \"authorization_code\",\n    redirect_uri = this._settings.redirect_uri,\n    client_id = this._settings.client_id,\n    client_secret = this._settings.client_secret,\n    extraHeaders,\n    ...args\n  }) {\n    const logger2 = this._logger.create(\"exchangeCode\");\n    if (!client_id) {\n      logger2.throw(new Error(\"A client_id is required\"));\n    }\n    if (!redirect_uri) {\n      logger2.throw(new Error(\"A redirect_uri is required\"));\n    }\n    if (!args.code) {\n      logger2.throw(new Error(\"A code is required\"));\n    }\n    const params = new URLSearchParams({ grant_type, redirect_uri });\n    for (const [key, value] of Object.entries(args)) {\n      if (value != null) {\n        params.set(key, value);\n      }\n    }\n    let basicAuth;\n    switch (this._settings.client_authentication) {\n      case \"client_secret_basic\":\n        if (client_secret === void 0 || client_secret === null) {\n          logger2.throw(new Error(\"A client_secret is required\"));\n          throw null;\n        }\n        basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n        break;\n      case \"client_secret_post\":\n        params.append(\"client_id\", client_id);\n        if (client_secret) {\n          params.append(\"client_secret\", client_secret);\n        }\n        break;\n    }\n    const url = await this._metadataService.getTokenEndpoint(false);\n    logger2.debug(\"got token endpoint\");\n    const response = await this._jsonService.postForm(url, {\n      body: params,\n      basicAuth,\n      timeoutInSeconds: this._settings.requestTimeoutInSeconds,\n      initCredentials: this._settings.fetchRequestCredentials,\n      extraHeaders\n    });\n    logger2.debug(\"got response\");\n    return response;\n  }\n  /**\n   * Exchange credentials.\n   *\n   * @see https://www.rfc-editor.org/rfc/rfc6749#section-4.3.2\n   */\n  async exchangeCredentials({\n    grant_type = \"password\",\n    client_id = this._settings.client_id,\n    client_secret = this._settings.client_secret,\n    scope = this._settings.scope,\n    ...args\n  }) {\n    const logger2 = this._logger.create(\"exchangeCredentials\");\n    if (!client_id) {\n      logger2.throw(new Error(\"A client_id is required\"));\n    }\n    const params = new URLSearchParams({ grant_type });\n    if (!this._settings.omitScopeWhenRequesting) {\n      params.set(\"scope\", scope);\n    }\n    for (const [key, value] of Object.entries(args)) {\n      if (value != null) {\n        params.set(key, value);\n      }\n    }\n    let basicAuth;\n    switch (this._settings.client_authentication) {\n      case \"client_secret_basic\":\n        if (client_secret === void 0 || client_secret === null) {\n          logger2.throw(new Error(\"A client_secret is required\"));\n          throw null;\n        }\n        basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n        break;\n      case \"client_secret_post\":\n        params.append(\"client_id\", client_id);\n        if (client_secret) {\n          params.append(\"client_secret\", client_secret);\n        }\n        break;\n    }\n    const url = await this._metadataService.getTokenEndpoint(false);\n    logger2.debug(\"got token endpoint\");\n    const response = await this._jsonService.postForm(url, { body: params, basicAuth, timeoutInSeconds: this._settings.requestTimeoutInSeconds, initCredentials: this._settings.fetchRequestCredentials });\n    logger2.debug(\"got response\");\n    return response;\n  }\n  /**\n   * Exchange a refresh token.\n   *\n   * @see https://www.rfc-editor.org/rfc/rfc6749#section-6\n   */\n  async exchangeRefreshToken({\n    grant_type = \"refresh_token\",\n    client_id = this._settings.client_id,\n    client_secret = this._settings.client_secret,\n    timeoutInSeconds,\n    extraHeaders,\n    ...args\n  }) {\n    const logger2 = this._logger.create(\"exchangeRefreshToken\");\n    if (!client_id) {\n      logger2.throw(new Error(\"A client_id is required\"));\n    }\n    if (!args.refresh_token) {\n      logger2.throw(new Error(\"A refresh_token is required\"));\n    }\n    const params = new URLSearchParams({ grant_type });\n    for (const [key, value] of Object.entries(args)) {\n      if (Array.isArray(value)) {\n        value.forEach((param) => params.append(key, param));\n      } else if (value != null) {\n        params.set(key, value);\n      }\n    }\n    let basicAuth;\n    switch (this._settings.client_authentication) {\n      case \"client_secret_basic\":\n        if (client_secret === void 0 || client_secret === null) {\n          logger2.throw(new Error(\"A client_secret is required\"));\n          throw null;\n        }\n        basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n        break;\n      case \"client_secret_post\":\n        params.append(\"client_id\", client_id);\n        if (client_secret) {\n          params.append(\"client_secret\", client_secret);\n        }\n        break;\n    }\n    const url = await this._metadataService.getTokenEndpoint(false);\n    logger2.debug(\"got token endpoint\");\n    const response = await this._jsonService.postForm(url, { body: params, basicAuth, timeoutInSeconds, initCredentials: this._settings.fetchRequestCredentials, extraHeaders });\n    logger2.debug(\"got response\");\n    return response;\n  }\n  /**\n   * Revoke an access or refresh token.\n   *\n   * @see https://datatracker.ietf.org/doc/html/rfc7009#section-2.1\n   */\n  async revoke(args) {\n    var _a;\n    const logger2 = this._logger.create(\"revoke\");\n    if (!args.token) {\n      logger2.throw(new Error(\"A token is required\"));\n    }\n    const url = await this._metadataService.getRevocationEndpoint(false);\n    logger2.debug(`got revocation endpoint, revoking ${(_a = args.token_type_hint) != null ? _a : \"default token type\"}`);\n    const params = new URLSearchParams();\n    for (const [key, value] of Object.entries(args)) {\n      if (value != null) {\n        params.set(key, value);\n      }\n    }\n    params.set(\"client_id\", this._settings.client_id);\n    if (this._settings.client_secret) {\n      params.set(\"client_secret\", this._settings.client_secret);\n    }\n    await this._jsonService.postForm(url, { body: params, timeoutInSeconds: this._settings.requestTimeoutInSeconds });\n    logger2.debug(\"got response\");\n  }\n};\n\n// src/ResponseValidator.ts\nvar ResponseValidator = class {\n  constructor(_settings, _metadataService, _claimsService) {\n    this._settings = _settings;\n    this._metadataService = _metadataService;\n    this._claimsService = _claimsService;\n    this._logger = new Logger(\"ResponseValidator\");\n    this._userInfoService = new UserInfoService(this._settings, this._metadataService);\n    this._tokenClient = new TokenClient(this._settings, this._metadataService);\n  }\n  async validateSigninResponse(response, state, extraHeaders) {\n    const logger2 = this._logger.create(\"validateSigninResponse\");\n    this._processSigninState(response, state);\n    logger2.debug(\"state processed\");\n    await this._processCode(response, state, extraHeaders);\n    logger2.debug(\"code processed\");\n    if (response.isOpenId) {\n      this._validateIdTokenAttributes(response);\n    }\n    logger2.debug(\"tokens validated\");\n    await this._processClaims(response, state == null ? void 0 : state.skipUserInfo, response.isOpenId);\n    logger2.debug(\"claims processed\");\n  }\n  async validateCredentialsResponse(response, skipUserInfo) {\n    const logger2 = this._logger.create(\"validateCredentialsResponse\");\n    const shouldValidateSubClaim = response.isOpenId && !!response.id_token;\n    if (shouldValidateSubClaim) {\n      this._validateIdTokenAttributes(response);\n    }\n    logger2.debug(\"tokens validated\");\n    await this._processClaims(response, skipUserInfo, shouldValidateSubClaim);\n    logger2.debug(\"claims processed\");\n  }\n  async validateRefreshResponse(response, state) {\n    var _a, _b;\n    const logger2 = this._logger.create(\"validateRefreshResponse\");\n    response.userState = state.data;\n    (_a = response.session_state) != null ? _a : response.session_state = state.session_state;\n    (_b = response.scope) != null ? _b : response.scope = state.scope;\n    if (response.isOpenId && !!response.id_token) {\n      this._validateIdTokenAttributes(response, state.id_token);\n      logger2.debug(\"ID Token validated\");\n    }\n    if (!response.id_token) {\n      response.id_token = state.id_token;\n      response.profile = state.profile;\n    }\n    const hasIdToken = response.isOpenId && !!response.id_token;\n    await this._processClaims(response, false, hasIdToken);\n    logger2.debug(\"claims processed\");\n  }\n  validateSignoutResponse(response, state) {\n    const logger2 = this._logger.create(\"validateSignoutResponse\");\n    if (state.id !== response.state) {\n      logger2.throw(new Error(\"State does not match\"));\n    }\n    logger2.debug(\"state validated\");\n    response.userState = state.data;\n    if (response.error) {\n      logger2.warn(\"Response was error\", response.error);\n      throw new ErrorResponse(response);\n    }\n  }\n  _processSigninState(response, state) {\n    var _a;\n    const logger2 = this._logger.create(\"_processSigninState\");\n    if (state.id !== response.state) {\n      logger2.throw(new Error(\"State does not match\"));\n    }\n    if (!state.client_id) {\n      logger2.throw(new Error(\"No client_id on state\"));\n    }\n    if (!state.authority) {\n      logger2.throw(new Error(\"No authority on state\"));\n    }\n    if (this._settings.authority !== state.authority) {\n      logger2.throw(new Error(\"authority mismatch on settings vs. signin state\"));\n    }\n    if (this._settings.client_id && this._settings.client_id !== state.client_id) {\n      logger2.throw(new Error(\"client_id mismatch on settings vs. signin state\"));\n    }\n    logger2.debug(\"state validated\");\n    response.userState = state.data;\n    response.url_state = state.url_state;\n    (_a = response.scope) != null ? _a : response.scope = state.scope;\n    if (response.error) {\n      logger2.warn(\"Response was error\", response.error);\n      throw new ErrorResponse(response);\n    }\n    if (state.code_verifier && !response.code) {\n      logger2.throw(new Error(\"Expected code in response\"));\n    }\n  }\n  async _processClaims(response, skipUserInfo = false, validateSub = true) {\n    const logger2 = this._logger.create(\"_processClaims\");\n    response.profile = this._claimsService.filterProtocolClaims(response.profile);\n    if (skipUserInfo || !this._settings.loadUserInfo || !response.access_token) {\n      logger2.debug(\"not loading user info\");\n      return;\n    }\n    logger2.debug(\"loading user info\");\n    const claims = await this._userInfoService.getClaims(response.access_token);\n    logger2.debug(\"user info claims received from user info endpoint\");\n    if (validateSub && claims.sub !== response.profile.sub) {\n      logger2.throw(new Error(\"subject from UserInfo response does not match subject in ID Token\"));\n    }\n    response.profile = this._claimsService.mergeClaims(response.profile, this._claimsService.filterProtocolClaims(claims));\n    logger2.debug(\"user info claims received, updated profile:\", response.profile);\n  }\n  async _processCode(response, state, extraHeaders) {\n    const logger2 = this._logger.create(\"_processCode\");\n    if (response.code) {\n      logger2.debug(\"Validating code\");\n      const tokenResponse = await this._tokenClient.exchangeCode({\n        client_id: state.client_id,\n        client_secret: state.client_secret,\n        code: response.code,\n        redirect_uri: state.redirect_uri,\n        code_verifier: state.code_verifier,\n        extraHeaders,\n        ...state.extraTokenParams\n      });\n      Object.assign(response, tokenResponse);\n    } else {\n      logger2.debug(\"No code to process\");\n    }\n  }\n  _validateIdTokenAttributes(response, existingToken) {\n    var _a;\n    const logger2 = this._logger.create(\"_validateIdTokenAttributes\");\n    logger2.debug(\"decoding ID Token JWT\");\n    const incoming = JwtUtils.decode((_a = response.id_token) != null ? _a : \"\");\n    if (!incoming.sub) {\n      logger2.throw(new Error(\"ID Token is missing a subject claim\"));\n    }\n    if (existingToken) {\n      const existing = JwtUtils.decode(existingToken);\n      if (incoming.sub !== existing.sub) {\n        logger2.throw(new Error(\"sub in id_token does not match current sub\"));\n      }\n      if (incoming.auth_time && incoming.auth_time !== existing.auth_time) {\n        logger2.throw(new Error(\"auth_time in id_token does not match original auth_time\"));\n      }\n      if (incoming.azp && incoming.azp !== existing.azp) {\n        logger2.throw(new Error(\"azp in id_token does not match original azp\"));\n      }\n      if (!incoming.azp && existing.azp) {\n        logger2.throw(new Error(\"azp not in id_token, but present in original id_token\"));\n      }\n    }\n    response.profile = incoming;\n  }\n};\n\n// src/State.ts\nvar State = class _State {\n  constructor(args) {\n    this.id = args.id || CryptoUtils.generateUUIDv4();\n    this.data = args.data;\n    if (args.created && args.created > 0) {\n      this.created = args.created;\n    } else {\n      this.created = Timer.getEpochTime();\n    }\n    this.request_type = args.request_type;\n    this.url_state = args.url_state;\n  }\n  toStorageString() {\n    new Logger(\"State\").create(\"toStorageString\");\n    return JSON.stringify({\n      id: this.id,\n      data: this.data,\n      created: this.created,\n      request_type: this.request_type,\n      url_state: this.url_state\n    });\n  }\n  static fromStorageString(storageString) {\n    Logger.createStatic(\"State\", \"fromStorageString\");\n    return Promise.resolve(new _State(JSON.parse(storageString)));\n  }\n  static async clearStaleState(storage, age) {\n    const logger2 = Logger.createStatic(\"State\", \"clearStaleState\");\n    const cutoff = Timer.getEpochTime() - age;\n    const keys = await storage.getAllKeys();\n    logger2.debug(\"got keys\", keys);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const item = await storage.get(key);\n      let remove = false;\n      if (item) {\n        try {\n          const state = await _State.fromStorageString(item);\n          logger2.debug(\"got item from key:\", key, state.created);\n          if (state.created <= cutoff) {\n            remove = true;\n          }\n        } catch (err) {\n          logger2.error(\"Error parsing state for key:\", key, err);\n          remove = true;\n        }\n      } else {\n        logger2.debug(\"no item in storage for key:\", key);\n        remove = true;\n      }\n      if (remove) {\n        logger2.debug(\"removed item for key:\", key);\n        void storage.remove(key);\n      }\n    }\n  }\n};\n\n// src/SigninState.ts\nvar SigninState = class _SigninState extends State {\n  constructor(args) {\n    super(args);\n    this.code_verifier = args.code_verifier;\n    this.code_challenge = args.code_challenge;\n    this.authority = args.authority;\n    this.client_id = args.client_id;\n    this.redirect_uri = args.redirect_uri;\n    this.scope = args.scope;\n    this.client_secret = args.client_secret;\n    this.extraTokenParams = args.extraTokenParams;\n    this.response_mode = args.response_mode;\n    this.skipUserInfo = args.skipUserInfo;\n  }\n  static async create(args) {\n    const code_verifier = args.code_verifier === true ? CryptoUtils.generateCodeVerifier() : args.code_verifier || void 0;\n    const code_challenge = code_verifier ? await CryptoUtils.generateCodeChallenge(code_verifier) : void 0;\n    return new _SigninState({\n      ...args,\n      code_verifier,\n      code_challenge\n    });\n  }\n  toStorageString() {\n    new Logger(\"SigninState\").create(\"toStorageString\");\n    return JSON.stringify({\n      id: this.id,\n      data: this.data,\n      created: this.created,\n      request_type: this.request_type,\n      url_state: this.url_state,\n      code_verifier: this.code_verifier,\n      authority: this.authority,\n      client_id: this.client_id,\n      redirect_uri: this.redirect_uri,\n      scope: this.scope,\n      client_secret: this.client_secret,\n      extraTokenParams: this.extraTokenParams,\n      response_mode: this.response_mode,\n      skipUserInfo: this.skipUserInfo\n    });\n  }\n  static fromStorageString(storageString) {\n    Logger.createStatic(\"SigninState\", \"fromStorageString\");\n    const data = JSON.parse(storageString);\n    return _SigninState.create(data);\n  }\n};\n\n// src/SigninRequest.ts\nvar _SigninRequest = class _SigninRequest {\n  constructor(args) {\n    this.url = args.url;\n    this.state = args.state;\n  }\n  static async create({\n    // mandatory\n    url,\n    authority,\n    client_id,\n    redirect_uri,\n    response_type,\n    scope,\n    // optional\n    state_data,\n    response_mode,\n    request_type,\n    client_secret,\n    nonce,\n    url_state,\n    resource,\n    skipUserInfo,\n    extraQueryParams,\n    extraTokenParams,\n    disablePKCE,\n    dpopJkt,\n    omitScopeWhenRequesting,\n    ...optionalParams\n  }) {\n    if (!url) {\n      this._logger.error(\"create: No url passed\");\n      throw new Error(\"url\");\n    }\n    if (!client_id) {\n      this._logger.error(\"create: No client_id passed\");\n      throw new Error(\"client_id\");\n    }\n    if (!redirect_uri) {\n      this._logger.error(\"create: No redirect_uri passed\");\n      throw new Error(\"redirect_uri\");\n    }\n    if (!response_type) {\n      this._logger.error(\"create: No response_type passed\");\n      throw new Error(\"response_type\");\n    }\n    if (!scope) {\n      this._logger.error(\"create: No scope passed\");\n      throw new Error(\"scope\");\n    }\n    if (!authority) {\n      this._logger.error(\"create: No authority passed\");\n      throw new Error(\"authority\");\n    }\n    const state = await SigninState.create({\n      data: state_data,\n      request_type,\n      url_state,\n      code_verifier: !disablePKCE,\n      client_id,\n      authority,\n      redirect_uri,\n      response_mode,\n      client_secret,\n      scope,\n      extraTokenParams,\n      skipUserInfo\n    });\n    const parsedUrl = new URL(url);\n    parsedUrl.searchParams.append(\"client_id\", client_id);\n    parsedUrl.searchParams.append(\"redirect_uri\", redirect_uri);\n    parsedUrl.searchParams.append(\"response_type\", response_type);\n    if (!omitScopeWhenRequesting) {\n      parsedUrl.searchParams.append(\"scope\", scope);\n    }\n    if (nonce) {\n      parsedUrl.searchParams.append(\"nonce\", nonce);\n    }\n    if (dpopJkt) {\n      parsedUrl.searchParams.append(\"dpop_jkt\", dpopJkt);\n    }\n    let stateParam = state.id;\n    if (url_state) {\n      stateParam = `${stateParam}${URL_STATE_DELIMITER}${url_state}`;\n    }\n    parsedUrl.searchParams.append(\"state\", stateParam);\n    if (state.code_challenge) {\n      parsedUrl.searchParams.append(\"code_challenge\", state.code_challenge);\n      parsedUrl.searchParams.append(\"code_challenge_method\", \"S256\");\n    }\n    if (resource) {\n      const resources = Array.isArray(resource) ? resource : [resource];\n      resources.forEach((r) => parsedUrl.searchParams.append(\"resource\", r));\n    }\n    for (const [key, value] of Object.entries({ response_mode, ...optionalParams, ...extraQueryParams })) {\n      if (value != null) {\n        parsedUrl.searchParams.append(key, value.toString());\n      }\n    }\n    return new _SigninRequest({\n      url: parsedUrl.href,\n      state\n    });\n  }\n};\n_SigninRequest._logger = new Logger(\"SigninRequest\");\nvar SigninRequest = _SigninRequest;\n\n// src/SigninResponse.ts\nvar OidcScope = \"openid\";\nvar SigninResponse = class {\n  constructor(params) {\n    /** @see {@link User.access_token} */\n    this.access_token = \"\";\n    /** @see {@link User.token_type} */\n    this.token_type = \"\";\n    /** @see {@link User.profile} */\n    this.profile = {};\n    this.state = params.get(\"state\");\n    this.session_state = params.get(\"session_state\");\n    if (this.state) {\n      const splitState = decodeURIComponent(this.state).split(URL_STATE_DELIMITER);\n      this.state = splitState[0];\n      if (splitState.length > 1) {\n        this.url_state = splitState.slice(1).join(URL_STATE_DELIMITER);\n      }\n    }\n    this.error = params.get(\"error\");\n    this.error_description = params.get(\"error_description\");\n    this.error_uri = params.get(\"error_uri\");\n    this.code = params.get(\"code\");\n  }\n  get expires_in() {\n    if (this.expires_at === void 0) {\n      return void 0;\n    }\n    return this.expires_at - Timer.getEpochTime();\n  }\n  set expires_in(value) {\n    if (typeof value === \"string\") value = Number(value);\n    if (value !== void 0 && value >= 0) {\n      this.expires_at = Math.floor(value) + Timer.getEpochTime();\n    }\n  }\n  get isOpenId() {\n    var _a;\n    return ((_a = this.scope) == null ? void 0 : _a.split(\" \").includes(OidcScope)) || !!this.id_token;\n  }\n};\n\n// src/SignoutRequest.ts\nvar SignoutRequest = class {\n  constructor({\n    url,\n    state_data,\n    id_token_hint,\n    post_logout_redirect_uri,\n    extraQueryParams,\n    request_type,\n    client_id,\n    url_state\n  }) {\n    this._logger = new Logger(\"SignoutRequest\");\n    if (!url) {\n      this._logger.error(\"ctor: No url passed\");\n      throw new Error(\"url\");\n    }\n    const parsedUrl = new URL(url);\n    if (id_token_hint) {\n      parsedUrl.searchParams.append(\"id_token_hint\", id_token_hint);\n    }\n    if (client_id) {\n      parsedUrl.searchParams.append(\"client_id\", client_id);\n    }\n    if (post_logout_redirect_uri) {\n      parsedUrl.searchParams.append(\"post_logout_redirect_uri\", post_logout_redirect_uri);\n      if (state_data || url_state) {\n        this.state = new State({ data: state_data, request_type, url_state });\n        let stateParam = this.state.id;\n        if (url_state) {\n          stateParam = `${stateParam}${URL_STATE_DELIMITER}${url_state}`;\n        }\n        parsedUrl.searchParams.append(\"state\", stateParam);\n      }\n    }\n    for (const [key, value] of Object.entries({ ...extraQueryParams })) {\n      if (value != null) {\n        parsedUrl.searchParams.append(key, value.toString());\n      }\n    }\n    this.url = parsedUrl.href;\n  }\n};\n\n// src/SignoutResponse.ts\nvar SignoutResponse = class {\n  constructor(params) {\n    this.state = params.get(\"state\");\n    if (this.state) {\n      const splitState = decodeURIComponent(this.state).split(URL_STATE_DELIMITER);\n      this.state = splitState[0];\n      if (splitState.length > 1) {\n        this.url_state = splitState.slice(1).join(URL_STATE_DELIMITER);\n      }\n    }\n    this.error = params.get(\"error\");\n    this.error_description = params.get(\"error_description\");\n    this.error_uri = params.get(\"error_uri\");\n  }\n};\n\n// src/ClaimsService.ts\nvar DefaultProtocolClaims = [\n  \"nbf\",\n  \"jti\",\n  \"auth_time\",\n  \"nonce\",\n  \"acr\",\n  \"amr\",\n  \"azp\",\n  \"at_hash\"\n  // https://openid.net/specs/openid-connect-core-1_0.html#CodeIDToken\n];\nvar InternalRequiredProtocolClaims = [\"sub\", \"iss\", \"aud\", \"exp\", \"iat\"];\nvar ClaimsService = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"ClaimsService\");\n  }\n  filterProtocolClaims(claims) {\n    const result = { ...claims };\n    if (this._settings.filterProtocolClaims) {\n      let protocolClaims;\n      if (Array.isArray(this._settings.filterProtocolClaims)) {\n        protocolClaims = this._settings.filterProtocolClaims;\n      } else {\n        protocolClaims = DefaultProtocolClaims;\n      }\n      for (const claim of protocolClaims) {\n        if (!InternalRequiredProtocolClaims.includes(claim)) {\n          delete result[claim];\n        }\n      }\n    }\n    return result;\n  }\n  mergeClaims(claims1, claims2) {\n    const result = { ...claims1 };\n    for (const [claim, values] of Object.entries(claims2)) {\n      if (result[claim] !== values) {\n        if (Array.isArray(result[claim]) || Array.isArray(values)) {\n          if (this._settings.mergeClaimsStrategy.array == \"replace\") {\n            result[claim] = values;\n          } else {\n            const mergedValues = Array.isArray(result[claim]) ? result[claim] : [result[claim]];\n            for (const value of Array.isArray(values) ? values : [values]) {\n              if (!mergedValues.includes(value)) {\n                mergedValues.push(value);\n              }\n            }\n            result[claim] = mergedValues;\n          }\n        } else if (typeof result[claim] === \"object\" && typeof values === \"object\") {\n          result[claim] = this.mergeClaims(result[claim], values);\n        } else {\n          result[claim] = values;\n        }\n      }\n    }\n    return result;\n  }\n};\n\n// src/DPoPStore.ts\nvar DPoPState = class {\n  constructor(keys, nonce) {\n    this.keys = keys;\n    this.nonce = nonce;\n  }\n};\n\n// src/OidcClient.ts\nvar OidcClient = class {\n  constructor(settings, metadataService) {\n    this._logger = new Logger(\"OidcClient\");\n    this.settings = settings instanceof OidcClientSettingsStore ? settings : new OidcClientSettingsStore(settings);\n    this.metadataService = metadataService != null ? metadataService : new MetadataService(this.settings);\n    this._claimsService = new ClaimsService(this.settings);\n    this._validator = new ResponseValidator(this.settings, this.metadataService, this._claimsService);\n    this._tokenClient = new TokenClient(this.settings, this.metadataService);\n  }\n  async createSigninRequest({\n    state,\n    request,\n    request_uri,\n    request_type,\n    id_token_hint,\n    login_hint,\n    skipUserInfo,\n    nonce,\n    url_state,\n    response_type = this.settings.response_type,\n    scope = this.settings.scope,\n    redirect_uri = this.settings.redirect_uri,\n    prompt = this.settings.prompt,\n    display = this.settings.display,\n    max_age = this.settings.max_age,\n    ui_locales = this.settings.ui_locales,\n    acr_values = this.settings.acr_values,\n    resource = this.settings.resource,\n    response_mode = this.settings.response_mode,\n    extraQueryParams = this.settings.extraQueryParams,\n    extraTokenParams = this.settings.extraTokenParams,\n    dpopJkt,\n    omitScopeWhenRequesting = this.settings.omitScopeWhenRequesting\n  }) {\n    const logger2 = this._logger.create(\"createSigninRequest\");\n    if (response_type !== \"code\") {\n      throw new Error(\"Only the Authorization Code flow (with PKCE) is supported\");\n    }\n    const url = await this.metadataService.getAuthorizationEndpoint();\n    logger2.debug(\"Received authorization endpoint\", url);\n    const signinRequest = await SigninRequest.create({\n      url,\n      authority: this.settings.authority,\n      client_id: this.settings.client_id,\n      redirect_uri,\n      response_type,\n      scope,\n      state_data: state,\n      url_state,\n      prompt,\n      display,\n      max_age,\n      ui_locales,\n      id_token_hint,\n      login_hint,\n      acr_values,\n      dpopJkt,\n      resource,\n      request,\n      request_uri,\n      extraQueryParams,\n      extraTokenParams,\n      request_type,\n      response_mode,\n      client_secret: this.settings.client_secret,\n      skipUserInfo,\n      nonce,\n      disablePKCE: this.settings.disablePKCE,\n      omitScopeWhenRequesting\n    });\n    await this.clearStaleState();\n    const signinState = signinRequest.state;\n    await this.settings.stateStore.set(signinState.id, signinState.toStorageString());\n    return signinRequest;\n  }\n  async readSigninResponseState(url, removeState = false) {\n    const logger2 = this._logger.create(\"readSigninResponseState\");\n    const response = new SigninResponse(UrlUtils.readParams(url, this.settings.response_mode));\n    if (!response.state) {\n      logger2.throw(new Error(\"No state in response\"));\n      throw null;\n    }\n    const storedStateString = await this.settings.stateStore[removeState ? \"remove\" : \"get\"](response.state);\n    if (!storedStateString) {\n      logger2.throw(new Error(\"No matching state found in storage\"));\n      throw null;\n    }\n    const state = await SigninState.fromStorageString(storedStateString);\n    return { state, response };\n  }\n  async processSigninResponse(url, extraHeaders, removeState = true) {\n    const logger2 = this._logger.create(\"processSigninResponse\");\n    const { state, response } = await this.readSigninResponseState(url, removeState);\n    logger2.debug(\"received state from storage; validating response\");\n    if (this.settings.dpop && this.settings.dpop.store) {\n      const dpopProof = await this.getDpopProof(this.settings.dpop.store);\n      extraHeaders = { ...extraHeaders, \"DPoP\": dpopProof };\n    }\n    try {\n      await this._validator.validateSigninResponse(response, state, extraHeaders);\n    } catch (err) {\n      if (err instanceof ErrorDPoPNonce && this.settings.dpop) {\n        const dpopProof = await this.getDpopProof(this.settings.dpop.store, err.nonce);\n        extraHeaders[\"DPoP\"] = dpopProof;\n        await this._validator.validateSigninResponse(response, state, extraHeaders);\n      } else {\n        throw err;\n      }\n    }\n    return response;\n  }\n  async getDpopProof(dpopStore, nonce) {\n    let keyPair;\n    let dpopState;\n    if (!(await dpopStore.getAllKeys()).includes(this.settings.client_id)) {\n      keyPair = await CryptoUtils.generateDPoPKeys();\n      dpopState = new DPoPState(keyPair, nonce);\n      await dpopStore.set(this.settings.client_id, dpopState);\n    } else {\n      dpopState = await dpopStore.get(this.settings.client_id);\n      if (dpopState.nonce !== nonce && nonce) {\n        dpopState.nonce = nonce;\n        await dpopStore.set(this.settings.client_id, dpopState);\n      }\n    }\n    return await CryptoUtils.generateDPoPProof({\n      url: await this.metadataService.getTokenEndpoint(false),\n      httpMethod: \"POST\",\n      keyPair: dpopState.keys,\n      nonce: dpopState.nonce\n    });\n  }\n  async processResourceOwnerPasswordCredentials({\n    username,\n    password,\n    skipUserInfo = false,\n    extraTokenParams = {}\n  }) {\n    const tokenResponse = await this._tokenClient.exchangeCredentials({ username, password, ...extraTokenParams });\n    const signinResponse = new SigninResponse(new URLSearchParams());\n    Object.assign(signinResponse, tokenResponse);\n    await this._validator.validateCredentialsResponse(signinResponse, skipUserInfo);\n    return signinResponse;\n  }\n  async useRefreshToken({\n    state,\n    redirect_uri,\n    resource,\n    timeoutInSeconds,\n    extraHeaders,\n    extraTokenParams\n  }) {\n    var _a;\n    const logger2 = this._logger.create(\"useRefreshToken\");\n    let scope;\n    if (this.settings.refreshTokenAllowedScope === void 0) {\n      scope = state.scope;\n    } else {\n      const allowableScopes = this.settings.refreshTokenAllowedScope.split(\" \");\n      const providedScopes = ((_a = state.scope) == null ? void 0 : _a.split(\" \")) || [];\n      scope = providedScopes.filter((s) => allowableScopes.includes(s)).join(\" \");\n    }\n    if (this.settings.dpop && this.settings.dpop.store) {\n      const dpopProof = await this.getDpopProof(this.settings.dpop.store);\n      extraHeaders = { ...extraHeaders, \"DPoP\": dpopProof };\n    }\n    let result;\n    try {\n      result = await this._tokenClient.exchangeRefreshToken({\n        refresh_token: state.refresh_token,\n        // provide the (possible filtered) scope list\n        scope,\n        redirect_uri,\n        resource,\n        timeoutInSeconds,\n        extraHeaders,\n        ...extraTokenParams\n      });\n    } catch (err) {\n      if (err instanceof ErrorDPoPNonce && this.settings.dpop) {\n        extraHeaders[\"DPoP\"] = await this.getDpopProof(this.settings.dpop.store, err.nonce);\n        result = await this._tokenClient.exchangeRefreshToken({\n          refresh_token: state.refresh_token,\n          // provide the (possible filtered) scope list\n          scope,\n          redirect_uri,\n          resource,\n          timeoutInSeconds,\n          extraHeaders,\n          ...extraTokenParams\n        });\n      } else {\n        throw err;\n      }\n    }\n    const response = new SigninResponse(new URLSearchParams());\n    Object.assign(response, result);\n    logger2.debug(\"validating response\", response);\n    await this._validator.validateRefreshResponse(response, {\n      ...state,\n      // override the scope in the state handed over to the validator\n      // so it can set the granted scope to the requested scope in case none is included in the response\n      scope\n    });\n    return response;\n  }\n  async createSignoutRequest({\n    state,\n    id_token_hint,\n    client_id,\n    request_type,\n    url_state,\n    post_logout_redirect_uri = this.settings.post_logout_redirect_uri,\n    extraQueryParams = this.settings.extraQueryParams\n  } = {}) {\n    const logger2 = this._logger.create(\"createSignoutRequest\");\n    const url = await this.metadataService.getEndSessionEndpoint();\n    if (!url) {\n      logger2.throw(new Error(\"No end session endpoint\"));\n      throw null;\n    }\n    logger2.debug(\"Received end session endpoint\", url);\n    if (!client_id && post_logout_redirect_uri && !id_token_hint) {\n      client_id = this.settings.client_id;\n    }\n    const request = new SignoutRequest({\n      url,\n      id_token_hint,\n      client_id,\n      post_logout_redirect_uri,\n      state_data: state,\n      extraQueryParams,\n      request_type,\n      url_state\n    });\n    await this.clearStaleState();\n    const signoutState = request.state;\n    if (signoutState) {\n      logger2.debug(\"Signout request has state to persist\");\n      await this.settings.stateStore.set(signoutState.id, signoutState.toStorageString());\n    }\n    return request;\n  }\n  async readSignoutResponseState(url, removeState = false) {\n    const logger2 = this._logger.create(\"readSignoutResponseState\");\n    const response = new SignoutResponse(UrlUtils.readParams(url, this.settings.response_mode));\n    if (!response.state) {\n      logger2.debug(\"No state in response\");\n      if (response.error) {\n        logger2.warn(\"Response was error:\", response.error);\n        throw new ErrorResponse(response);\n      }\n      return { state: void 0, response };\n    }\n    const storedStateString = await this.settings.stateStore[removeState ? \"remove\" : \"get\"](response.state);\n    if (!storedStateString) {\n      logger2.throw(new Error(\"No matching state found in storage\"));\n      throw null;\n    }\n    const state = await State.fromStorageString(storedStateString);\n    return { state, response };\n  }\n  async processSignoutResponse(url) {\n    const logger2 = this._logger.create(\"processSignoutResponse\");\n    const { state, response } = await this.readSignoutResponseState(url, true);\n    if (state) {\n      logger2.debug(\"Received state from storage; validating response\");\n      this._validator.validateSignoutResponse(response, state);\n    } else {\n      logger2.debug(\"No state from storage; skipping response validation\");\n    }\n    return response;\n  }\n  clearStaleState() {\n    this._logger.create(\"clearStaleState\");\n    return State.clearStaleState(this.settings.stateStore, this.settings.staleStateAgeInSeconds);\n  }\n  async revokeToken(token, type) {\n    this._logger.create(\"revokeToken\");\n    return await this._tokenClient.revoke({\n      token,\n      token_type_hint: type\n    });\n  }\n};\n\n// src/SessionMonitor.ts\nvar SessionMonitor = class {\n  constructor(_userManager) {\n    this._userManager = _userManager;\n    this._logger = new Logger(\"SessionMonitor\");\n    this._start = async (user) => {\n      const session_state = user.session_state;\n      if (!session_state) {\n        return;\n      }\n      const logger2 = this._logger.create(\"_start\");\n      if (user.profile) {\n        this._sub = user.profile.sub;\n        logger2.debug(\"session_state\", session_state, \", sub\", this._sub);\n      } else {\n        this._sub = void 0;\n        logger2.debug(\"session_state\", session_state, \", anonymous user\");\n      }\n      if (this._checkSessionIFrame) {\n        this._checkSessionIFrame.start(session_state);\n        return;\n      }\n      try {\n        const url = await this._userManager.metadataService.getCheckSessionIframe();\n        if (url) {\n          logger2.debug(\"initializing check session iframe\");\n          const client_id = this._userManager.settings.client_id;\n          const intervalInSeconds = this._userManager.settings.checkSessionIntervalInSeconds;\n          const stopOnError = this._userManager.settings.stopCheckSessionOnError;\n          const checkSessionIFrame = new CheckSessionIFrame(this._callback, client_id, url, intervalInSeconds, stopOnError);\n          await checkSessionIFrame.load();\n          this._checkSessionIFrame = checkSessionIFrame;\n          checkSessionIFrame.start(session_state);\n        } else {\n          logger2.warn(\"no check session iframe found in the metadata\");\n        }\n      } catch (err) {\n        logger2.error(\"Error from getCheckSessionIframe:\", err instanceof Error ? err.message : err);\n      }\n    };\n    this._stop = () => {\n      const logger2 = this._logger.create(\"_stop\");\n      this._sub = void 0;\n      if (this._checkSessionIFrame) {\n        this._checkSessionIFrame.stop();\n      }\n      if (this._userManager.settings.monitorAnonymousSession) {\n        const timerHandle = setInterval(async () => {\n          clearInterval(timerHandle);\n          try {\n            const session = await this._userManager.querySessionStatus();\n            if (session) {\n              const tmpUser = {\n                session_state: session.session_state,\n                profile: session.sub ? {\n                  sub: session.sub\n                } : null\n              };\n              void this._start(tmpUser);\n            }\n          } catch (err) {\n            logger2.error(\"error from querySessionStatus\", err instanceof Error ? err.message : err);\n          }\n        }, 1e3);\n      }\n    };\n    this._callback = async () => {\n      const logger2 = this._logger.create(\"_callback\");\n      try {\n        const session = await this._userManager.querySessionStatus();\n        let raiseEvent = true;\n        if (session && this._checkSessionIFrame) {\n          if (session.sub === this._sub) {\n            raiseEvent = false;\n            this._checkSessionIFrame.start(session.session_state);\n            logger2.debug(\"same sub still logged in at OP, session state has changed, restarting check session iframe; session_state\", session.session_state);\n            await this._userManager.events._raiseUserSessionChanged();\n          } else {\n            logger2.debug(\"different subject signed into OP\", session.sub);\n          }\n        } else {\n          logger2.debug(\"subject no longer signed into OP\");\n        }\n        if (raiseEvent) {\n          if (this._sub) {\n            await this._userManager.events._raiseUserSignedOut();\n          } else {\n            await this._userManager.events._raiseUserSignedIn();\n          }\n        } else {\n          logger2.debug(\"no change in session detected, no event to raise\");\n        }\n      } catch (err) {\n        if (this._sub) {\n          logger2.debug(\"Error calling queryCurrentSigninSession; raising signed out event\", err);\n          await this._userManager.events._raiseUserSignedOut();\n        }\n      }\n    };\n    if (!_userManager) {\n      this._logger.throw(new Error(\"No user manager passed\"));\n    }\n    this._userManager.events.addUserLoaded(this._start);\n    this._userManager.events.addUserUnloaded(this._stop);\n    this._init().catch((err) => {\n      this._logger.error(err);\n    });\n  }\n  async _init() {\n    this._logger.create(\"_init\");\n    const user = await this._userManager.getUser();\n    if (user) {\n      void this._start(user);\n    } else if (this._userManager.settings.monitorAnonymousSession) {\n      const session = await this._userManager.querySessionStatus();\n      if (session) {\n        const tmpUser = {\n          session_state: session.session_state,\n          profile: session.sub ? {\n            sub: session.sub\n          } : null\n        };\n        void this._start(tmpUser);\n      }\n    }\n  }\n};\n\n// src/User.ts\nvar User = class _User {\n  constructor(args) {\n    var _a;\n    this.id_token = args.id_token;\n    this.session_state = (_a = args.session_state) != null ? _a : null;\n    this.access_token = args.access_token;\n    this.refresh_token = args.refresh_token;\n    this.token_type = args.token_type;\n    this.scope = args.scope;\n    this.profile = args.profile;\n    this.expires_at = args.expires_at;\n    this.state = args.userState;\n    this.url_state = args.url_state;\n  }\n  /** Computed number of seconds the access token has remaining. */\n  get expires_in() {\n    if (this.expires_at === void 0) {\n      return void 0;\n    }\n    return this.expires_at - Timer.getEpochTime();\n  }\n  set expires_in(value) {\n    if (value !== void 0) {\n      this.expires_at = Math.floor(value) + Timer.getEpochTime();\n    }\n  }\n  /** Computed value indicating if the access token is expired. */\n  get expired() {\n    const expires_in = this.expires_in;\n    if (expires_in === void 0) {\n      return void 0;\n    }\n    return expires_in <= 0;\n  }\n  /** Array representing the parsed values from the `scope`. */\n  get scopes() {\n    var _a, _b;\n    return (_b = (_a = this.scope) == null ? void 0 : _a.split(\" \")) != null ? _b : [];\n  }\n  toStorageString() {\n    new Logger(\"User\").create(\"toStorageString\");\n    return JSON.stringify({\n      id_token: this.id_token,\n      session_state: this.session_state,\n      access_token: this.access_token,\n      refresh_token: this.refresh_token,\n      token_type: this.token_type,\n      scope: this.scope,\n      profile: this.profile,\n      expires_at: this.expires_at\n    });\n  }\n  static fromStorageString(storageString) {\n    Logger.createStatic(\"User\", \"fromStorageString\");\n    return new _User(JSON.parse(storageString));\n  }\n};\n\n// src/navigators/AbstractChildWindow.ts\nvar messageSource = \"oidc-client\";\nvar AbstractChildWindow = class {\n  constructor() {\n    this._abort = new Event(\"Window navigation aborted\");\n    this._disposeHandlers = /* @__PURE__ */ new Set();\n    this._window = null;\n  }\n  async navigate(params) {\n    const logger2 = this._logger.create(\"navigate\");\n    if (!this._window) {\n      throw new Error(\"Attempted to navigate on a disposed window\");\n    }\n    logger2.debug(\"setting URL in window\");\n    this._window.location.replace(params.url);\n    const { url, keepOpen } = await new Promise((resolve, reject) => {\n      const listener = (e) => {\n        var _a;\n        const data = e.data;\n        const origin = (_a = params.scriptOrigin) != null ? _a : window.location.origin;\n        if (e.origin !== origin || (data == null ? void 0 : data.source) !== messageSource) {\n          return;\n        }\n        try {\n          const state = UrlUtils.readParams(data.url, params.response_mode).get(\"state\");\n          if (!state) {\n            logger2.warn(\"no state found in response url\");\n          }\n          if (e.source !== this._window && state !== params.state) {\n            return;\n          }\n        } catch {\n          this._dispose();\n          reject(new Error(\"Invalid response from window\"));\n        }\n        resolve(data);\n      };\n      window.addEventListener(\"message\", listener, false);\n      this._disposeHandlers.add(() => window.removeEventListener(\"message\", listener, false));\n      const channel = new BroadcastChannel(`oidc-client-popup-${params.state}`);\n      channel.addEventListener(\"message\", listener, false);\n      this._disposeHandlers.add(() => channel.close());\n      this._disposeHandlers.add(this._abort.addHandler((reason) => {\n        this._dispose();\n        reject(reason);\n      }));\n    });\n    logger2.debug(\"got response from window\");\n    this._dispose();\n    if (!keepOpen) {\n      this.close();\n    }\n    return { url };\n  }\n  _dispose() {\n    this._logger.create(\"_dispose\");\n    for (const dispose of this._disposeHandlers) {\n      dispose();\n    }\n    this._disposeHandlers.clear();\n  }\n  static _notifyParent(parent, url, keepOpen = false, targetOrigin = window.location.origin) {\n    const msgData = {\n      source: messageSource,\n      url,\n      keepOpen\n    };\n    const logger2 = new Logger(\"_notifyParent\");\n    if (parent) {\n      logger2.debug(\"With parent. Using parent.postMessage.\");\n      parent.postMessage(msgData, targetOrigin);\n    } else {\n      logger2.debug(\"No parent. Using BroadcastChannel.\");\n      const state = new URL(url).searchParams.get(\"state\");\n      if (!state) {\n        throw new Error(\"No parent and no state in URL. Can't complete notification.\");\n      }\n      const channel = new BroadcastChannel(`oidc-client-popup-${state}`);\n      channel.postMessage(msgData);\n      channel.close();\n    }\n  }\n};\n\n// src/UserManagerSettings.ts\nvar DefaultPopupWindowFeatures = {\n  location: false,\n  toolbar: false,\n  height: 640,\n  closePopupWindowAfterInSeconds: -1\n};\nvar DefaultPopupTarget = \"_blank\";\nvar DefaultAccessTokenExpiringNotificationTimeInSeconds = 60;\nvar DefaultCheckSessionIntervalInSeconds = 2;\nvar DefaultSilentRequestTimeoutInSeconds = 10;\nvar UserManagerSettingsStore = class extends OidcClientSettingsStore {\n  constructor(args) {\n    const {\n      popup_redirect_uri = args.redirect_uri,\n      popup_post_logout_redirect_uri = args.post_logout_redirect_uri,\n      popupWindowFeatures = DefaultPopupWindowFeatures,\n      popupWindowTarget = DefaultPopupTarget,\n      redirectMethod = \"assign\",\n      redirectTarget = \"self\",\n      iframeNotifyParentOrigin = args.iframeNotifyParentOrigin,\n      iframeScriptOrigin = args.iframeScriptOrigin,\n      requestTimeoutInSeconds,\n      silent_redirect_uri = args.redirect_uri,\n      silentRequestTimeoutInSeconds,\n      automaticSilentRenew = true,\n      validateSubOnSilentRenew = true,\n      includeIdTokenInSilentRenew = false,\n      monitorSession = false,\n      monitorAnonymousSession = false,\n      checkSessionIntervalInSeconds = DefaultCheckSessionIntervalInSeconds,\n      query_status_response_type = \"code\",\n      stopCheckSessionOnError = true,\n      revokeTokenTypes = [\"access_token\", \"refresh_token\"],\n      revokeTokensOnSignout = false,\n      includeIdTokenInSilentSignout = false,\n      accessTokenExpiringNotificationTimeInSeconds = DefaultAccessTokenExpiringNotificationTimeInSeconds,\n      userStore\n    } = args;\n    super(args);\n    this.popup_redirect_uri = popup_redirect_uri;\n    this.popup_post_logout_redirect_uri = popup_post_logout_redirect_uri;\n    this.popupWindowFeatures = popupWindowFeatures;\n    this.popupWindowTarget = popupWindowTarget;\n    this.redirectMethod = redirectMethod;\n    this.redirectTarget = redirectTarget;\n    this.iframeNotifyParentOrigin = iframeNotifyParentOrigin;\n    this.iframeScriptOrigin = iframeScriptOrigin;\n    this.silent_redirect_uri = silent_redirect_uri;\n    this.silentRequestTimeoutInSeconds = silentRequestTimeoutInSeconds || requestTimeoutInSeconds || DefaultSilentRequestTimeoutInSeconds;\n    this.automaticSilentRenew = automaticSilentRenew;\n    this.validateSubOnSilentRenew = validateSubOnSilentRenew;\n    this.includeIdTokenInSilentRenew = includeIdTokenInSilentRenew;\n    this.monitorSession = monitorSession;\n    this.monitorAnonymousSession = monitorAnonymousSession;\n    this.checkSessionIntervalInSeconds = checkSessionIntervalInSeconds;\n    this.stopCheckSessionOnError = stopCheckSessionOnError;\n    this.query_status_response_type = query_status_response_type;\n    this.revokeTokenTypes = revokeTokenTypes;\n    this.revokeTokensOnSignout = revokeTokensOnSignout;\n    this.includeIdTokenInSilentSignout = includeIdTokenInSilentSignout;\n    this.accessTokenExpiringNotificationTimeInSeconds = accessTokenExpiringNotificationTimeInSeconds;\n    if (userStore) {\n      this.userStore = userStore;\n    } else {\n      const store = typeof window !== \"undefined\" ? window.sessionStorage : new InMemoryWebStorage();\n      this.userStore = new WebStorageStateStore({ store });\n    }\n  }\n};\n\n// src/navigators/IFrameWindow.ts\nvar IFrameWindow = class _IFrameWindow extends AbstractChildWindow {\n  constructor({\n    silentRequestTimeoutInSeconds = DefaultSilentRequestTimeoutInSeconds\n  }) {\n    super();\n    this._logger = new Logger(\"IFrameWindow\");\n    this._timeoutInSeconds = silentRequestTimeoutInSeconds;\n    this._frame = _IFrameWindow.createHiddenIframe();\n    this._window = this._frame.contentWindow;\n  }\n  static createHiddenIframe() {\n    const iframe = window.document.createElement(\"iframe\");\n    iframe.style.visibility = \"hidden\";\n    iframe.style.position = \"fixed\";\n    iframe.style.left = \"-1000px\";\n    iframe.style.top = \"0\";\n    iframe.width = \"0\";\n    iframe.height = \"0\";\n    window.document.body.appendChild(iframe);\n    return iframe;\n  }\n  async navigate(params) {\n    this._logger.debug(\"navigate: Using timeout of:\", this._timeoutInSeconds);\n    const timer = setTimeout(() => void this._abort.raise(new ErrorTimeout(\"IFrame timed out without a response\")), this._timeoutInSeconds * 1e3);\n    this._disposeHandlers.add(() => clearTimeout(timer));\n    return await super.navigate(params);\n  }\n  close() {\n    var _a;\n    if (this._frame) {\n      if (this._frame.parentNode) {\n        this._frame.addEventListener(\"load\", (ev) => {\n          var _a2;\n          const frame = ev.target;\n          (_a2 = frame.parentNode) == null ? void 0 : _a2.removeChild(frame);\n          void this._abort.raise(new Error(\"IFrame removed from DOM\"));\n        }, true);\n        (_a = this._frame.contentWindow) == null ? void 0 : _a.location.replace(\"about:blank\");\n      }\n      this._frame = null;\n    }\n    this._window = null;\n  }\n  static notifyParent(url, targetOrigin) {\n    return super._notifyParent(window.parent, url, false, targetOrigin);\n  }\n};\n\n// src/navigators/IFrameNavigator.ts\nvar IFrameNavigator = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"IFrameNavigator\");\n  }\n  async prepare({\n    silentRequestTimeoutInSeconds = this._settings.silentRequestTimeoutInSeconds\n  }) {\n    return new IFrameWindow({ silentRequestTimeoutInSeconds });\n  }\n  async callback(url) {\n    this._logger.create(\"callback\");\n    IFrameWindow.notifyParent(url, this._settings.iframeNotifyParentOrigin);\n  }\n};\n\n// src/navigators/PopupWindow.ts\nvar checkForPopupClosedInterval = 500;\nvar second = 1e3;\nvar PopupWindow = class extends AbstractChildWindow {\n  constructor({\n    popupWindowTarget = DefaultPopupTarget,\n    popupWindowFeatures = {},\n    popupSignal\n  }) {\n    super();\n    this._logger = new Logger(\"PopupWindow\");\n    const centeredPopup = PopupUtils.center({ ...DefaultPopupWindowFeatures, ...popupWindowFeatures });\n    this._window = window.open(void 0, popupWindowTarget, PopupUtils.serialize(centeredPopup));\n    if (popupSignal) {\n      popupSignal.addEventListener(\"abort\", () => {\n        var _a;\n        void this._abort.raise(new Error((_a = popupSignal.reason) != null ? _a : \"Popup aborted\"));\n      });\n    }\n    if (popupWindowFeatures.closePopupWindowAfterInSeconds && popupWindowFeatures.closePopupWindowAfterInSeconds > 0) {\n      setTimeout(() => {\n        if (!this._window || typeof this._window.closed !== \"boolean\" || this._window.closed) {\n          void this._abort.raise(new Error(\"Popup blocked by user\"));\n          return;\n        }\n        this.close();\n      }, popupWindowFeatures.closePopupWindowAfterInSeconds * second);\n    }\n  }\n  async navigate(params) {\n    var _a;\n    (_a = this._window) == null ? void 0 : _a.focus();\n    const popupClosedInterval = setInterval(() => {\n      if (!this._window || this._window.closed) {\n        this._logger.debug(\"Popup closed by user or isolated by redirect\");\n        clearPopupClosedInterval();\n        this._disposeHandlers.delete(clearPopupClosedInterval);\n      }\n    }, checkForPopupClosedInterval);\n    const clearPopupClosedInterval = () => clearInterval(popupClosedInterval);\n    this._disposeHandlers.add(clearPopupClosedInterval);\n    return await super.navigate(params);\n  }\n  close() {\n    if (this._window) {\n      if (!this._window.closed) {\n        this._window.close();\n        void this._abort.raise(new Error(\"Popup closed\"));\n      }\n    }\n    this._window = null;\n  }\n  static notifyOpener(url, keepOpen) {\n    super._notifyParent(window.opener, url, keepOpen);\n    if (!keepOpen && !window.opener) {\n      window.close();\n    }\n  }\n};\n\n// src/navigators/PopupNavigator.ts\nvar PopupNavigator = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"PopupNavigator\");\n  }\n  async prepare({\n    popupWindowFeatures = this._settings.popupWindowFeatures,\n    popupWindowTarget = this._settings.popupWindowTarget,\n    popupSignal\n  }) {\n    return new PopupWindow({ popupWindowFeatures, popupWindowTarget, popupSignal });\n  }\n  async callback(url, { keepOpen = false }) {\n    this._logger.create(\"callback\");\n    PopupWindow.notifyOpener(url, keepOpen);\n  }\n};\n\n// src/navigators/RedirectNavigator.ts\nvar RedirectNavigator = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"RedirectNavigator\");\n  }\n  async prepare({\n    redirectMethod = this._settings.redirectMethod,\n    redirectTarget = this._settings.redirectTarget\n  }) {\n    var _a;\n    this._logger.create(\"prepare\");\n    let targetWindow = window.self;\n    if (redirectTarget === \"top\") {\n      targetWindow = (_a = window.top) != null ? _a : window.self;\n    }\n    const redirect = targetWindow.location[redirectMethod].bind(targetWindow.location);\n    let abort;\n    return {\n      navigate: async (params) => {\n        this._logger.create(\"navigate\");\n        const promise = new Promise((resolve, reject) => {\n          abort = reject;\n        });\n        redirect(params.url);\n        return await promise;\n      },\n      close: () => {\n        this._logger.create(\"close\");\n        abort == null ? void 0 : abort(new Error(\"Redirect aborted\"));\n        targetWindow.stop();\n      }\n    };\n  }\n  async callback() {\n    return;\n  }\n};\n\n// src/UserManagerEvents.ts\nvar UserManagerEvents = class extends AccessTokenEvents {\n  constructor(settings) {\n    super({ expiringNotificationTimeInSeconds: settings.accessTokenExpiringNotificationTimeInSeconds });\n    this._logger = new Logger(\"UserManagerEvents\");\n    this._userLoaded = new Event(\"User loaded\");\n    this._userUnloaded = new Event(\"User unloaded\");\n    this._silentRenewError = new Event(\"Silent renew error\");\n    this._userSignedIn = new Event(\"User signed in\");\n    this._userSignedOut = new Event(\"User signed out\");\n    this._userSessionChanged = new Event(\"User session changed\");\n  }\n  async load(user, raiseEvent = true) {\n    await super.load(user);\n    if (raiseEvent) {\n      await this._userLoaded.raise(user);\n    }\n  }\n  async unload() {\n    await super.unload();\n    await this._userUnloaded.raise();\n  }\n  /**\n   * Add callback: Raised when a user session has been established (or re-established).\n   */\n  addUserLoaded(cb) {\n    return this._userLoaded.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when a user session has been established (or re-established).\n   */\n  removeUserLoaded(cb) {\n    return this._userLoaded.removeHandler(cb);\n  }\n  /**\n   * Add callback: Raised when a user session has been terminated.\n   */\n  addUserUnloaded(cb) {\n    return this._userUnloaded.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when a user session has been terminated.\n   */\n  removeUserUnloaded(cb) {\n    return this._userUnloaded.removeHandler(cb);\n  }\n  /**\n   * Add callback: Raised when the automatic silent renew has failed.\n   */\n  addSilentRenewError(cb) {\n    return this._silentRenewError.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when the automatic silent renew has failed.\n   */\n  removeSilentRenewError(cb) {\n    return this._silentRenewError.removeHandler(cb);\n  }\n  /**\n   * @internal\n   */\n  async _raiseSilentRenewError(e) {\n    await this._silentRenewError.raise(e);\n  }\n  /**\n   * Add callback: Raised when the user is signed in (when `monitorSession` is set).\n   * @see {@link UserManagerSettings.monitorSession}\n   */\n  addUserSignedIn(cb) {\n    return this._userSignedIn.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when the user is signed in (when `monitorSession` is set).\n   */\n  removeUserSignedIn(cb) {\n    this._userSignedIn.removeHandler(cb);\n  }\n  /**\n   * @internal\n   */\n  async _raiseUserSignedIn() {\n    await this._userSignedIn.raise();\n  }\n  /**\n   * Add callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).\n   * @see {@link UserManagerSettings.monitorSession}\n   */\n  addUserSignedOut(cb) {\n    return this._userSignedOut.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).\n   */\n  removeUserSignedOut(cb) {\n    this._userSignedOut.removeHandler(cb);\n  }\n  /**\n   * @internal\n   */\n  async _raiseUserSignedOut() {\n    await this._userSignedOut.raise();\n  }\n  /**\n   * Add callback: Raised when the user session changed (when `monitorSession` is set).\n   * @see {@link UserManagerSettings.monitorSession}\n   */\n  addUserSessionChanged(cb) {\n    return this._userSessionChanged.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when the user session changed (when `monitorSession` is set).\n   */\n  removeUserSessionChanged(cb) {\n    this._userSessionChanged.removeHandler(cb);\n  }\n  /**\n   * @internal\n   */\n  async _raiseUserSessionChanged() {\n    await this._userSessionChanged.raise();\n  }\n};\n\n// src/SilentRenewService.ts\nvar SilentRenewService = class {\n  constructor(_userManager) {\n    this._userManager = _userManager;\n    this._logger = new Logger(\"SilentRenewService\");\n    this._isStarted = false;\n    this._retryTimer = new Timer(\"Retry Silent Renew\");\n    this._tokenExpiring = async () => {\n      const logger2 = this._logger.create(\"_tokenExpiring\");\n      try {\n        await this._userManager.signinSilent();\n        logger2.debug(\"silent token renewal successful\");\n      } catch (err) {\n        if (err instanceof ErrorTimeout) {\n          logger2.warn(\"ErrorTimeout from signinSilent:\", err, \"retry in 5s\");\n          this._retryTimer.init(5);\n          return;\n        }\n        logger2.error(\"Error from signinSilent:\", err);\n        await this._userManager.events._raiseSilentRenewError(err);\n      }\n    };\n  }\n  async start() {\n    const logger2 = this._logger.create(\"start\");\n    if (!this._isStarted) {\n      this._isStarted = true;\n      this._userManager.events.addAccessTokenExpiring(this._tokenExpiring);\n      this._retryTimer.addHandler(this._tokenExpiring);\n      try {\n        await this._userManager.getUser();\n      } catch (err) {\n        logger2.error(\"getUser error\", err);\n      }\n    }\n  }\n  stop() {\n    if (this._isStarted) {\n      this._retryTimer.cancel();\n      this._retryTimer.removeHandler(this._tokenExpiring);\n      this._userManager.events.removeAccessTokenExpiring(this._tokenExpiring);\n      this._isStarted = false;\n    }\n  }\n};\n\n// src/RefreshState.ts\nvar RefreshState = class {\n  constructor(args) {\n    this.refresh_token = args.refresh_token;\n    this.id_token = args.id_token;\n    this.session_state = args.session_state;\n    this.scope = args.scope;\n    this.profile = args.profile;\n    this.data = args.state;\n  }\n};\n\n// src/UserManager.ts\nvar UserManager = class {\n  constructor(settings, redirectNavigator, popupNavigator, iframeNavigator) {\n    this._logger = new Logger(\"UserManager\");\n    this.settings = new UserManagerSettingsStore(settings);\n    this._client = new OidcClient(settings);\n    this._redirectNavigator = redirectNavigator != null ? redirectNavigator : new RedirectNavigator(this.settings);\n    this._popupNavigator = popupNavigator != null ? popupNavigator : new PopupNavigator(this.settings);\n    this._iframeNavigator = iframeNavigator != null ? iframeNavigator : new IFrameNavigator(this.settings);\n    this._events = new UserManagerEvents(this.settings);\n    this._silentRenewService = new SilentRenewService(this);\n    if (this.settings.automaticSilentRenew) {\n      this.startSilentRenew();\n    }\n    this._sessionMonitor = null;\n    if (this.settings.monitorSession) {\n      this._sessionMonitor = new SessionMonitor(this);\n    }\n  }\n  /**\n   * Get object used to register for events raised by the `UserManager`.\n   */\n  get events() {\n    return this._events;\n  }\n  /**\n   * Get object used to access the metadata configuration of the identity provider.\n   */\n  get metadataService() {\n    return this._client.metadataService;\n  }\n  /**\n   * Load the `User` object for the currently authenticated user.\n   *\n   * @param raiseEvent - If `true`, the `UserLoaded` event will be raised. Defaults to false.\n   * @returns A promise\n   */\n  async getUser(raiseEvent = false) {\n    const logger2 = this._logger.create(\"getUser\");\n    const user = await this._loadUser();\n    if (user) {\n      logger2.info(\"user loaded\");\n      await this._events.load(user, raiseEvent);\n      return user;\n    }\n    logger2.info(\"user not found in storage\");\n    return null;\n  }\n  /**\n   * Remove from any storage the currently authenticated user.\n   *\n   * @returns A promise\n   */\n  async removeUser() {\n    const logger2 = this._logger.create(\"removeUser\");\n    await this.storeUser(null);\n    logger2.info(\"user removed from storage\");\n    await this._events.unload();\n  }\n  /**\n   * Trigger a redirect of the current window to the authorization endpoint.\n   *\n   * @returns A promise\n   *\n   * @throws `Error` In cases of wrong authentication.\n   */\n  async signinRedirect(args = {}) {\n    var _a;\n    this._logger.create(\"signinRedirect\");\n    const {\n      redirectMethod,\n      ...requestArgs\n    } = args;\n    let dpopJkt;\n    if ((_a = this.settings.dpop) == null ? void 0 : _a.bind_authorization_code) {\n      dpopJkt = await this.generateDPoPJkt(this.settings.dpop);\n    }\n    const handle = await this._redirectNavigator.prepare({ redirectMethod });\n    await this._signinStart({\n      request_type: \"si:r\",\n      dpopJkt,\n      ...requestArgs\n    }, handle);\n  }\n  /**\n   * Process the response (callback) from the authorization endpoint.\n   * It is recommended to use {@link UserManager.signinCallback} instead.\n   *\n   * @returns A promise containing the authenticated `User`.\n   *\n   * @see {@link UserManager.signinCallback}\n   */\n  async signinRedirectCallback(url = window.location.href) {\n    const logger2 = this._logger.create(\"signinRedirectCallback\");\n    const user = await this._signinEnd(url);\n    if (user.profile && user.profile.sub) {\n      logger2.info(\"success, signed in subject\", user.profile.sub);\n    } else {\n      logger2.info(\"no subject\");\n    }\n    return user;\n  }\n  /**\n   * Trigger the signin with user/password.\n   *\n   * @returns A promise containing the authenticated `User`.\n   * @throws {@link ErrorResponse} In cases of wrong authentication.\n   */\n  async signinResourceOwnerCredentials({\n    username,\n    password,\n    skipUserInfo = false\n  }) {\n    const logger2 = this._logger.create(\"signinResourceOwnerCredential\");\n    const signinResponse = await this._client.processResourceOwnerPasswordCredentials({\n      username,\n      password,\n      skipUserInfo,\n      extraTokenParams: this.settings.extraTokenParams\n    });\n    logger2.debug(\"got signin response\");\n    const user = await this._buildUser(signinResponse);\n    if (user.profile && user.profile.sub) {\n      logger2.info(\"success, signed in subject\", user.profile.sub);\n    } else {\n      logger2.info(\"no subject\");\n    }\n    return user;\n  }\n  /**\n   * Trigger a request (via a popup window) to the authorization endpoint.\n   *\n   * @returns A promise containing the authenticated `User`.\n   * @throws `Error` In cases of wrong authentication.\n   */\n  async signinPopup(args = {}) {\n    var _a;\n    const logger2 = this._logger.create(\"signinPopup\");\n    let dpopJkt;\n    if ((_a = this.settings.dpop) == null ? void 0 : _a.bind_authorization_code) {\n      dpopJkt = await this.generateDPoPJkt(this.settings.dpop);\n    }\n    const {\n      popupWindowFeatures,\n      popupWindowTarget,\n      popupSignal,\n      ...requestArgs\n    } = args;\n    const url = this.settings.popup_redirect_uri;\n    if (!url) {\n      logger2.throw(new Error(\"No popup_redirect_uri configured\"));\n    }\n    const handle = await this._popupNavigator.prepare({ popupWindowFeatures, popupWindowTarget, popupSignal });\n    const user = await this._signin({\n      request_type: \"si:p\",\n      redirect_uri: url,\n      display: \"popup\",\n      dpopJkt,\n      ...requestArgs\n    }, handle);\n    if (user) {\n      if (user.profile && user.profile.sub) {\n        logger2.info(\"success, signed in subject\", user.profile.sub);\n      } else {\n        logger2.info(\"no subject\");\n      }\n    }\n    return user;\n  }\n  /**\n   * Notify the opening window of response (callback) from the authorization endpoint.\n   * It is recommended to use {@link UserManager.signinCallback} instead.\n   *\n   * @returns A promise\n   *\n   * @see {@link UserManager.signinCallback}\n   */\n  async signinPopupCallback(url = window.location.href, keepOpen = false) {\n    const logger2 = this._logger.create(\"signinPopupCallback\");\n    await this._popupNavigator.callback(url, { keepOpen });\n    logger2.info(\"success\");\n  }\n  /**\n   * Trigger a silent request (via refresh token or an iframe) to the authorization endpoint.\n   *\n   * @returns A promise that contains the authenticated `User`.\n   */\n  async signinSilent(args = {}) {\n    var _a, _b;\n    const logger2 = this._logger.create(\"signinSilent\");\n    const {\n      silentRequestTimeoutInSeconds,\n      ...requestArgs\n    } = args;\n    let user = await this._loadUser();\n    if (user == null ? void 0 : user.refresh_token) {\n      logger2.debug(\"using refresh token\");\n      const state = new RefreshState(user);\n      return await this._useRefreshToken({\n        state,\n        redirect_uri: requestArgs.redirect_uri,\n        resource: requestArgs.resource,\n        extraTokenParams: requestArgs.extraTokenParams,\n        timeoutInSeconds: silentRequestTimeoutInSeconds\n      });\n    }\n    let dpopJkt;\n    if ((_a = this.settings.dpop) == null ? void 0 : _a.bind_authorization_code) {\n      dpopJkt = await this.generateDPoPJkt(this.settings.dpop);\n    }\n    const url = this.settings.silent_redirect_uri;\n    if (!url) {\n      logger2.throw(new Error(\"No silent_redirect_uri configured\"));\n    }\n    let verifySub;\n    if (user && this.settings.validateSubOnSilentRenew) {\n      logger2.debug(\"subject prior to silent renew:\", user.profile.sub);\n      verifySub = user.profile.sub;\n    }\n    const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n    user = await this._signin({\n      request_type: \"si:s\",\n      redirect_uri: url,\n      prompt: \"none\",\n      id_token_hint: this.settings.includeIdTokenInSilentRenew ? user == null ? void 0 : user.id_token : void 0,\n      dpopJkt,\n      ...requestArgs\n    }, handle, verifySub);\n    if (user) {\n      if ((_b = user.profile) == null ? void 0 : _b.sub) {\n        logger2.info(\"success, signed in subject\", user.profile.sub);\n      } else {\n        logger2.info(\"no subject\");\n      }\n    }\n    return user;\n  }\n  async _useRefreshToken(args) {\n    const response = await this._client.useRefreshToken({\n      timeoutInSeconds: this.settings.silentRequestTimeoutInSeconds,\n      ...args\n    });\n    const user = new User({ ...args.state, ...response });\n    await this.storeUser(user);\n    await this._events.load(user);\n    return user;\n  }\n  /**\n   *\n   * Notify the parent window of response (callback) from the authorization endpoint.\n   * It is recommended to use {@link UserManager.signinCallback} instead.\n   *\n   * @returns A promise\n   *\n   * @see {@link UserManager.signinCallback}\n   */\n  async signinSilentCallback(url = window.location.href) {\n    const logger2 = this._logger.create(\"signinSilentCallback\");\n    await this._iframeNavigator.callback(url);\n    logger2.info(\"success\");\n  }\n  /**\n   * Process any response (callback) from the authorization endpoint, by dispatching the request_type\n   * and executing one of the following functions:\n   * - {@link UserManager.signinRedirectCallback}\n   * - {@link UserManager.signinPopupCallback}\n   * - {@link UserManager.signinSilentCallback}\n   *\n   * @throws `Error` If request_type is unknown or signin cannot be processed.\n   */\n  async signinCallback(url = window.location.href) {\n    const { state } = await this._client.readSigninResponseState(url);\n    switch (state.request_type) {\n      case \"si:r\":\n        return await this.signinRedirectCallback(url);\n      case \"si:p\":\n        await this.signinPopupCallback(url);\n        break;\n      case \"si:s\":\n        await this.signinSilentCallback(url);\n        break;\n      default:\n        throw new Error(\"invalid response_type in state\");\n    }\n    return void 0;\n  }\n  /**\n   * Process any response (callback) from the end session endpoint, by dispatching the request_type\n   * and executing one of the following functions:\n   * - {@link UserManager.signoutRedirectCallback}\n   * - {@link UserManager.signoutPopupCallback}\n   * - {@link UserManager.signoutSilentCallback}\n   *\n   * @throws `Error` If request_type is unknown or signout cannot be processed.\n   */\n  async signoutCallback(url = window.location.href, keepOpen = false) {\n    const { state } = await this._client.readSignoutResponseState(url);\n    if (!state) {\n      return void 0;\n    }\n    switch (state.request_type) {\n      case \"so:r\":\n        return await this.signoutRedirectCallback(url);\n      case \"so:p\":\n        await this.signoutPopupCallback(url, keepOpen);\n        break;\n      case \"so:s\":\n        await this.signoutSilentCallback(url);\n        break;\n      default:\n        throw new Error(\"invalid response_type in state\");\n    }\n    return void 0;\n  }\n  /**\n   * Query OP for user's current signin status.\n   *\n   * @returns A promise object with session_state and subject identifier.\n   */\n  async querySessionStatus(args = {}) {\n    const logger2 = this._logger.create(\"querySessionStatus\");\n    const {\n      silentRequestTimeoutInSeconds,\n      ...requestArgs\n    } = args;\n    const url = this.settings.silent_redirect_uri;\n    if (!url) {\n      logger2.throw(new Error(\"No silent_redirect_uri configured\"));\n    }\n    const user = await this._loadUser();\n    const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n    const navResponse = await this._signinStart({\n      request_type: \"si:s\",\n      // this acts like a signin silent\n      redirect_uri: url,\n      prompt: \"none\",\n      id_token_hint: this.settings.includeIdTokenInSilentRenew ? user == null ? void 0 : user.id_token : void 0,\n      response_type: this.settings.query_status_response_type,\n      scope: \"openid\",\n      skipUserInfo: true,\n      ...requestArgs\n    }, handle);\n    try {\n      const extraHeaders = {};\n      const signinResponse = await this._client.processSigninResponse(navResponse.url, extraHeaders);\n      logger2.debug(\"got signin response\");\n      if (signinResponse.session_state && signinResponse.profile.sub) {\n        logger2.info(\"success for subject\", signinResponse.profile.sub);\n        return {\n          session_state: signinResponse.session_state,\n          sub: signinResponse.profile.sub\n        };\n      }\n      logger2.info(\"success, user not authenticated\");\n      return null;\n    } catch (err) {\n      if (this.settings.monitorAnonymousSession && err instanceof ErrorResponse) {\n        switch (err.error) {\n          case \"login_required\":\n          case \"consent_required\":\n          case \"interaction_required\":\n          case \"account_selection_required\":\n            logger2.info(\"success for anonymous user\");\n            return {\n              session_state: err.session_state\n            };\n        }\n      }\n      throw err;\n    }\n  }\n  async _signin(args, handle, verifySub) {\n    const navResponse = await this._signinStart(args, handle);\n    return await this._signinEnd(navResponse.url, verifySub);\n  }\n  async _signinStart(args, handle) {\n    const logger2 = this._logger.create(\"_signinStart\");\n    try {\n      const signinRequest = await this._client.createSigninRequest(args);\n      logger2.debug(\"got signin request\");\n      return await handle.navigate({\n        url: signinRequest.url,\n        state: signinRequest.state.id,\n        response_mode: signinRequest.state.response_mode,\n        scriptOrigin: this.settings.iframeScriptOrigin\n      });\n    } catch (err) {\n      logger2.debug(\"error after preparing navigator, closing navigator window\");\n      handle.close();\n      throw err;\n    }\n  }\n  async _signinEnd(url, verifySub) {\n    const logger2 = this._logger.create(\"_signinEnd\");\n    const extraHeaders = {};\n    const signinResponse = await this._client.processSigninResponse(url, extraHeaders);\n    logger2.debug(\"got signin response\");\n    const user = await this._buildUser(signinResponse, verifySub);\n    return user;\n  }\n  async _buildUser(signinResponse, verifySub) {\n    const logger2 = this._logger.create(\"_buildUser\");\n    const user = new User(signinResponse);\n    if (verifySub) {\n      if (verifySub !== user.profile.sub) {\n        logger2.debug(\"current user does not match user returned from signin. sub from signin:\", user.profile.sub);\n        throw new ErrorResponse({ ...signinResponse, error: \"login_required\" });\n      }\n      logger2.debug(\"current user matches user returned from signin\");\n    }\n    await this.storeUser(user);\n    logger2.debug(\"user stored\");\n    await this._events.load(user);\n    return user;\n  }\n  /**\n   * Trigger a redirect of the current window to the end session endpoint.\n   *\n   * @returns A promise\n   */\n  async signoutRedirect(args = {}) {\n    const logger2 = this._logger.create(\"signoutRedirect\");\n    const {\n      redirectMethod,\n      ...requestArgs\n    } = args;\n    const handle = await this._redirectNavigator.prepare({ redirectMethod });\n    await this._signoutStart({\n      request_type: \"so:r\",\n      post_logout_redirect_uri: this.settings.post_logout_redirect_uri,\n      ...requestArgs\n    }, handle);\n    logger2.info(\"success\");\n  }\n  /**\n   * Process response (callback) from the end session endpoint.\n   * It is recommended to use {@link UserManager.signoutCallback} instead.\n   *\n   * @returns A promise containing signout response\n   *\n   * @see {@link UserManager.signoutCallback}\n   */\n  async signoutRedirectCallback(url = window.location.href) {\n    const logger2 = this._logger.create(\"signoutRedirectCallback\");\n    const response = await this._signoutEnd(url);\n    logger2.info(\"success\");\n    return response;\n  }\n  /**\n   * Trigger a redirect of a popup window to the end session endpoint.\n   *\n   * @returns A promise\n   */\n  async signoutPopup(args = {}) {\n    const logger2 = this._logger.create(\"signoutPopup\");\n    const {\n      popupWindowFeatures,\n      popupWindowTarget,\n      popupSignal,\n      ...requestArgs\n    } = args;\n    const url = this.settings.popup_post_logout_redirect_uri;\n    const handle = await this._popupNavigator.prepare({ popupWindowFeatures, popupWindowTarget, popupSignal });\n    await this._signout({\n      request_type: \"so:p\",\n      post_logout_redirect_uri: url,\n      // we're putting a dummy entry in here because we\n      // need a unique id from the state for notification\n      // to the parent window, which is necessary if we\n      // plan to return back to the client after signout\n      // and so we can close the popup after signout\n      state: url == null ? void 0 : {},\n      ...requestArgs\n    }, handle);\n    logger2.info(\"success\");\n  }\n  /**\n   * Process response (callback) from the end session endpoint from a popup window.\n   * It is recommended to use {@link UserManager.signoutCallback} instead.\n   *\n   * @returns A promise\n   *\n   * @see {@link UserManager.signoutCallback}\n   */\n  async signoutPopupCallback(url = window.location.href, keepOpen = false) {\n    const logger2 = this._logger.create(\"signoutPopupCallback\");\n    await this._popupNavigator.callback(url, { keepOpen });\n    logger2.info(\"success\");\n  }\n  async _signout(args, handle) {\n    const navResponse = await this._signoutStart(args, handle);\n    return await this._signoutEnd(navResponse.url);\n  }\n  async _signoutStart(args = {}, handle) {\n    var _a;\n    const logger2 = this._logger.create(\"_signoutStart\");\n    try {\n      const user = await this._loadUser();\n      logger2.debug(\"loaded current user from storage\");\n      if (this.settings.revokeTokensOnSignout) {\n        await this._revokeInternal(user);\n      }\n      const id_token = args.id_token_hint || user && user.id_token;\n      if (id_token) {\n        logger2.debug(\"setting id_token_hint in signout request\");\n        args.id_token_hint = id_token;\n      }\n      await this.removeUser();\n      logger2.debug(\"user removed, creating signout request\");\n      const signoutRequest = await this._client.createSignoutRequest(args);\n      logger2.debug(\"got signout request\");\n      return await handle.navigate({\n        url: signoutRequest.url,\n        state: (_a = signoutRequest.state) == null ? void 0 : _a.id,\n        scriptOrigin: this.settings.iframeScriptOrigin\n      });\n    } catch (err) {\n      logger2.debug(\"error after preparing navigator, closing navigator window\");\n      handle.close();\n      throw err;\n    }\n  }\n  async _signoutEnd(url) {\n    const logger2 = this._logger.create(\"_signoutEnd\");\n    const signoutResponse = await this._client.processSignoutResponse(url);\n    logger2.debug(\"got signout response\");\n    return signoutResponse;\n  }\n  /**\n   * Trigger a silent request (via an iframe) to the end session endpoint.\n   *\n   * @returns A promise\n   */\n  async signoutSilent(args = {}) {\n    var _a;\n    const logger2 = this._logger.create(\"signoutSilent\");\n    const {\n      silentRequestTimeoutInSeconds,\n      ...requestArgs\n    } = args;\n    const id_token_hint = this.settings.includeIdTokenInSilentSignout ? (_a = await this._loadUser()) == null ? void 0 : _a.id_token : void 0;\n    const url = this.settings.popup_post_logout_redirect_uri;\n    const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n    await this._signout({\n      request_type: \"so:s\",\n      post_logout_redirect_uri: url,\n      id_token_hint,\n      ...requestArgs\n    }, handle);\n    logger2.info(\"success\");\n  }\n  /**\n   * Notify the parent window of response (callback) from the end session endpoint.\n   * It is recommended to use {@link UserManager.signoutCallback} instead.\n   *\n   * @returns A promise\n   *\n   * @see {@link UserManager.signoutCallback}\n   */\n  async signoutSilentCallback(url = window.location.href) {\n    const logger2 = this._logger.create(\"signoutSilentCallback\");\n    await this._iframeNavigator.callback(url);\n    logger2.info(\"success\");\n  }\n  async revokeTokens(types) {\n    const user = await this._loadUser();\n    await this._revokeInternal(user, types);\n  }\n  async _revokeInternal(user, types = this.settings.revokeTokenTypes) {\n    const logger2 = this._logger.create(\"_revokeInternal\");\n    if (!user) return;\n    const typesPresent = types.filter((type) => typeof user[type] === \"string\");\n    if (!typesPresent.length) {\n      logger2.debug(\"no need to revoke due to no token(s)\");\n      return;\n    }\n    for (const type of typesPresent) {\n      await this._client.revokeToken(\n        user[type],\n        type\n      );\n      logger2.info(`${type} revoked successfully`);\n      if (type !== \"access_token\") {\n        user[type] = null;\n      }\n    }\n    await this.storeUser(user);\n    logger2.debug(\"user stored\");\n    await this._events.load(user);\n  }\n  /**\n   * Enables silent renew for the `UserManager`.\n   */\n  startSilentRenew() {\n    this._logger.create(\"startSilentRenew\");\n    void this._silentRenewService.start();\n  }\n  /**\n   * Disables silent renew for the `UserManager`.\n   */\n  stopSilentRenew() {\n    this._silentRenewService.stop();\n  }\n  get _userStoreKey() {\n    return `user:${this.settings.authority}:${this.settings.client_id}`;\n  }\n  async _loadUser() {\n    const logger2 = this._logger.create(\"_loadUser\");\n    const storageString = await this.settings.userStore.get(this._userStoreKey);\n    if (storageString) {\n      logger2.debug(\"user storageString loaded\");\n      return User.fromStorageString(storageString);\n    }\n    logger2.debug(\"no user storageString\");\n    return null;\n  }\n  async storeUser(user) {\n    const logger2 = this._logger.create(\"storeUser\");\n    if (user) {\n      logger2.debug(\"storing user\");\n      const storageString = user.toStorageString();\n      await this.settings.userStore.set(this._userStoreKey, storageString);\n    } else {\n      this._logger.debug(\"removing user\");\n      await this.settings.userStore.remove(this._userStoreKey);\n      if (this.settings.dpop) {\n        await this.settings.dpop.store.remove(this.settings.client_id);\n      }\n    }\n  }\n  /**\n   * Removes stale state entries in storage for incomplete authorize requests.\n   */\n  async clearStaleState() {\n    await this._client.clearStaleState();\n  }\n  /**\n   * Dynamically generates a DPoP proof for a given user, URL and optional Http method.\n   * This method is useful when you need to make a request to a resource server\n   * with fetch or similar, and you need to include a DPoP proof in a DPoP header.\n   * @param url - The URL to generate the DPoP proof for\n   * @param user - The user to generate the DPoP proof for\n   * @param httpMethod - Optional, defaults to \"GET\"\n   * @param nonce - Optional nonce provided by the resource server\n   *\n   * @returns A promise containing the DPoP proof or undefined if DPoP is not enabled/no user is found.\n   */\n  async dpopProof(url, user, httpMethod, nonce) {\n    var _a, _b;\n    const dpopState = await ((_b = (_a = this.settings.dpop) == null ? void 0 : _a.store) == null ? void 0 : _b.get(this.settings.client_id));\n    if (dpopState) {\n      return await CryptoUtils.generateDPoPProof({\n        url,\n        accessToken: user == null ? void 0 : user.access_token,\n        httpMethod,\n        keyPair: dpopState.keys,\n        nonce\n      });\n    }\n    return void 0;\n  }\n  async generateDPoPJkt(dpopSettings) {\n    let dpopState = await dpopSettings.store.get(this.settings.client_id);\n    if (!dpopState) {\n      const dpopKeys = await CryptoUtils.generateDPoPKeys();\n      dpopState = new DPoPState(dpopKeys);\n      await dpopSettings.store.set(this.settings.client_id, dpopState);\n    }\n    return await CryptoUtils.generateDPoPJkt(dpopState.keys);\n  }\n};\n\n// package.json\nvar version = \"3.3.0\";\n\n// src/Version.ts\nvar Version = version;\n\n// src/IndexedDbDPoPStore.ts\nvar IndexedDbDPoPStore = class {\n  constructor() {\n    this._dbName = \"oidc\";\n    this._storeName = \"dpop\";\n  }\n  async set(key, value) {\n    const store = await this.createStore(this._dbName, this._storeName);\n    await store(\"readwrite\", (str) => {\n      str.put(value, key);\n      return this.promisifyRequest(str.transaction);\n    });\n  }\n  async get(key) {\n    const store = await this.createStore(this._dbName, this._storeName);\n    return await store(\"readonly\", (str) => {\n      return this.promisifyRequest(str.get(key));\n    });\n  }\n  async remove(key) {\n    const item = await this.get(key);\n    const store = await this.createStore(this._dbName, this._storeName);\n    await store(\"readwrite\", (str) => {\n      return this.promisifyRequest(str.delete(key));\n    });\n    return item;\n  }\n  async getAllKeys() {\n    const store = await this.createStore(this._dbName, this._storeName);\n    return await store(\"readonly\", (str) => {\n      return this.promisifyRequest(str.getAllKeys());\n    });\n  }\n  promisifyRequest(request) {\n    return new Promise((resolve, reject) => {\n      request.oncomplete = request.onsuccess = () => resolve(request.result);\n      request.onabort = request.onerror = () => reject(request.error);\n    });\n  }\n  async createStore(dbName, storeName) {\n    const request = indexedDB.open(dbName);\n    request.onupgradeneeded = () => request.result.createObjectStore(storeName);\n    const db = await this.promisifyRequest(request);\n    return async (txMode, callback) => {\n      const tx = db.transaction(storeName, txMode);\n      const store = tx.objectStore(storeName);\n      return await callback(store);\n    };\n  }\n};\n\n//# sourceMappingURL=oidc-client-ts.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL29pZGMtY2xpZW50LXRzL2Rpc3QvZXNtL29pZGMtY2xpZW50LXRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFdBQVc7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQkFBa0I7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsS0FBSyxHQUFHLGFBQWE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsS0FBSztBQUM1Qix1QkFBdUIsUUFBUSxFQUFFLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUN1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscURBQVM7QUFDdEIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWMsR0FBRyxlQUFlO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWEsR0FBRyxpQkFBaUI7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDREQUE0RCxZQUFZO0FBQ3hFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esc0VBQXNFLFlBQVk7QUFDbEYsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRyxJQUFJLEdBQUcsMERBQTBEO0FBQ25LO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsSUFBSTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLFlBQVksaUNBQWlDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx1REFBdUQ7QUFDM0csTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxnREFBZ0QsY0FBYyxJQUFJO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSx5QkFBeUIscUJBQXFCLEdBQUcsZ0JBQWdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQkFBcUIsR0FBRyxnQkFBZ0IsS0FBSyxxQkFBcUI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELCtFQUErRTtBQUNuSSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGdEQUFnRCxjQUFjLElBQUk7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSwyQkFBMkIscUJBQXFCLEdBQUcsZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxxQkFBcUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUJBQXFCLEdBQUcsZ0JBQWdCLEtBQUsscUJBQXFCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxzR0FBc0c7QUFDaEw7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLEtBQUs7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsMERBQTBEO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxJQUFJO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDBCQUEwQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDRJQUE0STtBQUN6TTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGtIQUFrSDtBQUMvSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsZ0VBQWdFO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHdFQUF3RTtBQUNwSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXLEVBQUUsb0JBQW9CLEVBQUUsVUFBVTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx1REFBdUQ7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2QztBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0EsY0FBYyxvQkFBb0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywyQ0FBMkM7QUFDNUU7QUFDQTtBQUNBLDBCQUEwQixXQUFXLEVBQUUsb0JBQW9CLEVBQUUsVUFBVTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxxQkFBcUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUIsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx3RUFBd0UseUNBQXlDO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0EsTUFBTTtBQUNOLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SEFBdUg7QUFDdkg7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGFBQWE7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxNQUFNO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsOEJBQThCLCtCQUErQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw4Q0FBOEMsdURBQXVEO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsNkJBQTZCLHFEQUFxRDtBQUNsRjtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBGQUEwRjtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsZ0JBQWdCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQ0FBa0M7QUFDakU7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxxREFBcUQ7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQ0FBa0M7QUFDakU7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCwrQkFBK0I7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw0QkFBNEIsNEJBQTRCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtDQUFrQztBQUNqRTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLFFBQVE7QUFDUixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixRQUFRO0FBQ1IsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsK0JBQStCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDRDQUE0QztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwyREFBMkQsZ0JBQWdCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1DQUFtQztBQUNsRTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHdEQUF3RCxxREFBcUQ7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQ0FBbUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHlEQUF5RCwrQkFBK0I7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQ0FBbUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsTUFBTTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3QkFBd0IsR0FBRyx3QkFBd0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF3QkU7QUFDRiIsInNvdXJjZXMiOlsiRDpcXFRXRSBHS0VcXHRvdXJ3aXRoZWFzZS1na2UtaGFja2F0aG9uXFxub2RlX21vZHVsZXNcXG9pZGMtY2xpZW50LXRzXFxkaXN0XFxlc21cXG9pZGMtY2xpZW50LXRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy91dGlscy9Mb2dnZXIudHNcbnZhciBub3BMb2dnZXIgPSB7XG4gIGRlYnVnOiAoKSA9PiB2b2lkIDAsXG4gIGluZm86ICgpID0+IHZvaWQgMCxcbiAgd2FybjogKCkgPT4gdm9pZCAwLFxuICBlcnJvcjogKCkgPT4gdm9pZCAwXG59O1xudmFyIGxldmVsO1xudmFyIGxvZ2dlcjtcbnZhciBMb2cgPSAvKiBAX19QVVJFX18gKi8gKChMb2cyKSA9PiB7XG4gIExvZzJbTG9nMltcIk5PTkVcIl0gPSAwXSA9IFwiTk9ORVwiO1xuICBMb2cyW0xvZzJbXCJFUlJPUlwiXSA9IDFdID0gXCJFUlJPUlwiO1xuICBMb2cyW0xvZzJbXCJXQVJOXCJdID0gMl0gPSBcIldBUk5cIjtcbiAgTG9nMltMb2cyW1wiSU5GT1wiXSA9IDNdID0gXCJJTkZPXCI7XG4gIExvZzJbTG9nMltcIkRFQlVHXCJdID0gNF0gPSBcIkRFQlVHXCI7XG4gIHJldHVybiBMb2cyO1xufSkoTG9nIHx8IHt9KTtcbigoTG9nMikgPT4ge1xuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBsZXZlbCA9IDMgLyogSU5GTyAqLztcbiAgICBsb2dnZXIgPSBub3BMb2dnZXI7XG4gIH1cbiAgTG9nMi5yZXNldCA9IHJlc2V0O1xuICBmdW5jdGlvbiBzZXRMZXZlbCh2YWx1ZSkge1xuICAgIGlmICghKDAgLyogTk9ORSAqLyA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSA0IC8qIERFQlVHICovKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBsb2cgbGV2ZWxcIik7XG4gICAgfVxuICAgIGxldmVsID0gdmFsdWU7XG4gIH1cbiAgTG9nMi5zZXRMZXZlbCA9IHNldExldmVsO1xuICBmdW5jdGlvbiBzZXRMb2dnZXIodmFsdWUpIHtcbiAgICBsb2dnZXIgPSB2YWx1ZTtcbiAgfVxuICBMb2cyLnNldExvZ2dlciA9IHNldExvZ2dlcjtcbn0pKExvZyB8fCAoTG9nID0ge30pKTtcbnZhciBMb2dnZXIgPSBjbGFzcyBfTG9nZ2VyIHtcbiAgY29uc3RydWN0b3IoX25hbWUpIHtcbiAgICB0aGlzLl9uYW1lID0gX25hbWU7XG4gIH1cbiAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1lbnVtLWNvbXBhcmlzb24gKi9cbiAgZGVidWcoLi4uYXJncykge1xuICAgIGlmIChsZXZlbCA+PSA0IC8qIERFQlVHICovKSB7XG4gICAgICBsb2dnZXIuZGVidWcoX0xvZ2dlci5fZm9ybWF0KHRoaXMuX25hbWUsIHRoaXMuX21ldGhvZCksIC4uLmFyZ3MpO1xuICAgIH1cbiAgfVxuICBpbmZvKC4uLmFyZ3MpIHtcbiAgICBpZiAobGV2ZWwgPj0gMyAvKiBJTkZPICovKSB7XG4gICAgICBsb2dnZXIuaW5mbyhfTG9nZ2VyLl9mb3JtYXQodGhpcy5fbmFtZSwgdGhpcy5fbWV0aG9kKSwgLi4uYXJncyk7XG4gICAgfVxuICB9XG4gIHdhcm4oLi4uYXJncykge1xuICAgIGlmIChsZXZlbCA+PSAyIC8qIFdBUk4gKi8pIHtcbiAgICAgIGxvZ2dlci53YXJuKF9Mb2dnZXIuX2Zvcm1hdCh0aGlzLl9uYW1lLCB0aGlzLl9tZXRob2QpLCAuLi5hcmdzKTtcbiAgICB9XG4gIH1cbiAgZXJyb3IoLi4uYXJncykge1xuICAgIGlmIChsZXZlbCA+PSAxIC8qIEVSUk9SICovKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoX0xvZ2dlci5fZm9ybWF0KHRoaXMuX25hbWUsIHRoaXMuX21ldGhvZCksIC4uLmFyZ3MpO1xuICAgIH1cbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZW51bS1jb21wYXJpc29uICovXG4gIHRocm93KGVycikge1xuICAgIHRoaXMuZXJyb3IoZXJyKTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgY3JlYXRlKG1ldGhvZCkge1xuICAgIGNvbnN0IG1ldGhvZExvZ2dlciA9IE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgbWV0aG9kTG9nZ2VyLl9tZXRob2QgPSBtZXRob2Q7XG4gICAgbWV0aG9kTG9nZ2VyLmRlYnVnKFwiYmVnaW5cIik7XG4gICAgcmV0dXJuIG1ldGhvZExvZ2dlcjtcbiAgfVxuICBzdGF0aWMgY3JlYXRlU3RhdGljKG5hbWUsIHN0YXRpY01ldGhvZCkge1xuICAgIGNvbnN0IHN0YXRpY0xvZ2dlciA9IG5ldyBfTG9nZ2VyKGAke25hbWV9LiR7c3RhdGljTWV0aG9kfWApO1xuICAgIHN0YXRpY0xvZ2dlci5kZWJ1ZyhcImJlZ2luXCIpO1xuICAgIHJldHVybiBzdGF0aWNMb2dnZXI7XG4gIH1cbiAgc3RhdGljIF9mb3JtYXQobmFtZSwgbWV0aG9kKSB7XG4gICAgY29uc3QgcHJlZml4ID0gYFske25hbWV9XWA7XG4gICAgcmV0dXJuIG1ldGhvZCA/IGAke3ByZWZpeH0gJHttZXRob2R9OmAgOiBwcmVmaXg7XG4gIH1cbiAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1lbnVtLWNvbXBhcmlzb24gKi9cbiAgLy8gaGVscGVycyBmb3Igc3RhdGljIGNsYXNzIG1ldGhvZHNcbiAgc3RhdGljIGRlYnVnKG5hbWUsIC4uLmFyZ3MpIHtcbiAgICBpZiAobGV2ZWwgPj0gNCAvKiBERUJVRyAqLykge1xuICAgICAgbG9nZ2VyLmRlYnVnKF9Mb2dnZXIuX2Zvcm1hdChuYW1lKSwgLi4uYXJncyk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBpbmZvKG5hbWUsIC4uLmFyZ3MpIHtcbiAgICBpZiAobGV2ZWwgPj0gMyAvKiBJTkZPICovKSB7XG4gICAgICBsb2dnZXIuaW5mbyhfTG9nZ2VyLl9mb3JtYXQobmFtZSksIC4uLmFyZ3MpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgd2FybihuYW1lLCAuLi5hcmdzKSB7XG4gICAgaWYgKGxldmVsID49IDIgLyogV0FSTiAqLykge1xuICAgICAgbG9nZ2VyLndhcm4oX0xvZ2dlci5fZm9ybWF0KG5hbWUpLCAuLi5hcmdzKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGVycm9yKG5hbWUsIC4uLmFyZ3MpIHtcbiAgICBpZiAobGV2ZWwgPj0gMSAvKiBFUlJPUiAqLykge1xuICAgICAgbG9nZ2VyLmVycm9yKF9Mb2dnZXIuX2Zvcm1hdChuYW1lKSwgLi4uYXJncyk7XG4gICAgfVxuICB9XG4gIC8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1lbnVtLWNvbXBhcmlzb24gKi9cbn07XG5Mb2cucmVzZXQoKTtcblxuLy8gc3JjL3V0aWxzL0p3dFV0aWxzLnRzXG5pbXBvcnQgeyBqd3REZWNvZGUgfSBmcm9tIFwiand0LWRlY29kZVwiO1xudmFyIEp3dFV0aWxzID0gY2xhc3Mge1xuICAvLyBJTVBPUlRBTlQ6IGRvZXNuJ3QgdmFsaWRhdGUgdGhlIHRva2VuXG4gIHN0YXRpYyBkZWNvZGUodG9rZW4pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGp3dERlY29kZSh0b2tlbik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBMb2dnZXIuZXJyb3IoXCJKd3RVdGlscy5kZWNvZGVcIiwgZXJyKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGFzeW5jIGdlbmVyYXRlU2lnbmVkSnd0KGhlYWRlciwgcGF5bG9hZCwgcHJpdmF0ZUtleSkge1xuICAgIGNvbnN0IGVuY29kZWRIZWFkZXIgPSBDcnlwdG9VdGlscy5lbmNvZGVCYXNlNjRVcmwobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKEpTT04uc3RyaW5naWZ5KGhlYWRlcikpKTtcbiAgICBjb25zdCBlbmNvZGVkUGF5bG9hZCA9IENyeXB0b1V0aWxzLmVuY29kZUJhc2U2NFVybChuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpKTtcbiAgICBjb25zdCBlbmNvZGVkVG9rZW4gPSBgJHtlbmNvZGVkSGVhZGVyfS4ke2VuY29kZWRQYXlsb2FkfWA7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgd2luZG93LmNyeXB0by5zdWJ0bGUuc2lnbihcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJFQ0RTQVwiLFxuICAgICAgICBoYXNoOiB7IG5hbWU6IFwiU0hBLTI1NlwiIH1cbiAgICAgIH0sXG4gICAgICBwcml2YXRlS2V5LFxuICAgICAgbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGVuY29kZWRUb2tlbilcbiAgICApO1xuICAgIGNvbnN0IGVuY29kZWRTaWduYXR1cmUgPSBDcnlwdG9VdGlscy5lbmNvZGVCYXNlNjRVcmwobmV3IFVpbnQ4QXJyYXkoc2lnbmF0dXJlKSk7XG4gICAgcmV0dXJuIGAke2VuY29kZWRUb2tlbn0uJHtlbmNvZGVkU2lnbmF0dXJlfWA7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9DcnlwdG9VdGlscy50c1xudmFyIFVVSURfVjRfVEVNUExBVEUgPSBcIjEwMDAwMDAwLTEwMDAtNDAwMC04MDAwLTEwMDAwMDAwMDAwMFwiO1xudmFyIHRvQmFzZTY0ID0gKHZhbCkgPT4gYnRvYShbLi4ubmV3IFVpbnQ4QXJyYXkodmFsKV0ubWFwKChjaHIpID0+IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKSkuam9pbihcIlwiKSk7XG52YXIgX0NyeXB0b1V0aWxzID0gY2xhc3MgX0NyeXB0b1V0aWxzIHtcbiAgc3RhdGljIF9yYW5kb21Xb3JkKCkge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50MzJBcnJheSgxKTtcbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycik7XG4gICAgcmV0dXJuIGFyclswXTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIFJGQzQxMjIgdmVyc2lvbiA0IGd1aWRcbiAgICovXG4gIHN0YXRpYyBnZW5lcmF0ZVVVSUR2NCgpIHtcbiAgICBjb25zdCB1dWlkID0gVVVJRF9WNF9URU1QTEFURS5yZXBsYWNlKFxuICAgICAgL1swMThdL2csXG4gICAgICAoYykgPT4gKCtjIF4gX0NyeXB0b1V0aWxzLl9yYW5kb21Xb3JkKCkgJiAxNSA+PiArYyAvIDQpLnRvU3RyaW5nKDE2KVxuICAgICk7XG4gICAgcmV0dXJuIHV1aWQucmVwbGFjZSgvLS9nLCBcIlwiKTtcbiAgfVxuICAvKipcbiAgICogUEtDRTogR2VuZXJhdGUgYSBjb2RlIHZlcmlmaWVyXG4gICAqL1xuICBzdGF0aWMgZ2VuZXJhdGVDb2RlVmVyaWZpZXIoKSB7XG4gICAgcmV0dXJuIF9DcnlwdG9VdGlscy5nZW5lcmF0ZVVVSUR2NCgpICsgX0NyeXB0b1V0aWxzLmdlbmVyYXRlVVVJRHY0KCkgKyBfQ3J5cHRvVXRpbHMuZ2VuZXJhdGVVVUlEdjQoKTtcbiAgfVxuICAvKipcbiAgICogUEtDRTogR2VuZXJhdGUgYSBjb2RlIGNoYWxsZW5nZVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGdlbmVyYXRlQ29kZUNoYWxsZW5nZShjb2RlX3ZlcmlmaWVyKSB7XG4gICAgaWYgKCFjcnlwdG8uc3VidGxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDcnlwdG8uc3VidGxlIGlzIGF2YWlsYWJsZSBvbmx5IGluIHNlY3VyZSBjb250ZXh0cyAoSFRUUFMpLlwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVyLmVuY29kZShjb2RlX3ZlcmlmaWVyKTtcbiAgICAgIGNvbnN0IGhhc2hlZCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KFwiU0hBLTI1NlwiLCBkYXRhKTtcbiAgICAgIHJldHVybiB0b0Jhc2U2NChoYXNoZWQpLnJlcGxhY2UoL1xcKy9nLCBcIi1cIikucmVwbGFjZSgvXFwvL2csIFwiX1wiKS5yZXBsYWNlKC89KyQvLCBcIlwiKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIExvZ2dlci5lcnJvcihcIkNyeXB0b1V0aWxzLmdlbmVyYXRlQ29kZUNoYWxsZW5nZVwiLCBlcnIpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nIGZvciBhIGJhc2ljIGF1dGggaGVhZGVyXG4gICAqL1xuICBzdGF0aWMgZ2VuZXJhdGVCYXNpY0F1dGgoY2xpZW50X2lkLCBjbGllbnRfc2VjcmV0KSB7XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVyLmVuY29kZShbY2xpZW50X2lkLCBjbGllbnRfc2VjcmV0XS5qb2luKFwiOlwiKSk7XG4gICAgcmV0dXJuIHRvQmFzZTY0KGRhdGEpO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBoYXNoIG9mIGEgc3RyaW5nIHVzaW5nIGEgZ2l2ZW4gYWxnb3JpdGhtXG4gICAqIEBwYXJhbSBhbGdcbiAgICogQHBhcmFtIG1lc3NhZ2VcbiAgICovXG4gIHN0YXRpYyBhc3luYyBoYXNoKGFsZywgbWVzc2FnZSkge1xuICAgIGNvbnN0IG1zZ1VpbnQ4ID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKG1lc3NhZ2UpO1xuICAgIGNvbnN0IGhhc2hCdWZmZXIgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdChhbGcsIG1zZ1VpbnQ4KTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaGFzaEJ1ZmZlcik7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIHJmYzc2MzggY29tcGxpYW50IGp3ayB0aHVtYnByaW50XG4gICAqIEBwYXJhbSBqd2tcbiAgICovXG4gIHN0YXRpYyBhc3luYyBjdXN0b21DYWxjdWxhdGVKd2tUaHVtYnByaW50KGp3aykge1xuICAgIGxldCBqc29uT2JqZWN0O1xuICAgIHN3aXRjaCAoandrLmt0eSkge1xuICAgICAgY2FzZSBcIlJTQVwiOlxuICAgICAgICBqc29uT2JqZWN0ID0ge1xuICAgICAgICAgIFwiZVwiOiBqd2suZSxcbiAgICAgICAgICBcImt0eVwiOiBqd2sua3R5LFxuICAgICAgICAgIFwiblwiOiBqd2sublxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJFQ1wiOlxuICAgICAgICBqc29uT2JqZWN0ID0ge1xuICAgICAgICAgIFwiY3J2XCI6IGp3ay5jcnYsXG4gICAgICAgICAgXCJrdHlcIjogandrLmt0eSxcbiAgICAgICAgICBcInhcIjogandrLngsXG4gICAgICAgICAgXCJ5XCI6IGp3ay55XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIk9LUFwiOlxuICAgICAgICBqc29uT2JqZWN0ID0ge1xuICAgICAgICAgIFwiY3J2XCI6IGp3ay5jcnYsXG4gICAgICAgICAgXCJrdHlcIjogandrLmt0eSxcbiAgICAgICAgICBcInhcIjogandrLnhcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwib2N0XCI6XG4gICAgICAgIGpzb25PYmplY3QgPSB7XG4gICAgICAgICAgXCJjcnZcIjogandrLmssXG4gICAgICAgICAgXCJrdHlcIjogandrLmt0eVxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gandrIHR5cGVcIik7XG4gICAgfVxuICAgIGNvbnN0IHV0ZjhlbmNvZGVkQW5kSGFzaGVkID0gYXdhaXQgX0NyeXB0b1V0aWxzLmhhc2goXCJTSEEtMjU2XCIsIEpTT04uc3RyaW5naWZ5KGpzb25PYmplY3QpKTtcbiAgICByZXR1cm4gX0NyeXB0b1V0aWxzLmVuY29kZUJhc2U2NFVybCh1dGY4ZW5jb2RlZEFuZEhhc2hlZCk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGdlbmVyYXRlRFBvUFByb29mKHtcbiAgICB1cmwsXG4gICAgYWNjZXNzVG9rZW4sXG4gICAgaHR0cE1ldGhvZCxcbiAgICBrZXlQYWlyLFxuICAgIG5vbmNlXG4gIH0pIHtcbiAgICBsZXQgaGFzaGVkVG9rZW47XG4gICAgbGV0IGVuY29kZWRIYXNoO1xuICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICBcImp0aVwiOiB3aW5kb3cuY3J5cHRvLnJhbmRvbVVVSUQoKSxcbiAgICAgIFwiaHRtXCI6IGh0dHBNZXRob2QgIT0gbnVsbCA/IGh0dHBNZXRob2QgOiBcIkdFVFwiLFxuICAgICAgXCJodHVcIjogdXJsLFxuICAgICAgXCJpYXRcIjogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKVxuICAgIH07XG4gICAgaWYgKGFjY2Vzc1Rva2VuKSB7XG4gICAgICBoYXNoZWRUb2tlbiA9IGF3YWl0IF9DcnlwdG9VdGlscy5oYXNoKFwiU0hBLTI1NlwiLCBhY2Nlc3NUb2tlbik7XG4gICAgICBlbmNvZGVkSGFzaCA9IF9DcnlwdG9VdGlscy5lbmNvZGVCYXNlNjRVcmwoaGFzaGVkVG9rZW4pO1xuICAgICAgcGF5bG9hZC5hdGggPSBlbmNvZGVkSGFzaDtcbiAgICB9XG4gICAgaWYgKG5vbmNlKSB7XG4gICAgICBwYXlsb2FkLm5vbmNlID0gbm9uY2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwdWJsaWNKd2sgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmV4cG9ydEtleShcImp3a1wiLCBrZXlQYWlyLnB1YmxpY0tleSk7XG4gICAgICBjb25zdCBoZWFkZXIgPSB7XG4gICAgICAgIFwiYWxnXCI6IFwiRVMyNTZcIixcbiAgICAgICAgXCJ0eXBcIjogXCJkcG9wK2p3dFwiLFxuICAgICAgICBcImp3a1wiOiB7XG4gICAgICAgICAgXCJjcnZcIjogcHVibGljSndrLmNydixcbiAgICAgICAgICBcImt0eVwiOiBwdWJsaWNKd2sua3R5LFxuICAgICAgICAgIFwieFwiOiBwdWJsaWNKd2sueCxcbiAgICAgICAgICBcInlcIjogcHVibGljSndrLnlcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBhd2FpdCBKd3RVdGlscy5nZW5lcmF0ZVNpZ25lZEp3dChoZWFkZXIsIHBheWxvYWQsIGtleVBhaXIucHJpdmF0ZUtleSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZXhwb3J0aW5nIGRwb3AgcHVibGljIGtleTogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RhdGljIGFzeW5jIGdlbmVyYXRlRFBvUEprdChrZXlQYWlyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHB1YmxpY0p3ayA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KFwiandrXCIsIGtleVBhaXIucHVibGljS2V5KTtcbiAgICAgIHJldHVybiBhd2FpdCBfQ3J5cHRvVXRpbHMuY3VzdG9tQ2FsY3VsYXRlSndrVGh1bWJwcmludChwdWJsaWNKd2spO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCByZXRyaWV2ZSBkcG9wIGtleXMgZnJvbSBzdG9yYWdlOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdGF0aWMgYXN5bmMgZ2VuZXJhdGVEUG9QS2V5cygpIHtcbiAgICByZXR1cm4gYXdhaXQgd2luZG93LmNyeXB0by5zdWJ0bGUuZ2VuZXJhdGVLZXkoXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiRUNEU0FcIixcbiAgICAgICAgbmFtZWRDdXJ2ZTogXCJQLTI1NlwiXG4gICAgICB9LFxuICAgICAgZmFsc2UsXG4gICAgICBbXCJzaWduXCIsIFwidmVyaWZ5XCJdXG4gICAgKTtcbiAgfVxufTtcbi8qKlxuICogR2VuZXJhdGVzIGEgYmFzZTY0dXJsIGVuY29kZWQgc3RyaW5nXG4gKi9cbl9DcnlwdG9VdGlscy5lbmNvZGVCYXNlNjRVcmwgPSAoaW5wdXQpID0+IHtcbiAgcmV0dXJuIHRvQmFzZTY0KGlucHV0KS5yZXBsYWNlKC89L2csIFwiXCIpLnJlcGxhY2UoL1xcKy9nLCBcIi1cIikucmVwbGFjZSgvXFwvL2csIFwiX1wiKTtcbn07XG52YXIgQ3J5cHRvVXRpbHMgPSBfQ3J5cHRvVXRpbHM7XG5cbi8vIHNyYy91dGlscy9FdmVudC50c1xudmFyIEV2ZW50ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihfbmFtZSkge1xuICAgIHRoaXMuX25hbWUgPSBfbmFtZTtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSBbXTtcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKGBFdmVudCgnJHt0aGlzLl9uYW1lfScpYCk7XG4gIH1cbiAgYWRkSGFuZGxlcihjYikge1xuICAgIHRoaXMuX2NhbGxiYWNrcy5wdXNoKGNiKTtcbiAgICByZXR1cm4gKCkgPT4gdGhpcy5yZW1vdmVIYW5kbGVyKGNiKTtcbiAgfVxuICByZW1vdmVIYW5kbGVyKGNiKSB7XG4gICAgY29uc3QgaWR4ID0gdGhpcy5fY2FsbGJhY2tzLmxhc3RJbmRleE9mKGNiKTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIHRoaXMuX2NhbGxiYWNrcy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcmFpc2UoLi4uZXYpIHtcbiAgICB0aGlzLl9sb2dnZXIuZGVidWcoXCJyYWlzZTpcIiwgLi4uZXYpO1xuICAgIGZvciAoY29uc3QgY2Igb2YgdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICBhd2FpdCBjYiguLi5ldik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvUG9wdXBVdGlscy50c1xudmFyIFBvcHVwVXRpbHMgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBQb3B1bGF0ZXMgYSBtYXAgb2Ygd2luZG93IGZlYXR1cmVzIHdpdGggYSBwbGFjZW1lbnQgY2VudGVyZWQgaW4gZnJvbnQgb2ZcbiAgICogdGhlIGN1cnJlbnQgd2luZG93LiBJZiBubyBleHBsaWNpdCB3aWR0aCBpcyBnaXZlbiwgYSBkZWZhdWx0IHZhbHVlIGlzXG4gICAqIGJpbm5lZCBpbnRvIFs4MDAsIDcyMCwgNjAwLCA0ODAsIDM2MF0gYmFzZWQgb24gdGhlIGN1cnJlbnQgd2luZG93J3Mgd2lkdGguXG4gICAqL1xuICBzdGF0aWMgY2VudGVyKHsgLi4uZmVhdHVyZXMgfSkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGlmIChmZWF0dXJlcy53aWR0aCA9PSBudWxsKVxuICAgICAgZmVhdHVyZXMud2lkdGggPSAoX2EgPSBbODAwLCA3MjAsIDYwMCwgNDgwXS5maW5kKCh3aWR0aCkgPT4gd2lkdGggPD0gd2luZG93Lm91dGVyV2lkdGggLyAxLjYxOCkpICE9IG51bGwgPyBfYSA6IDM2MDtcbiAgICAoX2IgPSBmZWF0dXJlcy5sZWZ0KSAhPSBudWxsID8gX2IgOiBmZWF0dXJlcy5sZWZ0ID0gTWF0aC5tYXgoMCwgTWF0aC5yb3VuZCh3aW5kb3cuc2NyZWVuWCArICh3aW5kb3cub3V0ZXJXaWR0aCAtIGZlYXR1cmVzLndpZHRoKSAvIDIpKTtcbiAgICBpZiAoZmVhdHVyZXMuaGVpZ2h0ICE9IG51bGwpXG4gICAgICAoX2MgPSBmZWF0dXJlcy50b3ApICE9IG51bGwgPyBfYyA6IGZlYXR1cmVzLnRvcCA9IE1hdGgubWF4KDAsIE1hdGgucm91bmQod2luZG93LnNjcmVlblkgKyAod2luZG93Lm91dGVySGVpZ2h0IC0gZmVhdHVyZXMuaGVpZ2h0KSAvIDIpKTtcbiAgICByZXR1cm4gZmVhdHVyZXM7XG4gIH1cbiAgc3RhdGljIHNlcmlhbGl6ZShmZWF0dXJlcykge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhmZWF0dXJlcykuZmlsdGVyKChbLCB2YWx1ZV0pID0+IHZhbHVlICE9IG51bGwpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBgJHtrZXl9PSR7dHlwZW9mIHZhbHVlICE9PSBcImJvb2xlYW5cIiA/IHZhbHVlIDogdmFsdWUgPyBcInllc1wiIDogXCJub1wifWApLmpvaW4oXCIsXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvVGltZXIudHNcbnZhciBUaW1lciA9IGNsYXNzIF9UaW1lciBleHRlbmRzIEV2ZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKGBUaW1lcignJHt0aGlzLl9uYW1lfScpYCk7XG4gICAgdGhpcy5fdGltZXJIYW5kbGUgPSBudWxsO1xuICAgIHRoaXMuX2V4cGlyYXRpb24gPSAwO1xuICAgIHRoaXMuX2NhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgY29uc3QgZGlmZiA9IHRoaXMuX2V4cGlyYXRpb24gLSBfVGltZXIuZ2V0RXBvY2hUaW1lKCk7XG4gICAgICB0aGlzLl9sb2dnZXIuZGVidWcoXCJ0aW1lciBjb21wbGV0ZXMgaW5cIiwgZGlmZik7XG4gICAgICBpZiAodGhpcy5fZXhwaXJhdGlvbiA8PSBfVGltZXIuZ2V0RXBvY2hUaW1lKCkpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgdm9pZCBzdXBlci5yYWlzZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLy8gZ2V0IHRoZSB0aW1lXG4gIHN0YXRpYyBnZXRFcG9jaFRpbWUoKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMyk7XG4gIH1cbiAgaW5pdChkdXJhdGlvbkluU2Vjb25kcykge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiaW5pdFwiKTtcbiAgICBkdXJhdGlvbkluU2Vjb25kcyA9IE1hdGgubWF4KE1hdGguZmxvb3IoZHVyYXRpb25JblNlY29uZHMpLCAxKTtcbiAgICBjb25zdCBleHBpcmF0aW9uID0gX1RpbWVyLmdldEVwb2NoVGltZSgpICsgZHVyYXRpb25JblNlY29uZHM7XG4gICAgaWYgKHRoaXMuZXhwaXJhdGlvbiA9PT0gZXhwaXJhdGlvbiAmJiB0aGlzLl90aW1lckhhbmRsZSkge1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcInNraXBwaW5nIHNpbmNlIGFscmVhZHkgaW5pdGlhbGl6ZWQgZm9yIGV4cGlyYXRpb24gYXRcIiwgdGhpcy5leHBpcmF0aW9uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jYW5jZWwoKTtcbiAgICBsb2dnZXIyLmRlYnVnKFwidXNpbmcgZHVyYXRpb25cIiwgZHVyYXRpb25JblNlY29uZHMpO1xuICAgIHRoaXMuX2V4cGlyYXRpb24gPSBleHBpcmF0aW9uO1xuICAgIGNvbnN0IHRpbWVyRHVyYXRpb25JblNlY29uZHMgPSBNYXRoLm1pbihkdXJhdGlvbkluU2Vjb25kcywgNSk7XG4gICAgdGhpcy5fdGltZXJIYW5kbGUgPSBzZXRJbnRlcnZhbCh0aGlzLl9jYWxsYmFjaywgdGltZXJEdXJhdGlvbkluU2Vjb25kcyAqIDFlMyk7XG4gIH1cbiAgZ2V0IGV4cGlyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V4cGlyYXRpb247XG4gIH1cbiAgY2FuY2VsKCkge1xuICAgIHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJjYW5jZWxcIik7XG4gICAgaWYgKHRoaXMuX3RpbWVySGFuZGxlKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX3RpbWVySGFuZGxlKTtcbiAgICAgIHRoaXMuX3RpbWVySGFuZGxlID0gbnVsbDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9VcmxVdGlscy50c1xudmFyIFVybFV0aWxzID0gY2xhc3Mge1xuICBzdGF0aWMgcmVhZFBhcmFtcyh1cmwsIHJlc3BvbnNlTW9kZSA9IFwicXVlcnlcIikge1xuICAgIGlmICghdXJsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBVUkxcIik7XG4gICAgY29uc3QgcGFyc2VkVXJsID0gbmV3IFVSTCh1cmwsIFwiaHR0cDovLzEyNy4wLjAuMVwiKTtcbiAgICBjb25zdCBwYXJhbXMgPSBwYXJzZWRVcmxbcmVzcG9uc2VNb2RlID09PSBcImZyYWdtZW50XCIgPyBcImhhc2hcIiA6IFwic2VhcmNoXCJdO1xuICAgIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtcy5zbGljZSgxKSk7XG4gIH1cbn07XG52YXIgVVJMX1NUQVRFX0RFTElNSVRFUiA9IFwiO1wiO1xuXG4vLyBzcmMvZXJyb3JzL0Vycm9yUmVzcG9uc2UudHNcbnZhciBFcnJvclJlc3BvbnNlID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MsIGZvcm0pIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBzdXBlcihhcmdzLmVycm9yX2Rlc2NyaXB0aW9uIHx8IGFyZ3MuZXJyb3IgfHwgXCJcIik7XG4gICAgdGhpcy5mb3JtID0gZm9ybTtcbiAgICAvKiogTWFya2VyIHRvIGRldGVjdCBjbGFzczogXCJFcnJvclJlc3BvbnNlXCIgKi9cbiAgICB0aGlzLm5hbWUgPSBcIkVycm9yUmVzcG9uc2VcIjtcbiAgICBpZiAoIWFyZ3MuZXJyb3IpIHtcbiAgICAgIExvZ2dlci5lcnJvcihcIkVycm9yUmVzcG9uc2VcIiwgXCJObyBlcnJvciBwYXNzZWRcIik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBlcnJvciBwYXNzZWRcIik7XG4gICAgfVxuICAgIHRoaXMuZXJyb3IgPSBhcmdzLmVycm9yO1xuICAgIHRoaXMuZXJyb3JfZGVzY3JpcHRpb24gPSAoX2EgPSBhcmdzLmVycm9yX2Rlc2NyaXB0aW9uKSAhPSBudWxsID8gX2EgOiBudWxsO1xuICAgIHRoaXMuZXJyb3JfdXJpID0gKF9iID0gYXJncy5lcnJvcl91cmkpICE9IG51bGwgPyBfYiA6IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IGFyZ3MudXNlclN0YXRlO1xuICAgIHRoaXMuc2Vzc2lvbl9zdGF0ZSA9IChfYyA9IGFyZ3Muc2Vzc2lvbl9zdGF0ZSkgIT0gbnVsbCA/IF9jIDogbnVsbDtcbiAgICB0aGlzLnVybF9zdGF0ZSA9IGFyZ3MudXJsX3N0YXRlO1xuICB9XG59O1xuXG4vLyBzcmMvZXJyb3JzL0Vycm9yVGltZW91dC50c1xudmFyIEVycm9yVGltZW91dCA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgLyoqIE1hcmtlciB0byBkZXRlY3QgY2xhc3M6IFwiRXJyb3JUaW1lb3V0XCIgKi9cbiAgICB0aGlzLm5hbWUgPSBcIkVycm9yVGltZW91dFwiO1xuICB9XG59O1xuXG4vLyBzcmMvQWNjZXNzVG9rZW5FdmVudHMudHNcbnZhciBBY2Nlc3NUb2tlbkV2ZW50cyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHRoaXMuX2xvZ2dlciA9IG5ldyBMb2dnZXIoXCJBY2Nlc3NUb2tlbkV2ZW50c1wiKTtcbiAgICB0aGlzLl9leHBpcmluZ1RpbWVyID0gbmV3IFRpbWVyKFwiQWNjZXNzIHRva2VuIGV4cGlyaW5nXCIpO1xuICAgIHRoaXMuX2V4cGlyZWRUaW1lciA9IG5ldyBUaW1lcihcIkFjY2VzcyB0b2tlbiBleHBpcmVkXCIpO1xuICAgIHRoaXMuX2V4cGlyaW5nTm90aWZpY2F0aW9uVGltZUluU2Vjb25kcyA9IGFyZ3MuZXhwaXJpbmdOb3RpZmljYXRpb25UaW1lSW5TZWNvbmRzO1xuICB9XG4gIGFzeW5jIGxvYWQoY29udGFpbmVyKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJsb2FkXCIpO1xuICAgIGlmIChjb250YWluZXIuYWNjZXNzX3Rva2VuICYmIGNvbnRhaW5lci5leHBpcmVzX2luICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gY29udGFpbmVyLmV4cGlyZXNfaW47XG4gICAgICBsb2dnZXIyLmRlYnVnKFwiYWNjZXNzIHRva2VuIHByZXNlbnQsIHJlbWFpbmluZyBkdXJhdGlvbjpcIiwgZHVyYXRpb24pO1xuICAgICAgaWYgKGR1cmF0aW9uID4gMCkge1xuICAgICAgICBsZXQgZXhwaXJpbmcgPSBkdXJhdGlvbiAtIHRoaXMuX2V4cGlyaW5nTm90aWZpY2F0aW9uVGltZUluU2Vjb25kcztcbiAgICAgICAgaWYgKGV4cGlyaW5nIDw9IDApIHtcbiAgICAgICAgICBleHBpcmluZyA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyMi5kZWJ1ZyhcInJlZ2lzdGVyaW5nIGV4cGlyaW5nIHRpbWVyLCByYWlzaW5nIGluXCIsIGV4cGlyaW5nLCBcInNlY29uZHNcIik7XG4gICAgICAgIHRoaXMuX2V4cGlyaW5nVGltZXIuaW5pdChleHBpcmluZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIyLmRlYnVnKFwiY2FuY2VsaW5nIGV4aXN0aW5nIGV4cGlyaW5nIHRpbWVyIGJlY2F1c2Ugd2UncmUgcGFzdCBleHBpcmF0aW9uLlwiKTtcbiAgICAgICAgdGhpcy5fZXhwaXJpbmdUaW1lci5jYW5jZWwoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGV4cGlyZWQgPSBkdXJhdGlvbiArIDE7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwicmVnaXN0ZXJpbmcgZXhwaXJlZCB0aW1lciwgcmFpc2luZyBpblwiLCBleHBpcmVkLCBcInNlY29uZHNcIik7XG4gICAgICB0aGlzLl9leHBpcmVkVGltZXIuaW5pdChleHBpcmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZXhwaXJpbmdUaW1lci5jYW5jZWwoKTtcbiAgICAgIHRoaXMuX2V4cGlyZWRUaW1lci5jYW5jZWwoKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgdW5sb2FkKCkge1xuICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhcInVubG9hZDogY2FuY2VsaW5nIGV4aXN0aW5nIGFjY2VzcyB0b2tlbiB0aW1lcnNcIik7XG4gICAgdGhpcy5fZXhwaXJpbmdUaW1lci5jYW5jZWwoKTtcbiAgICB0aGlzLl9leHBpcmVkVGltZXIuY2FuY2VsKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBjYWxsYmFjazogUmFpc2VkIHByaW9yIHRvIHRoZSBhY2Nlc3MgdG9rZW4gZXhwaXJpbmcuXG4gICAqL1xuICBhZGRBY2Nlc3NUb2tlbkV4cGlyaW5nKGNiKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V4cGlyaW5nVGltZXIuYWRkSGFuZGxlcihjYik7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBjYWxsYmFjazogUmFpc2VkIHByaW9yIHRvIHRoZSBhY2Nlc3MgdG9rZW4gZXhwaXJpbmcuXG4gICAqL1xuICByZW1vdmVBY2Nlc3NUb2tlbkV4cGlyaW5nKGNiKSB7XG4gICAgdGhpcy5fZXhwaXJpbmdUaW1lci5yZW1vdmVIYW5kbGVyKGNiKTtcbiAgfVxuICAvKipcbiAgICogQWRkIGNhbGxiYWNrOiBSYWlzZWQgYWZ0ZXIgdGhlIGFjY2VzcyB0b2tlbiBoYXMgZXhwaXJlZC5cbiAgICovXG4gIGFkZEFjY2Vzc1Rva2VuRXhwaXJlZChjYikge1xuICAgIHJldHVybiB0aGlzLl9leHBpcmVkVGltZXIuYWRkSGFuZGxlcihjYik7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBjYWxsYmFjazogUmFpc2VkIGFmdGVyIHRoZSBhY2Nlc3MgdG9rZW4gaGFzIGV4cGlyZWQuXG4gICAqL1xuICByZW1vdmVBY2Nlc3NUb2tlbkV4cGlyZWQoY2IpIHtcbiAgICB0aGlzLl9leHBpcmVkVGltZXIucmVtb3ZlSGFuZGxlcihjYik7XG4gIH1cbn07XG5cbi8vIHNyYy9DaGVja1Nlc3Npb25JRnJhbWUudHNcbnZhciBDaGVja1Nlc3Npb25JRnJhbWUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKF9jYWxsYmFjaywgX2NsaWVudF9pZCwgdXJsLCBfaW50ZXJ2YWxJblNlY29uZHMsIF9zdG9wT25FcnJvcikge1xuICAgIHRoaXMuX2NhbGxiYWNrID0gX2NhbGxiYWNrO1xuICAgIHRoaXMuX2NsaWVudF9pZCA9IF9jbGllbnRfaWQ7XG4gICAgdGhpcy5faW50ZXJ2YWxJblNlY29uZHMgPSBfaW50ZXJ2YWxJblNlY29uZHM7XG4gICAgdGhpcy5fc3RvcE9uRXJyb3IgPSBfc3RvcE9uRXJyb3I7XG4gICAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIkNoZWNrU2Vzc2lvbklGcmFtZVwiKTtcbiAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgdGhpcy5fc2Vzc2lvbl9zdGF0ZSA9IG51bGw7XG4gICAgdGhpcy5fbWVzc2FnZSA9IChlKSA9PiB7XG4gICAgICBpZiAoZS5vcmlnaW4gPT09IHRoaXMuX2ZyYW1lX29yaWdpbiAmJiBlLnNvdXJjZSA9PT0gdGhpcy5fZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICBpZiAoZS5kYXRhID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoXCJlcnJvciBtZXNzYWdlIGZyb20gY2hlY2sgc2Vzc2lvbiBvcCBpZnJhbWVcIik7XG4gICAgICAgICAgaWYgKHRoaXMuX3N0b3BPbkVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhID09PSBcImNoYW5nZWRcIikge1xuICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhcImNoYW5nZWQgbWVzc2FnZSBmcm9tIGNoZWNrIHNlc3Npb24gb3AgaWZyYW1lXCIpO1xuICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgIHZvaWQgdGhpcy5fY2FsbGJhY2soKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoZS5kYXRhICsgXCIgbWVzc2FnZSBmcm9tIGNoZWNrIHNlc3Npb24gb3AgaWZyYW1lXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwYXJzZWRVcmwgPSBuZXcgVVJMKHVybCk7XG4gICAgdGhpcy5fZnJhbWVfb3JpZ2luID0gcGFyc2VkVXJsLm9yaWdpbjtcbiAgICB0aGlzLl9mcmFtZSA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgIHRoaXMuX2ZyYW1lLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgIHRoaXMuX2ZyYW1lLnN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xuICAgIHRoaXMuX2ZyYW1lLnN0eWxlLmxlZnQgPSBcIi0xMDAwcHhcIjtcbiAgICB0aGlzLl9mcmFtZS5zdHlsZS50b3AgPSBcIjBcIjtcbiAgICB0aGlzLl9mcmFtZS53aWR0aCA9IFwiMFwiO1xuICAgIHRoaXMuX2ZyYW1lLmhlaWdodCA9IFwiMFwiO1xuICAgIHRoaXMuX2ZyYW1lLnNyYyA9IHBhcnNlZFVybC5ocmVmO1xuICB9XG4gIGxvYWQoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLl9mcmFtZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH07XG4gICAgICB3aW5kb3cuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLl9mcmFtZSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5fbWVzc2FnZSwgZmFsc2UpO1xuICAgIH0pO1xuICB9XG4gIHN0YXJ0KHNlc3Npb25fc3RhdGUpIHtcbiAgICBpZiAodGhpcy5fc2Vzc2lvbl9zdGF0ZSA9PT0gc2Vzc2lvbl9zdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9sb2dnZXIuY3JlYXRlKFwic3RhcnRcIik7XG4gICAgdGhpcy5zdG9wKCk7XG4gICAgdGhpcy5fc2Vzc2lvbl9zdGF0ZSA9IHNlc3Npb25fc3RhdGU7XG4gICAgY29uc3Qgc2VuZCA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fZnJhbWUuY29udGVudFdpbmRvdyB8fCAhdGhpcy5fc2Vzc2lvbl9zdGF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9mcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKHRoaXMuX2NsaWVudF9pZCArIFwiIFwiICsgdGhpcy5fc2Vzc2lvbl9zdGF0ZSwgdGhpcy5fZnJhbWVfb3JpZ2luKTtcbiAgICB9O1xuICAgIHNlbmQoKTtcbiAgICB0aGlzLl90aW1lciA9IHNldEludGVydmFsKHNlbmQsIHRoaXMuX2ludGVydmFsSW5TZWNvbmRzICogMWUzKTtcbiAgfVxuICBzdG9wKCkge1xuICAgIHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJzdG9wXCIpO1xuICAgIHRoaXMuX3Nlc3Npb25fc3RhdGUgPSBudWxsO1xuICAgIGlmICh0aGlzLl90aW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl90aW1lcik7XG4gICAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvSW5NZW1vcnlXZWJTdG9yYWdlLnRzXG52YXIgSW5NZW1vcnlXZWJTdG9yYWdlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiSW5NZW1vcnlXZWJTdG9yYWdlXCIpO1xuICAgIHRoaXMuX2RhdGEgPSB7fTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiY2xlYXJcIik7XG4gICAgdGhpcy5fZGF0YSA9IHt9O1xuICB9XG4gIGdldEl0ZW0oa2V5KSB7XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShgZ2V0SXRlbSgnJHtrZXl9JylgKTtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVtrZXldO1xuICB9XG4gIHNldEl0ZW0oa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX2xvZ2dlci5jcmVhdGUoYHNldEl0ZW0oJyR7a2V5fScpYCk7XG4gICAgdGhpcy5fZGF0YVtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmVtb3ZlSXRlbShrZXkpIHtcbiAgICB0aGlzLl9sb2dnZXIuY3JlYXRlKGByZW1vdmVJdGVtKCcke2tleX0nKWApO1xuICAgIGRlbGV0ZSB0aGlzLl9kYXRhW2tleV07XG4gIH1cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5fZGF0YSkubGVuZ3RoO1xuICB9XG4gIGtleShpbmRleCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLl9kYXRhKVtpbmRleF07XG4gIH1cbn07XG5cbi8vIHNyYy9lcnJvcnMvRXJyb3JEUG9QTm9uY2UudHNcbnZhciBFcnJvckRQb1BOb25jZSA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihub25jZSwgbWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIC8qKiBNYXJrZXIgdG8gZGV0ZWN0IGNsYXNzOiBcIkVycm9yRFBvUE5vbmNlXCIgKi9cbiAgICB0aGlzLm5hbWUgPSBcIkVycm9yRFBvUE5vbmNlXCI7XG4gICAgdGhpcy5ub25jZSA9IG5vbmNlO1xuICB9XG59O1xuXG4vLyBzcmMvSnNvblNlcnZpY2UudHNcbnZhciBKc29uU2VydmljZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoYWRkaXRpb25hbENvbnRlbnRUeXBlcyA9IFtdLCBfand0SGFuZGxlciA9IG51bGwsIF9leHRyYUhlYWRlcnMgPSB7fSkge1xuICAgIHRoaXMuX2p3dEhhbmRsZXIgPSBfand0SGFuZGxlcjtcbiAgICB0aGlzLl9leHRyYUhlYWRlcnMgPSBfZXh0cmFIZWFkZXJzO1xuICAgIHRoaXMuX2xvZ2dlciA9IG5ldyBMb2dnZXIoXCJKc29uU2VydmljZVwiKTtcbiAgICB0aGlzLl9jb250ZW50VHlwZXMgPSBbXTtcbiAgICB0aGlzLl9jb250ZW50VHlwZXMucHVzaCguLi5hZGRpdGlvbmFsQ29udGVudFR5cGVzLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgaWYgKF9qd3RIYW5kbGVyKSB7XG4gICAgICB0aGlzLl9jb250ZW50VHlwZXMucHVzaChcImFwcGxpY2F0aW9uL2p3dFwiKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZmV0Y2hXaXRoVGltZW91dChpbnB1dCwgaW5pdCA9IHt9KSB7XG4gICAgY29uc3QgeyB0aW1lb3V0SW5TZWNvbmRzLCAuLi5pbml0RmV0Y2ggfSA9IGluaXQ7XG4gICAgaWYgKCF0aW1lb3V0SW5TZWNvbmRzKSB7XG4gICAgICByZXR1cm4gYXdhaXQgZmV0Y2goaW5wdXQsIGluaXRGZXRjaCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIHRpbWVvdXRJblNlY29uZHMgKiAxZTMpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGlucHV0LCB7XG4gICAgICAgIC4uLmluaXQsXG4gICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbiAmJiBlcnIubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yVGltZW91dChcIk5ldHdvcmsgdGltZWQgb3V0XCIpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZ2V0SnNvbih1cmwsIHtcbiAgICB0b2tlbixcbiAgICBjcmVkZW50aWFscyxcbiAgICB0aW1lb3V0SW5TZWNvbmRzXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiZ2V0SnNvblwiKTtcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgXCJBY2NlcHRcIjogdGhpcy5fY29udGVudFR5cGVzLmpvaW4oXCIsIFwiKVxuICAgIH07XG4gICAgaWYgKHRva2VuKSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwidG9rZW4gcGFzc2VkLCBzZXR0aW5nIEF1dGhvcml6YXRpb24gaGVhZGVyXCIpO1xuICAgICAgaGVhZGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSBcIkJlYXJlciBcIiArIHRva2VuO1xuICAgIH1cbiAgICB0aGlzLl9hcHBlbmRFeHRyYUhlYWRlcnMoaGVhZGVycyk7XG4gICAgbGV0IHJlc3BvbnNlO1xuICAgIHRyeSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwidXJsOlwiLCB1cmwpO1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoV2l0aFRpbWVvdXQodXJsLCB7IG1ldGhvZDogXCJHRVRcIiwgaGVhZGVycywgdGltZW91dEluU2Vjb25kcywgY3JlZGVudGlhbHMgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2dnZXIyLmVycm9yKFwiTmV0d29yayBFcnJvclwiKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcIkhUVFAgcmVzcG9uc2UgcmVjZWl2ZWQsIHN0YXR1c1wiLCByZXNwb25zZS5zdGF0dXMpO1xuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIik7XG4gICAgaWYgKGNvbnRlbnRUeXBlICYmICF0aGlzLl9jb250ZW50VHlwZXMuZmluZCgoaXRlbSkgPT4gY29udGVudFR5cGUuc3RhcnRzV2l0aChpdGVtKSkpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKGBJbnZhbGlkIHJlc3BvbnNlIENvbnRlbnQtVHlwZTogJHtjb250ZW50VHlwZSAhPSBudWxsID8gY29udGVudFR5cGUgOiBcInVuZGVmaW5lZFwifSwgZnJvbSBVUkw6ICR7dXJsfWApKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLm9rICYmIHRoaXMuX2p3dEhhbmRsZXIgJiYgKGNvbnRlbnRUeXBlID09IG51bGwgPyB2b2lkIDAgOiBjb250ZW50VHlwZS5zdGFydHNXaXRoKFwiYXBwbGljYXRpb24vand0XCIpKSkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2p3dEhhbmRsZXIoYXdhaXQgcmVzcG9uc2UudGV4dCgpKTtcbiAgICB9XG4gICAgbGV0IGpzb247XG4gICAgdHJ5IHtcbiAgICAgIGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2dnZXIyLmVycm9yKFwiRXJyb3IgcGFyc2luZyBKU09OIHJlc3BvbnNlXCIsIGVycik7XG4gICAgICBpZiAocmVzcG9uc2Uub2spIHRocm93IGVycjtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtyZXNwb25zZS5zdGF0dXNUZXh0fSAoJHtyZXNwb25zZS5zdGF0dXN9KWApO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBsb2dnZXIyLmVycm9yKFwiRXJyb3IgZnJvbSBzZXJ2ZXI6XCIsIGpzb24pO1xuICAgICAgaWYgKGpzb24uZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yUmVzcG9uc2UoanNvbik7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0gKCR7cmVzcG9uc2Uuc3RhdHVzfSk6ICR7SlNPTi5zdHJpbmdpZnkoanNvbil9YCk7XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xuICB9XG4gIGFzeW5jIHBvc3RGb3JtKHVybCwge1xuICAgIGJvZHksXG4gICAgYmFzaWNBdXRoLFxuICAgIHRpbWVvdXRJblNlY29uZHMsXG4gICAgaW5pdENyZWRlbnRpYWxzLFxuICAgIGV4dHJhSGVhZGVyc1xuICB9KSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJwb3N0Rm9ybVwiKTtcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgXCJBY2NlcHRcIjogdGhpcy5fY29udGVudFR5cGVzLmpvaW4oXCIsIFwiKSxcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsXG4gICAgICAuLi5leHRyYUhlYWRlcnNcbiAgICB9O1xuICAgIGlmIChiYXNpY0F1dGggIT09IHZvaWQgMCkge1xuICAgICAgaGVhZGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSBcIkJhc2ljIFwiICsgYmFzaWNBdXRoO1xuICAgIH1cbiAgICB0aGlzLl9hcHBlbmRFeHRyYUhlYWRlcnMoaGVhZGVycyk7XG4gICAgbGV0IHJlc3BvbnNlO1xuICAgIHRyeSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwidXJsOlwiLCB1cmwpO1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoV2l0aFRpbWVvdXQodXJsLCB7IG1ldGhvZDogXCJQT1NUXCIsIGhlYWRlcnMsIGJvZHksIHRpbWVvdXRJblNlY29uZHMsIGNyZWRlbnRpYWxzOiBpbml0Q3JlZGVudGlhbHMgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2dnZXIyLmVycm9yKFwiTmV0d29yayBlcnJvclwiKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcIkhUVFAgcmVzcG9uc2UgcmVjZWl2ZWQsIHN0YXR1c1wiLCByZXNwb25zZS5zdGF0dXMpO1xuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIik7XG4gICAgaWYgKGNvbnRlbnRUeXBlICYmICF0aGlzLl9jb250ZW50VHlwZXMuZmluZCgoaXRlbSkgPT4gY29udGVudFR5cGUuc3RhcnRzV2l0aChpdGVtKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCByZXNwb25zZSBDb250ZW50LVR5cGU6ICR7Y29udGVudFR5cGUgIT0gbnVsbCA/IGNvbnRlbnRUeXBlIDogXCJ1bmRlZmluZWRcIn0sIGZyb20gVVJMOiAke3VybH1gKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2VUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgIGxldCBqc29uID0ge307XG4gICAgaWYgKHJlc3BvbnNlVGV4dCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAganNvbiA9IEpTT04ucGFyc2UocmVzcG9uc2VUZXh0KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dnZXIyLmVycm9yKFwiRXJyb3IgcGFyc2luZyBKU09OIHJlc3BvbnNlXCIsIGVycik7XG4gICAgICAgIGlmIChyZXNwb25zZS5vaykgdGhyb3cgZXJyO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0gKCR7cmVzcG9uc2Uuc3RhdHVzfSlgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgbG9nZ2VyMi5lcnJvcihcIkVycm9yIGZyb20gc2VydmVyOlwiLCBqc29uKTtcbiAgICAgIGlmIChyZXNwb25zZS5oZWFkZXJzLmhhcyhcImRwb3Atbm9uY2VcIikpIHtcbiAgICAgICAgY29uc3Qgbm9uY2UgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImRwb3Atbm9uY2VcIik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvckRQb1BOb25jZShub25jZSwgYCR7SlNPTi5zdHJpbmdpZnkoanNvbil9YCk7XG4gICAgICB9XG4gICAgICBpZiAoanNvbi5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JSZXNwb25zZShqc29uLCBib2R5KTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtyZXNwb25zZS5zdGF0dXNUZXh0fSAoJHtyZXNwb25zZS5zdGF0dXN9KTogJHtKU09OLnN0cmluZ2lmeShqc29uKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG4gIH1cbiAgX2FwcGVuZEV4dHJhSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJhcHBlbmRFeHRyYUhlYWRlcnNcIik7XG4gICAgY29uc3QgY3VzdG9tS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX2V4dHJhSGVhZGVycyk7XG4gICAgY29uc3QgcHJvdGVjdGVkSGVhZGVycyA9IFtcbiAgICAgIFwiYWNjZXB0XCIsXG4gICAgICBcImNvbnRlbnQtdHlwZVwiXG4gICAgXTtcbiAgICBjb25zdCBwcmV2ZW50T3ZlcnJpZGUgPSBbXG4gICAgICBcImF1dGhvcml6YXRpb25cIlxuICAgIF07XG4gICAgaWYgKGN1c3RvbUtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN1c3RvbUtleXMuZm9yRWFjaCgoaGVhZGVyTmFtZSkgPT4ge1xuICAgICAgaWYgKHByb3RlY3RlZEhlYWRlcnMuaW5jbHVkZXMoaGVhZGVyTmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpKSkge1xuICAgICAgICBsb2dnZXIyLndhcm4oXCJQcm90ZWN0ZWQgaGVhZGVyIGNvdWxkIG5vdCBiZSBzZXRcIiwgaGVhZGVyTmFtZSwgcHJvdGVjdGVkSGVhZGVycyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2ZW50T3ZlcnJpZGUuaW5jbHVkZXMoaGVhZGVyTmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpKSAmJiBPYmplY3Qua2V5cyhoZWFkZXJzKS5pbmNsdWRlcyhoZWFkZXJOYW1lKSkge1xuICAgICAgICBsb2dnZXIyLndhcm4oXCJIZWFkZXIgY291bGQgbm90IGJlIG92ZXJyaWRkZW5cIiwgaGVhZGVyTmFtZSwgcHJldmVudE92ZXJyaWRlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY29udGVudCA9IHR5cGVvZiB0aGlzLl9leHRyYUhlYWRlcnNbaGVhZGVyTmFtZV0gPT09IFwiZnVuY3Rpb25cIiA/IHRoaXMuX2V4dHJhSGVhZGVyc1toZWFkZXJOYW1lXSgpIDogdGhpcy5fZXh0cmFIZWFkZXJzW2hlYWRlck5hbWVdO1xuICAgICAgaWYgKGNvbnRlbnQgJiYgY29udGVudCAhPT0gXCJcIikge1xuICAgICAgICBoZWFkZXJzW2hlYWRlck5hbWVdID0gY29udGVudDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL01ldGFkYXRhU2VydmljZS50c1xudmFyIE1ldGFkYXRhU2VydmljZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoX3NldHRpbmdzKSB7XG4gICAgdGhpcy5fc2V0dGluZ3MgPSBfc2V0dGluZ3M7XG4gICAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIk1ldGFkYXRhU2VydmljZVwiKTtcbiAgICB0aGlzLl9zaWduaW5nS2V5cyA9IG51bGw7XG4gICAgdGhpcy5fbWV0YWRhdGEgPSBudWxsO1xuICAgIHRoaXMuX21ldGFkYXRhVXJsID0gdGhpcy5fc2V0dGluZ3MubWV0YWRhdGFVcmw7XG4gICAgdGhpcy5fanNvblNlcnZpY2UgPSBuZXcgSnNvblNlcnZpY2UoXG4gICAgICBbXCJhcHBsaWNhdGlvbi9qd2stc2V0K2pzb25cIl0sXG4gICAgICBudWxsLFxuICAgICAgdGhpcy5fc2V0dGluZ3MuZXh0cmFIZWFkZXJzXG4gICAgKTtcbiAgICBpZiAodGhpcy5fc2V0dGluZ3Muc2lnbmluZ0tleXMpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhcInVzaW5nIHNpZ25pbmdLZXlzIGZyb20gc2V0dGluZ3NcIik7XG4gICAgICB0aGlzLl9zaWduaW5nS2V5cyA9IHRoaXMuX3NldHRpbmdzLnNpZ25pbmdLZXlzO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc2V0dGluZ3MubWV0YWRhdGEpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhcInVzaW5nIG1ldGFkYXRhIGZyb20gc2V0dGluZ3NcIik7XG4gICAgICB0aGlzLl9tZXRhZGF0YSA9IHRoaXMuX3NldHRpbmdzLm1ldGFkYXRhO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc2V0dGluZ3MuZmV0Y2hSZXF1ZXN0Q3JlZGVudGlhbHMpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhcInVzaW5nIGZldGNoUmVxdWVzdENyZWRlbnRpYWxzIGZyb20gc2V0dGluZ3NcIik7XG4gICAgICB0aGlzLl9mZXRjaFJlcXVlc3RDcmVkZW50aWFscyA9IHRoaXMuX3NldHRpbmdzLmZldGNoUmVxdWVzdENyZWRlbnRpYWxzO1xuICAgIH1cbiAgfVxuICByZXNldFNpZ25pbmdLZXlzKCkge1xuICAgIHRoaXMuX3NpZ25pbmdLZXlzID0gbnVsbDtcbiAgfVxuICBhc3luYyBnZXRNZXRhZGF0YSgpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcImdldE1ldGFkYXRhXCIpO1xuICAgIGlmICh0aGlzLl9tZXRhZGF0YSkge1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcInVzaW5nIGNhY2hlZCB2YWx1ZXNcIik7XG4gICAgICByZXR1cm4gdGhpcy5fbWV0YWRhdGE7XG4gICAgfVxuICAgIGlmICghdGhpcy5fbWV0YWRhdGFVcmwpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiTm8gYXV0aG9yaXR5IG9yIG1ldGFkYXRhVXJsIGNvbmZpZ3VyZWQgb24gc2V0dGluZ3NcIikpO1xuICAgICAgdGhyb3cgbnVsbDtcbiAgICB9XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcImdldHRpbmcgbWV0YWRhdGEgZnJvbVwiLCB0aGlzLl9tZXRhZGF0YVVybCk7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCB0aGlzLl9qc29uU2VydmljZS5nZXRKc29uKHRoaXMuX21ldGFkYXRhVXJsLCB7IGNyZWRlbnRpYWxzOiB0aGlzLl9mZXRjaFJlcXVlc3RDcmVkZW50aWFscywgdGltZW91dEluU2Vjb25kczogdGhpcy5fc2V0dGluZ3MucmVxdWVzdFRpbWVvdXRJblNlY29uZHMgfSk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcIm1lcmdpbmcgcmVtb3RlIEpTT04gd2l0aCBzZWVkIG1ldGFkYXRhXCIpO1xuICAgIHRoaXMuX21ldGFkYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgbWV0YWRhdGEsIHRoaXMuX3NldHRpbmdzLm1ldGFkYXRhU2VlZCk7XG4gICAgcmV0dXJuIHRoaXMuX21ldGFkYXRhO1xuICB9XG4gIGdldElzc3VlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TWV0YWRhdGFQcm9wZXJ0eShcImlzc3VlclwiKTtcbiAgfVxuICBnZXRBdXRob3JpemF0aW9uRW5kcG9pbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldE1ldGFkYXRhUHJvcGVydHkoXCJhdXRob3JpemF0aW9uX2VuZHBvaW50XCIpO1xuICB9XG4gIGdldFVzZXJJbmZvRW5kcG9pbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldE1ldGFkYXRhUHJvcGVydHkoXCJ1c2VyaW5mb19lbmRwb2ludFwiKTtcbiAgfVxuICBnZXRUb2tlbkVuZHBvaW50KG9wdGlvbmFsID0gdHJ1ZSkge1xuICAgIHJldHVybiB0aGlzLl9nZXRNZXRhZGF0YVByb3BlcnR5KFwidG9rZW5fZW5kcG9pbnRcIiwgb3B0aW9uYWwpO1xuICB9XG4gIGdldENoZWNrU2Vzc2lvbklmcmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TWV0YWRhdGFQcm9wZXJ0eShcImNoZWNrX3Nlc3Npb25faWZyYW1lXCIsIHRydWUpO1xuICB9XG4gIGdldEVuZFNlc3Npb25FbmRwb2ludCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TWV0YWRhdGFQcm9wZXJ0eShcImVuZF9zZXNzaW9uX2VuZHBvaW50XCIsIHRydWUpO1xuICB9XG4gIGdldFJldm9jYXRpb25FbmRwb2ludChvcHRpb25hbCA9IHRydWUpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TWV0YWRhdGFQcm9wZXJ0eShcInJldm9jYXRpb25fZW5kcG9pbnRcIiwgb3B0aW9uYWwpO1xuICB9XG4gIGdldEtleXNFbmRwb2ludChvcHRpb25hbCA9IHRydWUpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TWV0YWRhdGFQcm9wZXJ0eShcImp3a3NfdXJpXCIsIG9wdGlvbmFsKTtcbiAgfVxuICBhc3luYyBfZ2V0TWV0YWRhdGFQcm9wZXJ0eShuYW1lLCBvcHRpb25hbCA9IGZhbHNlKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoYF9nZXRNZXRhZGF0YVByb3BlcnR5KCcke25hbWV9JylgKTtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHRoaXMuZ2V0TWV0YWRhdGEoKTtcbiAgICBsb2dnZXIyLmRlYnVnKFwicmVzb2x2ZWRcIik7XG4gICAgaWYgKG1ldGFkYXRhW25hbWVdID09PSB2b2lkIDApIHtcbiAgICAgIGlmIChvcHRpb25hbCA9PT0gdHJ1ZSkge1xuICAgICAgICBsb2dnZXIyLndhcm4oXCJNZXRhZGF0YSBkb2VzIG5vdCBjb250YWluIG9wdGlvbmFsIHByb3BlcnR5XCIpO1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJNZXRhZGF0YSBkb2VzIG5vdCBjb250YWluIHByb3BlcnR5IFwiICsgbmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gbWV0YWRhdGFbbmFtZV07XG4gIH1cbiAgYXN5bmMgZ2V0U2lnbmluZ0tleXMoKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJnZXRTaWduaW5nS2V5c1wiKTtcbiAgICBpZiAodGhpcy5fc2lnbmluZ0tleXMpIHtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJyZXR1cm5pbmcgc2lnbmluZ0tleXMgZnJvbSBjYWNoZVwiKTtcbiAgICAgIHJldHVybiB0aGlzLl9zaWduaW5nS2V5cztcbiAgICB9XG4gICAgY29uc3Qgandrc191cmkgPSBhd2FpdCB0aGlzLmdldEtleXNFbmRwb2ludChmYWxzZSk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcImdvdCBqd2tzX3VyaVwiLCBqd2tzX3VyaSk7XG4gICAgY29uc3Qga2V5U2V0ID0gYXdhaXQgdGhpcy5fanNvblNlcnZpY2UuZ2V0SnNvbihqd2tzX3VyaSwgeyB0aW1lb3V0SW5TZWNvbmRzOiB0aGlzLl9zZXR0aW5ncy5yZXF1ZXN0VGltZW91dEluU2Vjb25kcyB9KTtcbiAgICBsb2dnZXIyLmRlYnVnKFwiZ290IGtleSBzZXRcIiwga2V5U2V0KTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5U2V0LmtleXMpKSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIk1pc3Npbmcga2V5cyBvbiBrZXlzZXRcIikpO1xuICAgICAgdGhyb3cgbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fc2lnbmluZ0tleXMgPSBrZXlTZXQua2V5cztcbiAgICByZXR1cm4gdGhpcy5fc2lnbmluZ0tleXM7XG4gIH1cbn07XG5cbi8vIHNyYy9XZWJTdG9yYWdlU3RhdGVTdG9yZS50c1xudmFyIFdlYlN0b3JhZ2VTdGF0ZVN0b3JlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcHJlZml4ID0gXCJvaWRjLlwiLFxuICAgIHN0b3JlID0gbG9jYWxTdG9yYWdlXG4gIH0gPSB7fSkge1xuICAgIHRoaXMuX2xvZ2dlciA9IG5ldyBMb2dnZXIoXCJXZWJTdG9yYWdlU3RhdGVTdG9yZVwiKTtcbiAgICB0aGlzLl9zdG9yZSA9IHN0b3JlO1xuICAgIHRoaXMuX3ByZWZpeCA9IHByZWZpeDtcbiAgfVxuICBhc3luYyBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX2xvZ2dlci5jcmVhdGUoYHNldCgnJHtrZXl9JylgKTtcbiAgICBrZXkgPSB0aGlzLl9wcmVmaXggKyBrZXk7XG4gICAgYXdhaXQgdGhpcy5fc3RvcmUuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgfVxuICBhc3luYyBnZXQoa2V5KSB7XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShgZ2V0KCcke2tleX0nKWApO1xuICAgIGtleSA9IHRoaXMuX3ByZWZpeCArIGtleTtcbiAgICBjb25zdCBpdGVtID0gYXdhaXQgdGhpcy5fc3RvcmUuZ2V0SXRlbShrZXkpO1xuICAgIHJldHVybiBpdGVtO1xuICB9XG4gIGFzeW5jIHJlbW92ZShrZXkpIHtcbiAgICB0aGlzLl9sb2dnZXIuY3JlYXRlKGByZW1vdmUoJyR7a2V5fScpYCk7XG4gICAga2V5ID0gdGhpcy5fcHJlZml4ICsga2V5O1xuICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCB0aGlzLl9zdG9yZS5nZXRJdGVtKGtleSk7XG4gICAgYXdhaXQgdGhpcy5fc3RvcmUucmVtb3ZlSXRlbShrZXkpO1xuICAgIHJldHVybiBpdGVtO1xuICB9XG4gIGFzeW5jIGdldEFsbEtleXMoKSB7XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShcImdldEFsbEtleXNcIik7XG4gICAgY29uc3QgbGVuID0gYXdhaXQgdGhpcy5fc3RvcmUubGVuZ3RoO1xuICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGVuOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBhd2FpdCB0aGlzLl9zdG9yZS5rZXkoaW5kZXgpO1xuICAgICAgaWYgKGtleSAmJiBrZXkuaW5kZXhPZih0aGlzLl9wcmVmaXgpID09PSAwKSB7XG4gICAgICAgIGtleXMucHVzaChrZXkuc3Vic3RyKHRoaXMuX3ByZWZpeC5sZW5ndGgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG4gIH1cbn07XG5cbi8vIHNyYy9PaWRjQ2xpZW50U2V0dGluZ3MudHNcbnZhciBEZWZhdWx0UmVzcG9uc2VUeXBlID0gXCJjb2RlXCI7XG52YXIgRGVmYXVsdFNjb3BlID0gXCJvcGVuaWRcIjtcbnZhciBEZWZhdWx0Q2xpZW50QXV0aGVudGljYXRpb24gPSBcImNsaWVudF9zZWNyZXRfcG9zdFwiO1xudmFyIERlZmF1bHRTdGFsZVN0YXRlQWdlSW5TZWNvbmRzID0gNjAgKiAxNTtcbnZhciBPaWRjQ2xpZW50U2V0dGluZ3NTdG9yZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIC8vIG1ldGFkYXRhIHJlbGF0ZWRcbiAgICBhdXRob3JpdHksXG4gICAgbWV0YWRhdGFVcmwsXG4gICAgbWV0YWRhdGEsXG4gICAgc2lnbmluZ0tleXMsXG4gICAgbWV0YWRhdGFTZWVkLFxuICAgIC8vIGNsaWVudCByZWxhdGVkXG4gICAgY2xpZW50X2lkLFxuICAgIGNsaWVudF9zZWNyZXQsXG4gICAgcmVzcG9uc2VfdHlwZSA9IERlZmF1bHRSZXNwb25zZVR5cGUsXG4gICAgc2NvcGUgPSBEZWZhdWx0U2NvcGUsXG4gICAgcmVkaXJlY3RfdXJpLFxuICAgIHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSxcbiAgICBjbGllbnRfYXV0aGVudGljYXRpb24gPSBEZWZhdWx0Q2xpZW50QXV0aGVudGljYXRpb24sXG4gICAgLy8gb3B0aW9uYWwgcHJvdG9jb2xcbiAgICBwcm9tcHQsXG4gICAgZGlzcGxheSxcbiAgICBtYXhfYWdlLFxuICAgIHVpX2xvY2FsZXMsXG4gICAgYWNyX3ZhbHVlcyxcbiAgICByZXNvdXJjZSxcbiAgICByZXNwb25zZV9tb2RlLFxuICAgIC8vIGJlaGF2aW9yIGZsYWdzXG4gICAgZmlsdGVyUHJvdG9jb2xDbGFpbXMgPSB0cnVlLFxuICAgIGxvYWRVc2VySW5mbyA9IGZhbHNlLFxuICAgIHJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzLFxuICAgIHN0YWxlU3RhdGVBZ2VJblNlY29uZHMgPSBEZWZhdWx0U3RhbGVTdGF0ZUFnZUluU2Vjb25kcyxcbiAgICBtZXJnZUNsYWltc1N0cmF0ZWd5ID0geyBhcnJheTogXCJyZXBsYWNlXCIgfSxcbiAgICBkaXNhYmxlUEtDRSA9IGZhbHNlLFxuICAgIC8vIG90aGVyIGJlaGF2aW9yXG4gICAgc3RhdGVTdG9yZSxcbiAgICByZXZva2VUb2tlbkFkZGl0aW9uYWxDb250ZW50VHlwZXMsXG4gICAgZmV0Y2hSZXF1ZXN0Q3JlZGVudGlhbHMsXG4gICAgcmVmcmVzaFRva2VuQWxsb3dlZFNjb3BlLFxuICAgIC8vIGV4dHJhXG4gICAgZXh0cmFRdWVyeVBhcmFtcyA9IHt9LFxuICAgIGV4dHJhVG9rZW5QYXJhbXMgPSB7fSxcbiAgICBleHRyYUhlYWRlcnMgPSB7fSxcbiAgICBkcG9wLFxuICAgIG9taXRTY29wZVdoZW5SZXF1ZXN0aW5nID0gZmFsc2VcbiAgfSkge1xuICAgIHZhciBfYTtcbiAgICB0aGlzLmF1dGhvcml0eSA9IGF1dGhvcml0eTtcbiAgICBpZiAobWV0YWRhdGFVcmwpIHtcbiAgICAgIHRoaXMubWV0YWRhdGFVcmwgPSBtZXRhZGF0YVVybDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tZXRhZGF0YVVybCA9IGF1dGhvcml0eTtcbiAgICAgIGlmIChhdXRob3JpdHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1ldGFkYXRhVXJsLmVuZHNXaXRoKFwiL1wiKSkge1xuICAgICAgICAgIHRoaXMubWV0YWRhdGFVcmwgKz0gXCIvXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZXRhZGF0YVVybCArPSBcIi53ZWxsLWtub3duL29wZW5pZC1jb25maWd1cmF0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICB0aGlzLm1ldGFkYXRhU2VlZCA9IG1ldGFkYXRhU2VlZDtcbiAgICB0aGlzLnNpZ25pbmdLZXlzID0gc2lnbmluZ0tleXM7XG4gICAgdGhpcy5jbGllbnRfaWQgPSBjbGllbnRfaWQ7XG4gICAgdGhpcy5jbGllbnRfc2VjcmV0ID0gY2xpZW50X3NlY3JldDtcbiAgICB0aGlzLnJlc3BvbnNlX3R5cGUgPSByZXNwb25zZV90eXBlO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLnJlZGlyZWN0X3VyaSA9IHJlZGlyZWN0X3VyaTtcbiAgICB0aGlzLnBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSA9IHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaTtcbiAgICB0aGlzLmNsaWVudF9hdXRoZW50aWNhdGlvbiA9IGNsaWVudF9hdXRoZW50aWNhdGlvbjtcbiAgICB0aGlzLnByb21wdCA9IHByb21wdDtcbiAgICB0aGlzLmRpc3BsYXkgPSBkaXNwbGF5O1xuICAgIHRoaXMubWF4X2FnZSA9IG1heF9hZ2U7XG4gICAgdGhpcy51aV9sb2NhbGVzID0gdWlfbG9jYWxlcztcbiAgICB0aGlzLmFjcl92YWx1ZXMgPSBhY3JfdmFsdWVzO1xuICAgIHRoaXMucmVzb3VyY2UgPSByZXNvdXJjZTtcbiAgICB0aGlzLnJlc3BvbnNlX21vZGUgPSByZXNwb25zZV9tb2RlO1xuICAgIHRoaXMuZmlsdGVyUHJvdG9jb2xDbGFpbXMgPSBmaWx0ZXJQcm90b2NvbENsYWltcyAhPSBudWxsID8gZmlsdGVyUHJvdG9jb2xDbGFpbXMgOiB0cnVlO1xuICAgIHRoaXMubG9hZFVzZXJJbmZvID0gISFsb2FkVXNlckluZm87XG4gICAgdGhpcy5zdGFsZVN0YXRlQWdlSW5TZWNvbmRzID0gc3RhbGVTdGF0ZUFnZUluU2Vjb25kcztcbiAgICB0aGlzLm1lcmdlQ2xhaW1zU3RyYXRlZ3kgPSBtZXJnZUNsYWltc1N0cmF0ZWd5O1xuICAgIHRoaXMub21pdFNjb3BlV2hlblJlcXVlc3RpbmcgPSBvbWl0U2NvcGVXaGVuUmVxdWVzdGluZztcbiAgICB0aGlzLmRpc2FibGVQS0NFID0gISFkaXNhYmxlUEtDRTtcbiAgICB0aGlzLnJldm9rZVRva2VuQWRkaXRpb25hbENvbnRlbnRUeXBlcyA9IHJldm9rZVRva2VuQWRkaXRpb25hbENvbnRlbnRUeXBlcztcbiAgICB0aGlzLmZldGNoUmVxdWVzdENyZWRlbnRpYWxzID0gZmV0Y2hSZXF1ZXN0Q3JlZGVudGlhbHMgPyBmZXRjaFJlcXVlc3RDcmVkZW50aWFscyA6IFwic2FtZS1vcmlnaW5cIjtcbiAgICB0aGlzLnJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzID0gcmVxdWVzdFRpbWVvdXRJblNlY29uZHM7XG4gICAgaWYgKHN0YXRlU3RvcmUpIHtcbiAgICAgIHRoaXMuc3RhdGVTdG9yZSA9IHN0YXRlU3RvcmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0b3JlID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5sb2NhbFN0b3JhZ2UgOiBuZXcgSW5NZW1vcnlXZWJTdG9yYWdlKCk7XG4gICAgICB0aGlzLnN0YXRlU3RvcmUgPSBuZXcgV2ViU3RvcmFnZVN0YXRlU3RvcmUoeyBzdG9yZSB9KTtcbiAgICB9XG4gICAgdGhpcy5yZWZyZXNoVG9rZW5BbGxvd2VkU2NvcGUgPSByZWZyZXNoVG9rZW5BbGxvd2VkU2NvcGU7XG4gICAgdGhpcy5leHRyYVF1ZXJ5UGFyYW1zID0gZXh0cmFRdWVyeVBhcmFtcztcbiAgICB0aGlzLmV4dHJhVG9rZW5QYXJhbXMgPSBleHRyYVRva2VuUGFyYW1zO1xuICAgIHRoaXMuZXh0cmFIZWFkZXJzID0gZXh0cmFIZWFkZXJzO1xuICAgIHRoaXMuZHBvcCA9IGRwb3A7XG4gICAgaWYgKHRoaXMuZHBvcCAmJiAhKChfYSA9IHRoaXMuZHBvcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnN0b3JlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBEUG9QU3RvcmUgaXMgcmVxdWlyZWQgd2hlbiBkcG9wIGlzIGVuYWJsZWRcIik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvVXNlckluZm9TZXJ2aWNlLnRzXG52YXIgVXNlckluZm9TZXJ2aWNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihfc2V0dGluZ3MsIF9tZXRhZGF0YVNlcnZpY2UpIHtcbiAgICB0aGlzLl9zZXR0aW5ncyA9IF9zZXR0aW5ncztcbiAgICB0aGlzLl9tZXRhZGF0YVNlcnZpY2UgPSBfbWV0YWRhdGFTZXJ2aWNlO1xuICAgIHRoaXMuX2xvZ2dlciA9IG5ldyBMb2dnZXIoXCJVc2VySW5mb1NlcnZpY2VcIik7XG4gICAgdGhpcy5fZ2V0Q2xhaW1zRnJvbUp3dCA9IGFzeW5jIChyZXNwb25zZVRleHQpID0+IHtcbiAgICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiX2dldENsYWltc0Zyb21Kd3RcIik7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gSnd0VXRpbHMuZGVjb2RlKHJlc3BvbnNlVGV4dCk7XG4gICAgICAgIGxvZ2dlcjIuZGVidWcoXCJKV1QgZGVjb2Rpbmcgc3VjY2Vzc2Z1bFwiKTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nZ2VyMi5lcnJvcihcIkVycm9yIHBhcnNpbmcgSldUIHJlc3BvbnNlXCIpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9qc29uU2VydmljZSA9IG5ldyBKc29uU2VydmljZShcbiAgICAgIHZvaWQgMCxcbiAgICAgIHRoaXMuX2dldENsYWltc0Zyb21Kd3QsXG4gICAgICB0aGlzLl9zZXR0aW5ncy5leHRyYUhlYWRlcnNcbiAgICApO1xuICB9XG4gIGFzeW5jIGdldENsYWltcyh0b2tlbikge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiZ2V0Q2xhaW1zXCIpO1xuICAgIGlmICghdG9rZW4pIHtcbiAgICAgIHRoaXMuX2xvZ2dlci50aHJvdyhuZXcgRXJyb3IoXCJObyB0b2tlbiBwYXNzZWRcIikpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLl9tZXRhZGF0YVNlcnZpY2UuZ2V0VXNlckluZm9FbmRwb2ludCgpO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJnb3QgdXNlcmluZm8gdXJsXCIsIHVybCk7XG4gICAgY29uc3QgY2xhaW1zID0gYXdhaXQgdGhpcy5fanNvblNlcnZpY2UuZ2V0SnNvbih1cmwsIHtcbiAgICAgIHRva2VuLFxuICAgICAgY3JlZGVudGlhbHM6IHRoaXMuX3NldHRpbmdzLmZldGNoUmVxdWVzdENyZWRlbnRpYWxzLFxuICAgICAgdGltZW91dEluU2Vjb25kczogdGhpcy5fc2V0dGluZ3MucmVxdWVzdFRpbWVvdXRJblNlY29uZHNcbiAgICB9KTtcbiAgICBsb2dnZXIyLmRlYnVnKFwiZ290IGNsYWltc1wiLCBjbGFpbXMpO1xuICAgIHJldHVybiBjbGFpbXM7XG4gIH1cbn07XG5cbi8vIHNyYy9Ub2tlbkNsaWVudC50c1xudmFyIFRva2VuQ2xpZW50ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihfc2V0dGluZ3MsIF9tZXRhZGF0YVNlcnZpY2UpIHtcbiAgICB0aGlzLl9zZXR0aW5ncyA9IF9zZXR0aW5ncztcbiAgICB0aGlzLl9tZXRhZGF0YVNlcnZpY2UgPSBfbWV0YWRhdGFTZXJ2aWNlO1xuICAgIHRoaXMuX2xvZ2dlciA9IG5ldyBMb2dnZXIoXCJUb2tlbkNsaWVudFwiKTtcbiAgICB0aGlzLl9qc29uU2VydmljZSA9IG5ldyBKc29uU2VydmljZShcbiAgICAgIHRoaXMuX3NldHRpbmdzLnJldm9rZVRva2VuQWRkaXRpb25hbENvbnRlbnRUeXBlcyxcbiAgICAgIG51bGwsXG4gICAgICB0aGlzLl9zZXR0aW5ncy5leHRyYUhlYWRlcnNcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBFeGNoYW5nZSBjb2RlLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM2NzQ5I3NlY3Rpb24tNC4xLjNcbiAgICovXG4gIGFzeW5jIGV4Y2hhbmdlQ29kZSh7XG4gICAgZ3JhbnRfdHlwZSA9IFwiYXV0aG9yaXphdGlvbl9jb2RlXCIsXG4gICAgcmVkaXJlY3RfdXJpID0gdGhpcy5fc2V0dGluZ3MucmVkaXJlY3RfdXJpLFxuICAgIGNsaWVudF9pZCA9IHRoaXMuX3NldHRpbmdzLmNsaWVudF9pZCxcbiAgICBjbGllbnRfc2VjcmV0ID0gdGhpcy5fc2V0dGluZ3MuY2xpZW50X3NlY3JldCxcbiAgICBleHRyYUhlYWRlcnMsXG4gICAgLi4uYXJnc1xuICB9KSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJleGNoYW5nZUNvZGVcIik7XG4gICAgaWYgKCFjbGllbnRfaWQpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiQSBjbGllbnRfaWQgaXMgcmVxdWlyZWRcIikpO1xuICAgIH1cbiAgICBpZiAoIXJlZGlyZWN0X3VyaSkge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJBIHJlZGlyZWN0X3VyaSBpcyByZXF1aXJlZFwiKSk7XG4gICAgfVxuICAgIGlmICghYXJncy5jb2RlKSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIkEgY29kZSBpcyByZXF1aXJlZFwiKSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBncmFudF90eXBlLCByZWRpcmVjdF91cmkgfSk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYXJncykpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHBhcmFtcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBiYXNpY0F1dGg7XG4gICAgc3dpdGNoICh0aGlzLl9zZXR0aW5ncy5jbGllbnRfYXV0aGVudGljYXRpb24pIHtcbiAgICAgIGNhc2UgXCJjbGllbnRfc2VjcmV0X2Jhc2ljXCI6XG4gICAgICAgIGlmIChjbGllbnRfc2VjcmV0ID09PSB2b2lkIDAgfHwgY2xpZW50X3NlY3JldCA9PT0gbnVsbCkge1xuICAgICAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiQSBjbGllbnRfc2VjcmV0IGlzIHJlcXVpcmVkXCIpKTtcbiAgICAgICAgICB0aHJvdyBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGJhc2ljQXV0aCA9IENyeXB0b1V0aWxzLmdlbmVyYXRlQmFzaWNBdXRoKGNsaWVudF9pZCwgY2xpZW50X3NlY3JldCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImNsaWVudF9zZWNyZXRfcG9zdFwiOlxuICAgICAgICBwYXJhbXMuYXBwZW5kKFwiY2xpZW50X2lkXCIsIGNsaWVudF9pZCk7XG4gICAgICAgIGlmIChjbGllbnRfc2VjcmV0KSB7XG4gICAgICAgICAgcGFyYW1zLmFwcGVuZChcImNsaWVudF9zZWNyZXRcIiwgY2xpZW50X3NlY3JldCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IGF3YWl0IHRoaXMuX21ldGFkYXRhU2VydmljZS5nZXRUb2tlbkVuZHBvaW50KGZhbHNlKTtcbiAgICBsb2dnZXIyLmRlYnVnKFwiZ290IHRva2VuIGVuZHBvaW50XCIpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fanNvblNlcnZpY2UucG9zdEZvcm0odXJsLCB7XG4gICAgICBib2R5OiBwYXJhbXMsXG4gICAgICBiYXNpY0F1dGgsXG4gICAgICB0aW1lb3V0SW5TZWNvbmRzOiB0aGlzLl9zZXR0aW5ncy5yZXF1ZXN0VGltZW91dEluU2Vjb25kcyxcbiAgICAgIGluaXRDcmVkZW50aWFsczogdGhpcy5fc2V0dGluZ3MuZmV0Y2hSZXF1ZXN0Q3JlZGVudGlhbHMsXG4gICAgICBleHRyYUhlYWRlcnNcbiAgICB9KTtcbiAgICBsb2dnZXIyLmRlYnVnKFwiZ290IHJlc3BvbnNlXCIpO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICAvKipcbiAgICogRXhjaGFuZ2UgY3JlZGVudGlhbHMuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzY3NDkjc2VjdGlvbi00LjMuMlxuICAgKi9cbiAgYXN5bmMgZXhjaGFuZ2VDcmVkZW50aWFscyh7XG4gICAgZ3JhbnRfdHlwZSA9IFwicGFzc3dvcmRcIixcbiAgICBjbGllbnRfaWQgPSB0aGlzLl9zZXR0aW5ncy5jbGllbnRfaWQsXG4gICAgY2xpZW50X3NlY3JldCA9IHRoaXMuX3NldHRpbmdzLmNsaWVudF9zZWNyZXQsXG4gICAgc2NvcGUgPSB0aGlzLl9zZXR0aW5ncy5zY29wZSxcbiAgICAuLi5hcmdzXG4gIH0pIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcImV4Y2hhbmdlQ3JlZGVudGlhbHNcIik7XG4gICAgaWYgKCFjbGllbnRfaWQpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiQSBjbGllbnRfaWQgaXMgcmVxdWlyZWRcIikpO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgZ3JhbnRfdHlwZSB9KTtcbiAgICBpZiAoIXRoaXMuX3NldHRpbmdzLm9taXRTY29wZVdoZW5SZXF1ZXN0aW5nKSB7XG4gICAgICBwYXJhbXMuc2V0KFwic2NvcGVcIiwgc2NvcGUpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhcmdzKSkge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcGFyYW1zLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGJhc2ljQXV0aDtcbiAgICBzd2l0Y2ggKHRoaXMuX3NldHRpbmdzLmNsaWVudF9hdXRoZW50aWNhdGlvbikge1xuICAgICAgY2FzZSBcImNsaWVudF9zZWNyZXRfYmFzaWNcIjpcbiAgICAgICAgaWYgKGNsaWVudF9zZWNyZXQgPT09IHZvaWQgMCB8fCBjbGllbnRfc2VjcmV0ID09PSBudWxsKSB7XG4gICAgICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJBIGNsaWVudF9zZWNyZXQgaXMgcmVxdWlyZWRcIikpO1xuICAgICAgICAgIHRocm93IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYmFzaWNBdXRoID0gQ3J5cHRvVXRpbHMuZ2VuZXJhdGVCYXNpY0F1dGgoY2xpZW50X2lkLCBjbGllbnRfc2VjcmV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY2xpZW50X3NlY3JldF9wb3N0XCI6XG4gICAgICAgIHBhcmFtcy5hcHBlbmQoXCJjbGllbnRfaWRcIiwgY2xpZW50X2lkKTtcbiAgICAgICAgaWYgKGNsaWVudF9zZWNyZXQpIHtcbiAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiY2xpZW50X3NlY3JldFwiLCBjbGllbnRfc2VjcmV0KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgdXJsID0gYXdhaXQgdGhpcy5fbWV0YWRhdGFTZXJ2aWNlLmdldFRva2VuRW5kcG9pbnQoZmFsc2UpO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJnb3QgdG9rZW4gZW5kcG9pbnRcIik7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9qc29uU2VydmljZS5wb3N0Rm9ybSh1cmwsIHsgYm9keTogcGFyYW1zLCBiYXNpY0F1dGgsIHRpbWVvdXRJblNlY29uZHM6IHRoaXMuX3NldHRpbmdzLnJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzLCBpbml0Q3JlZGVudGlhbHM6IHRoaXMuX3NldHRpbmdzLmZldGNoUmVxdWVzdENyZWRlbnRpYWxzIH0pO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJnb3QgcmVzcG9uc2VcIik7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIC8qKlxuICAgKiBFeGNoYW5nZSBhIHJlZnJlc2ggdG9rZW4uXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzY3NDkjc2VjdGlvbi02XG4gICAqL1xuICBhc3luYyBleGNoYW5nZVJlZnJlc2hUb2tlbih7XG4gICAgZ3JhbnRfdHlwZSA9IFwicmVmcmVzaF90b2tlblwiLFxuICAgIGNsaWVudF9pZCA9IHRoaXMuX3NldHRpbmdzLmNsaWVudF9pZCxcbiAgICBjbGllbnRfc2VjcmV0ID0gdGhpcy5fc2V0dGluZ3MuY2xpZW50X3NlY3JldCxcbiAgICB0aW1lb3V0SW5TZWNvbmRzLFxuICAgIGV4dHJhSGVhZGVycyxcbiAgICAuLi5hcmdzXG4gIH0pIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcImV4Y2hhbmdlUmVmcmVzaFRva2VuXCIpO1xuICAgIGlmICghY2xpZW50X2lkKSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIkEgY2xpZW50X2lkIGlzIHJlcXVpcmVkXCIpKTtcbiAgICB9XG4gICAgaWYgKCFhcmdzLnJlZnJlc2hfdG9rZW4pIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiQSByZWZyZXNoX3Rva2VuIGlzIHJlcXVpcmVkXCIpKTtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7IGdyYW50X3R5cGUgfSk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYXJncykpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKChwYXJhbSkgPT4gcGFyYW1zLmFwcGVuZChrZXksIHBhcmFtKSk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcGFyYW1zLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGJhc2ljQXV0aDtcbiAgICBzd2l0Y2ggKHRoaXMuX3NldHRpbmdzLmNsaWVudF9hdXRoZW50aWNhdGlvbikge1xuICAgICAgY2FzZSBcImNsaWVudF9zZWNyZXRfYmFzaWNcIjpcbiAgICAgICAgaWYgKGNsaWVudF9zZWNyZXQgPT09IHZvaWQgMCB8fCBjbGllbnRfc2VjcmV0ID09PSBudWxsKSB7XG4gICAgICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJBIGNsaWVudF9zZWNyZXQgaXMgcmVxdWlyZWRcIikpO1xuICAgICAgICAgIHRocm93IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYmFzaWNBdXRoID0gQ3J5cHRvVXRpbHMuZ2VuZXJhdGVCYXNpY0F1dGgoY2xpZW50X2lkLCBjbGllbnRfc2VjcmV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY2xpZW50X3NlY3JldF9wb3N0XCI6XG4gICAgICAgIHBhcmFtcy5hcHBlbmQoXCJjbGllbnRfaWRcIiwgY2xpZW50X2lkKTtcbiAgICAgICAgaWYgKGNsaWVudF9zZWNyZXQpIHtcbiAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiY2xpZW50X3NlY3JldFwiLCBjbGllbnRfc2VjcmV0KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgdXJsID0gYXdhaXQgdGhpcy5fbWV0YWRhdGFTZXJ2aWNlLmdldFRva2VuRW5kcG9pbnQoZmFsc2UpO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJnb3QgdG9rZW4gZW5kcG9pbnRcIik7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9qc29uU2VydmljZS5wb3N0Rm9ybSh1cmwsIHsgYm9keTogcGFyYW1zLCBiYXNpY0F1dGgsIHRpbWVvdXRJblNlY29uZHMsIGluaXRDcmVkZW50aWFsczogdGhpcy5fc2V0dGluZ3MuZmV0Y2hSZXF1ZXN0Q3JlZGVudGlhbHMsIGV4dHJhSGVhZGVycyB9KTtcbiAgICBsb2dnZXIyLmRlYnVnKFwiZ290IHJlc3BvbnNlXCIpO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICAvKipcbiAgICogUmV2b2tlIGFuIGFjY2VzcyBvciByZWZyZXNoIHRva2VuLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNzAwOSNzZWN0aW9uLTIuMVxuICAgKi9cbiAgYXN5bmMgcmV2b2tlKGFyZ3MpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJyZXZva2VcIik7XG4gICAgaWYgKCFhcmdzLnRva2VuKSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIkEgdG9rZW4gaXMgcmVxdWlyZWRcIikpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLl9tZXRhZGF0YVNlcnZpY2UuZ2V0UmV2b2NhdGlvbkVuZHBvaW50KGZhbHNlKTtcbiAgICBsb2dnZXIyLmRlYnVnKGBnb3QgcmV2b2NhdGlvbiBlbmRwb2ludCwgcmV2b2tpbmcgJHsoX2EgPSBhcmdzLnRva2VuX3R5cGVfaGludCkgIT0gbnVsbCA/IF9hIDogXCJkZWZhdWx0IHRva2VuIHR5cGVcIn1gKTtcbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYXJncykpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHBhcmFtcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHBhcmFtcy5zZXQoXCJjbGllbnRfaWRcIiwgdGhpcy5fc2V0dGluZ3MuY2xpZW50X2lkKTtcbiAgICBpZiAodGhpcy5fc2V0dGluZ3MuY2xpZW50X3NlY3JldCkge1xuICAgICAgcGFyYW1zLnNldChcImNsaWVudF9zZWNyZXRcIiwgdGhpcy5fc2V0dGluZ3MuY2xpZW50X3NlY3JldCk7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuX2pzb25TZXJ2aWNlLnBvc3RGb3JtKHVybCwgeyBib2R5OiBwYXJhbXMsIHRpbWVvdXRJblNlY29uZHM6IHRoaXMuX3NldHRpbmdzLnJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzIH0pO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJnb3QgcmVzcG9uc2VcIik7XG4gIH1cbn07XG5cbi8vIHNyYy9SZXNwb25zZVZhbGlkYXRvci50c1xudmFyIFJlc3BvbnNlVmFsaWRhdG9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihfc2V0dGluZ3MsIF9tZXRhZGF0YVNlcnZpY2UsIF9jbGFpbXNTZXJ2aWNlKSB7XG4gICAgdGhpcy5fc2V0dGluZ3MgPSBfc2V0dGluZ3M7XG4gICAgdGhpcy5fbWV0YWRhdGFTZXJ2aWNlID0gX21ldGFkYXRhU2VydmljZTtcbiAgICB0aGlzLl9jbGFpbXNTZXJ2aWNlID0gX2NsYWltc1NlcnZpY2U7XG4gICAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIlJlc3BvbnNlVmFsaWRhdG9yXCIpO1xuICAgIHRoaXMuX3VzZXJJbmZvU2VydmljZSA9IG5ldyBVc2VySW5mb1NlcnZpY2UodGhpcy5fc2V0dGluZ3MsIHRoaXMuX21ldGFkYXRhU2VydmljZSk7XG4gICAgdGhpcy5fdG9rZW5DbGllbnQgPSBuZXcgVG9rZW5DbGllbnQodGhpcy5fc2V0dGluZ3MsIHRoaXMuX21ldGFkYXRhU2VydmljZSk7XG4gIH1cbiAgYXN5bmMgdmFsaWRhdGVTaWduaW5SZXNwb25zZShyZXNwb25zZSwgc3RhdGUsIGV4dHJhSGVhZGVycykge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwidmFsaWRhdGVTaWduaW5SZXNwb25zZVwiKTtcbiAgICB0aGlzLl9wcm9jZXNzU2lnbmluU3RhdGUocmVzcG9uc2UsIHN0YXRlKTtcbiAgICBsb2dnZXIyLmRlYnVnKFwic3RhdGUgcHJvY2Vzc2VkXCIpO1xuICAgIGF3YWl0IHRoaXMuX3Byb2Nlc3NDb2RlKHJlc3BvbnNlLCBzdGF0ZSwgZXh0cmFIZWFkZXJzKTtcbiAgICBsb2dnZXIyLmRlYnVnKFwiY29kZSBwcm9jZXNzZWRcIik7XG4gICAgaWYgKHJlc3BvbnNlLmlzT3BlbklkKSB7XG4gICAgICB0aGlzLl92YWxpZGF0ZUlkVG9rZW5BdHRyaWJ1dGVzKHJlc3BvbnNlKTtcbiAgICB9XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcInRva2VucyB2YWxpZGF0ZWRcIik7XG4gICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0NsYWltcyhyZXNwb25zZSwgc3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLnNraXBVc2VySW5mbywgcmVzcG9uc2UuaXNPcGVuSWQpO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJjbGFpbXMgcHJvY2Vzc2VkXCIpO1xuICB9XG4gIGFzeW5jIHZhbGlkYXRlQ3JlZGVudGlhbHNSZXNwb25zZShyZXNwb25zZSwgc2tpcFVzZXJJbmZvKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJ2YWxpZGF0ZUNyZWRlbnRpYWxzUmVzcG9uc2VcIik7XG4gICAgY29uc3Qgc2hvdWxkVmFsaWRhdGVTdWJDbGFpbSA9IHJlc3BvbnNlLmlzT3BlbklkICYmICEhcmVzcG9uc2UuaWRfdG9rZW47XG4gICAgaWYgKHNob3VsZFZhbGlkYXRlU3ViQ2xhaW0pIHtcbiAgICAgIHRoaXMuX3ZhbGlkYXRlSWRUb2tlbkF0dHJpYnV0ZXMocmVzcG9uc2UpO1xuICAgIH1cbiAgICBsb2dnZXIyLmRlYnVnKFwidG9rZW5zIHZhbGlkYXRlZFwiKTtcbiAgICBhd2FpdCB0aGlzLl9wcm9jZXNzQ2xhaW1zKHJlc3BvbnNlLCBza2lwVXNlckluZm8sIHNob3VsZFZhbGlkYXRlU3ViQ2xhaW0pO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJjbGFpbXMgcHJvY2Vzc2VkXCIpO1xuICB9XG4gIGFzeW5jIHZhbGlkYXRlUmVmcmVzaFJlc3BvbnNlKHJlc3BvbnNlLCBzdGF0ZSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJ2YWxpZGF0ZVJlZnJlc2hSZXNwb25zZVwiKTtcbiAgICByZXNwb25zZS51c2VyU3RhdGUgPSBzdGF0ZS5kYXRhO1xuICAgIChfYSA9IHJlc3BvbnNlLnNlc3Npb25fc3RhdGUpICE9IG51bGwgPyBfYSA6IHJlc3BvbnNlLnNlc3Npb25fc3RhdGUgPSBzdGF0ZS5zZXNzaW9uX3N0YXRlO1xuICAgIChfYiA9IHJlc3BvbnNlLnNjb3BlKSAhPSBudWxsID8gX2IgOiByZXNwb25zZS5zY29wZSA9IHN0YXRlLnNjb3BlO1xuICAgIGlmIChyZXNwb25zZS5pc09wZW5JZCAmJiAhIXJlc3BvbnNlLmlkX3Rva2VuKSB7XG4gICAgICB0aGlzLl92YWxpZGF0ZUlkVG9rZW5BdHRyaWJ1dGVzKHJlc3BvbnNlLCBzdGF0ZS5pZF90b2tlbik7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwiSUQgVG9rZW4gdmFsaWRhdGVkXCIpO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLmlkX3Rva2VuKSB7XG4gICAgICByZXNwb25zZS5pZF90b2tlbiA9IHN0YXRlLmlkX3Rva2VuO1xuICAgICAgcmVzcG9uc2UucHJvZmlsZSA9IHN0YXRlLnByb2ZpbGU7XG4gICAgfVxuICAgIGNvbnN0IGhhc0lkVG9rZW4gPSByZXNwb25zZS5pc09wZW5JZCAmJiAhIXJlc3BvbnNlLmlkX3Rva2VuO1xuICAgIGF3YWl0IHRoaXMuX3Byb2Nlc3NDbGFpbXMocmVzcG9uc2UsIGZhbHNlLCBoYXNJZFRva2VuKTtcbiAgICBsb2dnZXIyLmRlYnVnKFwiY2xhaW1zIHByb2Nlc3NlZFwiKTtcbiAgfVxuICB2YWxpZGF0ZVNpZ25vdXRSZXNwb25zZShyZXNwb25zZSwgc3RhdGUpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInZhbGlkYXRlU2lnbm91dFJlc3BvbnNlXCIpO1xuICAgIGlmIChzdGF0ZS5pZCAhPT0gcmVzcG9uc2Uuc3RhdGUpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiU3RhdGUgZG9lcyBub3QgbWF0Y2hcIikpO1xuICAgIH1cbiAgICBsb2dnZXIyLmRlYnVnKFwic3RhdGUgdmFsaWRhdGVkXCIpO1xuICAgIHJlc3BvbnNlLnVzZXJTdGF0ZSA9IHN0YXRlLmRhdGE7XG4gICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICBsb2dnZXIyLndhcm4oXCJSZXNwb25zZSB3YXMgZXJyb3JcIiwgcmVzcG9uc2UuZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH1cbiAgfVxuICBfcHJvY2Vzc1NpZ25pblN0YXRlKHJlc3BvbnNlLCBzdGF0ZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIl9wcm9jZXNzU2lnbmluU3RhdGVcIik7XG4gICAgaWYgKHN0YXRlLmlkICE9PSByZXNwb25zZS5zdGF0ZSkge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJTdGF0ZSBkb2VzIG5vdCBtYXRjaFwiKSk7XG4gICAgfVxuICAgIGlmICghc3RhdGUuY2xpZW50X2lkKSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIk5vIGNsaWVudF9pZCBvbiBzdGF0ZVwiKSk7XG4gICAgfVxuICAgIGlmICghc3RhdGUuYXV0aG9yaXR5KSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIk5vIGF1dGhvcml0eSBvbiBzdGF0ZVwiKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zZXR0aW5ncy5hdXRob3JpdHkgIT09IHN0YXRlLmF1dGhvcml0eSkge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJhdXRob3JpdHkgbWlzbWF0Y2ggb24gc2V0dGluZ3MgdnMuIHNpZ25pbiBzdGF0ZVwiKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zZXR0aW5ncy5jbGllbnRfaWQgJiYgdGhpcy5fc2V0dGluZ3MuY2xpZW50X2lkICE9PSBzdGF0ZS5jbGllbnRfaWQpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiY2xpZW50X2lkIG1pc21hdGNoIG9uIHNldHRpbmdzIHZzLiBzaWduaW4gc3RhdGVcIikpO1xuICAgIH1cbiAgICBsb2dnZXIyLmRlYnVnKFwic3RhdGUgdmFsaWRhdGVkXCIpO1xuICAgIHJlc3BvbnNlLnVzZXJTdGF0ZSA9IHN0YXRlLmRhdGE7XG4gICAgcmVzcG9uc2UudXJsX3N0YXRlID0gc3RhdGUudXJsX3N0YXRlO1xuICAgIChfYSA9IHJlc3BvbnNlLnNjb3BlKSAhPSBudWxsID8gX2EgOiByZXNwb25zZS5zY29wZSA9IHN0YXRlLnNjb3BlO1xuICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgbG9nZ2VyMi53YXJuKFwiUmVzcG9uc2Ugd2FzIGVycm9yXCIsIHJlc3BvbnNlLmVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvclJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmNvZGVfdmVyaWZpZXIgJiYgIXJlc3BvbnNlLmNvZGUpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiRXhwZWN0ZWQgY29kZSBpbiByZXNwb25zZVwiKSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIF9wcm9jZXNzQ2xhaW1zKHJlc3BvbnNlLCBza2lwVXNlckluZm8gPSBmYWxzZSwgdmFsaWRhdGVTdWIgPSB0cnVlKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJfcHJvY2Vzc0NsYWltc1wiKTtcbiAgICByZXNwb25zZS5wcm9maWxlID0gdGhpcy5fY2xhaW1zU2VydmljZS5maWx0ZXJQcm90b2NvbENsYWltcyhyZXNwb25zZS5wcm9maWxlKTtcbiAgICBpZiAoc2tpcFVzZXJJbmZvIHx8ICF0aGlzLl9zZXR0aW5ncy5sb2FkVXNlckluZm8gfHwgIXJlc3BvbnNlLmFjY2Vzc190b2tlbikge1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcIm5vdCBsb2FkaW5nIHVzZXIgaW5mb1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcImxvYWRpbmcgdXNlciBpbmZvXCIpO1xuICAgIGNvbnN0IGNsYWltcyA9IGF3YWl0IHRoaXMuX3VzZXJJbmZvU2VydmljZS5nZXRDbGFpbXMocmVzcG9uc2UuYWNjZXNzX3Rva2VuKTtcbiAgICBsb2dnZXIyLmRlYnVnKFwidXNlciBpbmZvIGNsYWltcyByZWNlaXZlZCBmcm9tIHVzZXIgaW5mbyBlbmRwb2ludFwiKTtcbiAgICBpZiAodmFsaWRhdGVTdWIgJiYgY2xhaW1zLnN1YiAhPT0gcmVzcG9uc2UucHJvZmlsZS5zdWIpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwic3ViamVjdCBmcm9tIFVzZXJJbmZvIHJlc3BvbnNlIGRvZXMgbm90IG1hdGNoIHN1YmplY3QgaW4gSUQgVG9rZW5cIikpO1xuICAgIH1cbiAgICByZXNwb25zZS5wcm9maWxlID0gdGhpcy5fY2xhaW1zU2VydmljZS5tZXJnZUNsYWltcyhyZXNwb25zZS5wcm9maWxlLCB0aGlzLl9jbGFpbXNTZXJ2aWNlLmZpbHRlclByb3RvY29sQ2xhaW1zKGNsYWltcykpO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJ1c2VyIGluZm8gY2xhaW1zIHJlY2VpdmVkLCB1cGRhdGVkIHByb2ZpbGU6XCIsIHJlc3BvbnNlLnByb2ZpbGUpO1xuICB9XG4gIGFzeW5jIF9wcm9jZXNzQ29kZShyZXNwb25zZSwgc3RhdGUsIGV4dHJhSGVhZGVycykge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiX3Byb2Nlc3NDb2RlXCIpO1xuICAgIGlmIChyZXNwb25zZS5jb2RlKSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwiVmFsaWRhdGluZyBjb2RlXCIpO1xuICAgICAgY29uc3QgdG9rZW5SZXNwb25zZSA9IGF3YWl0IHRoaXMuX3Rva2VuQ2xpZW50LmV4Y2hhbmdlQ29kZSh7XG4gICAgICAgIGNsaWVudF9pZDogc3RhdGUuY2xpZW50X2lkLFxuICAgICAgICBjbGllbnRfc2VjcmV0OiBzdGF0ZS5jbGllbnRfc2VjcmV0LFxuICAgICAgICBjb2RlOiByZXNwb25zZS5jb2RlLFxuICAgICAgICByZWRpcmVjdF91cmk6IHN0YXRlLnJlZGlyZWN0X3VyaSxcbiAgICAgICAgY29kZV92ZXJpZmllcjogc3RhdGUuY29kZV92ZXJpZmllcixcbiAgICAgICAgZXh0cmFIZWFkZXJzLFxuICAgICAgICAuLi5zdGF0ZS5leHRyYVRva2VuUGFyYW1zXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5hc3NpZ24ocmVzcG9uc2UsIHRva2VuUmVzcG9uc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwiTm8gY29kZSB0byBwcm9jZXNzXCIpO1xuICAgIH1cbiAgfVxuICBfdmFsaWRhdGVJZFRva2VuQXR0cmlidXRlcyhyZXNwb25zZSwgZXhpc3RpbmdUb2tlbikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIl92YWxpZGF0ZUlkVG9rZW5BdHRyaWJ1dGVzXCIpO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJkZWNvZGluZyBJRCBUb2tlbiBKV1RcIik7XG4gICAgY29uc3QgaW5jb21pbmcgPSBKd3RVdGlscy5kZWNvZGUoKF9hID0gcmVzcG9uc2UuaWRfdG9rZW4pICE9IG51bGwgPyBfYSA6IFwiXCIpO1xuICAgIGlmICghaW5jb21pbmcuc3ViKSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIklEIFRva2VuIGlzIG1pc3NpbmcgYSBzdWJqZWN0IGNsYWltXCIpKTtcbiAgICB9XG4gICAgaWYgKGV4aXN0aW5nVG9rZW4pIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gSnd0VXRpbHMuZGVjb2RlKGV4aXN0aW5nVG9rZW4pO1xuICAgICAgaWYgKGluY29taW5nLnN1YiAhPT0gZXhpc3Rpbmcuc3ViKSB7XG4gICAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwic3ViIGluIGlkX3Rva2VuIGRvZXMgbm90IG1hdGNoIGN1cnJlbnQgc3ViXCIpKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmNvbWluZy5hdXRoX3RpbWUgJiYgaW5jb21pbmcuYXV0aF90aW1lICE9PSBleGlzdGluZy5hdXRoX3RpbWUpIHtcbiAgICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJhdXRoX3RpbWUgaW4gaWRfdG9rZW4gZG9lcyBub3QgbWF0Y2ggb3JpZ2luYWwgYXV0aF90aW1lXCIpKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmNvbWluZy5henAgJiYgaW5jb21pbmcuYXpwICE9PSBleGlzdGluZy5henApIHtcbiAgICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJhenAgaW4gaWRfdG9rZW4gZG9lcyBub3QgbWF0Y2ggb3JpZ2luYWwgYXpwXCIpKTtcbiAgICAgIH1cbiAgICAgIGlmICghaW5jb21pbmcuYXpwICYmIGV4aXN0aW5nLmF6cCkge1xuICAgICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcImF6cCBub3QgaW4gaWRfdG9rZW4sIGJ1dCBwcmVzZW50IGluIG9yaWdpbmFsIGlkX3Rva2VuXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzcG9uc2UucHJvZmlsZSA9IGluY29taW5nO1xuICB9XG59O1xuXG4vLyBzcmMvU3RhdGUudHNcbnZhciBTdGF0ZSA9IGNsYXNzIF9TdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLmlkID0gYXJncy5pZCB8fCBDcnlwdG9VdGlscy5nZW5lcmF0ZVVVSUR2NCgpO1xuICAgIHRoaXMuZGF0YSA9IGFyZ3MuZGF0YTtcbiAgICBpZiAoYXJncy5jcmVhdGVkICYmIGFyZ3MuY3JlYXRlZCA+IDApIHtcbiAgICAgIHRoaXMuY3JlYXRlZCA9IGFyZ3MuY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jcmVhdGVkID0gVGltZXIuZ2V0RXBvY2hUaW1lKCk7XG4gICAgfVxuICAgIHRoaXMucmVxdWVzdF90eXBlID0gYXJncy5yZXF1ZXN0X3R5cGU7XG4gICAgdGhpcy51cmxfc3RhdGUgPSBhcmdzLnVybF9zdGF0ZTtcbiAgfVxuICB0b1N0b3JhZ2VTdHJpbmcoKSB7XG4gICAgbmV3IExvZ2dlcihcIlN0YXRlXCIpLmNyZWF0ZShcInRvU3RvcmFnZVN0cmluZ1wiKTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICBjcmVhdGVkOiB0aGlzLmNyZWF0ZWQsXG4gICAgICByZXF1ZXN0X3R5cGU6IHRoaXMucmVxdWVzdF90eXBlLFxuICAgICAgdXJsX3N0YXRlOiB0aGlzLnVybF9zdGF0ZVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBmcm9tU3RvcmFnZVN0cmluZyhzdG9yYWdlU3RyaW5nKSB7XG4gICAgTG9nZ2VyLmNyZWF0ZVN0YXRpYyhcIlN0YXRlXCIsIFwiZnJvbVN0b3JhZ2VTdHJpbmdcIik7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgX1N0YXRlKEpTT04ucGFyc2Uoc3RvcmFnZVN0cmluZykpKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgY2xlYXJTdGFsZVN0YXRlKHN0b3JhZ2UsIGFnZSkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSBMb2dnZXIuY3JlYXRlU3RhdGljKFwiU3RhdGVcIiwgXCJjbGVhclN0YWxlU3RhdGVcIik7XG4gICAgY29uc3QgY3V0b2ZmID0gVGltZXIuZ2V0RXBvY2hUaW1lKCkgLSBhZ2U7XG4gICAgY29uc3Qga2V5cyA9IGF3YWl0IHN0b3JhZ2UuZ2V0QWxsS2V5cygpO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJnb3Qga2V5c1wiLCBrZXlzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBjb25zdCBpdGVtID0gYXdhaXQgc3RvcmFnZS5nZXQoa2V5KTtcbiAgICAgIGxldCByZW1vdmUgPSBmYWxzZTtcbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBhd2FpdCBfU3RhdGUuZnJvbVN0b3JhZ2VTdHJpbmcoaXRlbSk7XG4gICAgICAgICAgbG9nZ2VyMi5kZWJ1ZyhcImdvdCBpdGVtIGZyb20ga2V5OlwiLCBrZXksIHN0YXRlLmNyZWF0ZWQpO1xuICAgICAgICAgIGlmIChzdGF0ZS5jcmVhdGVkIDw9IGN1dG9mZikge1xuICAgICAgICAgICAgcmVtb3ZlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGxvZ2dlcjIuZXJyb3IoXCJFcnJvciBwYXJzaW5nIHN0YXRlIGZvciBrZXk6XCIsIGtleSwgZXJyKTtcbiAgICAgICAgICByZW1vdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIyLmRlYnVnKFwibm8gaXRlbSBpbiBzdG9yYWdlIGZvciBrZXk6XCIsIGtleSk7XG4gICAgICAgIHJlbW92ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgIGxvZ2dlcjIuZGVidWcoXCJyZW1vdmVkIGl0ZW0gZm9yIGtleTpcIiwga2V5KTtcbiAgICAgICAgdm9pZCBzdG9yYWdlLnJlbW92ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL1NpZ25pblN0YXRlLnRzXG52YXIgU2lnbmluU3RhdGUgPSBjbGFzcyBfU2lnbmluU3RhdGUgZXh0ZW5kcyBTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICBzdXBlcihhcmdzKTtcbiAgICB0aGlzLmNvZGVfdmVyaWZpZXIgPSBhcmdzLmNvZGVfdmVyaWZpZXI7XG4gICAgdGhpcy5jb2RlX2NoYWxsZW5nZSA9IGFyZ3MuY29kZV9jaGFsbGVuZ2U7XG4gICAgdGhpcy5hdXRob3JpdHkgPSBhcmdzLmF1dGhvcml0eTtcbiAgICB0aGlzLmNsaWVudF9pZCA9IGFyZ3MuY2xpZW50X2lkO1xuICAgIHRoaXMucmVkaXJlY3RfdXJpID0gYXJncy5yZWRpcmVjdF91cmk7XG4gICAgdGhpcy5zY29wZSA9IGFyZ3Muc2NvcGU7XG4gICAgdGhpcy5jbGllbnRfc2VjcmV0ID0gYXJncy5jbGllbnRfc2VjcmV0O1xuICAgIHRoaXMuZXh0cmFUb2tlblBhcmFtcyA9IGFyZ3MuZXh0cmFUb2tlblBhcmFtcztcbiAgICB0aGlzLnJlc3BvbnNlX21vZGUgPSBhcmdzLnJlc3BvbnNlX21vZGU7XG4gICAgdGhpcy5za2lwVXNlckluZm8gPSBhcmdzLnNraXBVc2VySW5mbztcbiAgfVxuICBzdGF0aWMgYXN5bmMgY3JlYXRlKGFyZ3MpIHtcbiAgICBjb25zdCBjb2RlX3ZlcmlmaWVyID0gYXJncy5jb2RlX3ZlcmlmaWVyID09PSB0cnVlID8gQ3J5cHRvVXRpbHMuZ2VuZXJhdGVDb2RlVmVyaWZpZXIoKSA6IGFyZ3MuY29kZV92ZXJpZmllciB8fCB2b2lkIDA7XG4gICAgY29uc3QgY29kZV9jaGFsbGVuZ2UgPSBjb2RlX3ZlcmlmaWVyID8gYXdhaXQgQ3J5cHRvVXRpbHMuZ2VuZXJhdGVDb2RlQ2hhbGxlbmdlKGNvZGVfdmVyaWZpZXIpIDogdm9pZCAwO1xuICAgIHJldHVybiBuZXcgX1NpZ25pblN0YXRlKHtcbiAgICAgIC4uLmFyZ3MsXG4gICAgICBjb2RlX3ZlcmlmaWVyLFxuICAgICAgY29kZV9jaGFsbGVuZ2VcbiAgICB9KTtcbiAgfVxuICB0b1N0b3JhZ2VTdHJpbmcoKSB7XG4gICAgbmV3IExvZ2dlcihcIlNpZ25pblN0YXRlXCIpLmNyZWF0ZShcInRvU3RvcmFnZVN0cmluZ1wiKTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICBjcmVhdGVkOiB0aGlzLmNyZWF0ZWQsXG4gICAgICByZXF1ZXN0X3R5cGU6IHRoaXMucmVxdWVzdF90eXBlLFxuICAgICAgdXJsX3N0YXRlOiB0aGlzLnVybF9zdGF0ZSxcbiAgICAgIGNvZGVfdmVyaWZpZXI6IHRoaXMuY29kZV92ZXJpZmllcixcbiAgICAgIGF1dGhvcml0eTogdGhpcy5hdXRob3JpdHksXG4gICAgICBjbGllbnRfaWQ6IHRoaXMuY2xpZW50X2lkLFxuICAgICAgcmVkaXJlY3RfdXJpOiB0aGlzLnJlZGlyZWN0X3VyaSxcbiAgICAgIHNjb3BlOiB0aGlzLnNjb3BlLFxuICAgICAgY2xpZW50X3NlY3JldDogdGhpcy5jbGllbnRfc2VjcmV0LFxuICAgICAgZXh0cmFUb2tlblBhcmFtczogdGhpcy5leHRyYVRva2VuUGFyYW1zLFxuICAgICAgcmVzcG9uc2VfbW9kZTogdGhpcy5yZXNwb25zZV9tb2RlLFxuICAgICAgc2tpcFVzZXJJbmZvOiB0aGlzLnNraXBVc2VySW5mb1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBmcm9tU3RvcmFnZVN0cmluZyhzdG9yYWdlU3RyaW5nKSB7XG4gICAgTG9nZ2VyLmNyZWF0ZVN0YXRpYyhcIlNpZ25pblN0YXRlXCIsIFwiZnJvbVN0b3JhZ2VTdHJpbmdcIik7XG4gICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2Uoc3RvcmFnZVN0cmluZyk7XG4gICAgcmV0dXJuIF9TaWduaW5TdGF0ZS5jcmVhdGUoZGF0YSk7XG4gIH1cbn07XG5cbi8vIHNyYy9TaWduaW5SZXF1ZXN0LnRzXG52YXIgX1NpZ25pblJlcXVlc3QgPSBjbGFzcyBfU2lnbmluUmVxdWVzdCB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLnVybCA9IGFyZ3MudXJsO1xuICAgIHRoaXMuc3RhdGUgPSBhcmdzLnN0YXRlO1xuICB9XG4gIHN0YXRpYyBhc3luYyBjcmVhdGUoe1xuICAgIC8vIG1hbmRhdG9yeVxuICAgIHVybCxcbiAgICBhdXRob3JpdHksXG4gICAgY2xpZW50X2lkLFxuICAgIHJlZGlyZWN0X3VyaSxcbiAgICByZXNwb25zZV90eXBlLFxuICAgIHNjb3BlLFxuICAgIC8vIG9wdGlvbmFsXG4gICAgc3RhdGVfZGF0YSxcbiAgICByZXNwb25zZV9tb2RlLFxuICAgIHJlcXVlc3RfdHlwZSxcbiAgICBjbGllbnRfc2VjcmV0LFxuICAgIG5vbmNlLFxuICAgIHVybF9zdGF0ZSxcbiAgICByZXNvdXJjZSxcbiAgICBza2lwVXNlckluZm8sXG4gICAgZXh0cmFRdWVyeVBhcmFtcyxcbiAgICBleHRyYVRva2VuUGFyYW1zLFxuICAgIGRpc2FibGVQS0NFLFxuICAgIGRwb3BKa3QsXG4gICAgb21pdFNjb3BlV2hlblJlcXVlc3RpbmcsXG4gICAgLi4ub3B0aW9uYWxQYXJhbXNcbiAgfSkge1xuICAgIGlmICghdXJsKSB7XG4gICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoXCJjcmVhdGU6IE5vIHVybCBwYXNzZWRcIik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1cmxcIik7XG4gICAgfVxuICAgIGlmICghY2xpZW50X2lkKSB7XG4gICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoXCJjcmVhdGU6IE5vIGNsaWVudF9pZCBwYXNzZWRcIik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjbGllbnRfaWRcIik7XG4gICAgfVxuICAgIGlmICghcmVkaXJlY3RfdXJpKSB7XG4gICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoXCJjcmVhdGU6IE5vIHJlZGlyZWN0X3VyaSBwYXNzZWRcIik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWRpcmVjdF91cmlcIik7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2VfdHlwZSkge1xuICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKFwiY3JlYXRlOiBObyByZXNwb25zZV90eXBlIHBhc3NlZFwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInJlc3BvbnNlX3R5cGVcIik7XG4gICAgfVxuICAgIGlmICghc2NvcGUpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihcImNyZWF0ZTogTm8gc2NvcGUgcGFzc2VkXCIpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2NvcGVcIik7XG4gICAgfVxuICAgIGlmICghYXV0aG9yaXR5KSB7XG4gICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoXCJjcmVhdGU6IE5vIGF1dGhvcml0eSBwYXNzZWRcIik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdXRob3JpdHlcIik7XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0gYXdhaXQgU2lnbmluU3RhdGUuY3JlYXRlKHtcbiAgICAgIGRhdGE6IHN0YXRlX2RhdGEsXG4gICAgICByZXF1ZXN0X3R5cGUsXG4gICAgICB1cmxfc3RhdGUsXG4gICAgICBjb2RlX3ZlcmlmaWVyOiAhZGlzYWJsZVBLQ0UsXG4gICAgICBjbGllbnRfaWQsXG4gICAgICBhdXRob3JpdHksXG4gICAgICByZWRpcmVjdF91cmksXG4gICAgICByZXNwb25zZV9tb2RlLFxuICAgICAgY2xpZW50X3NlY3JldCxcbiAgICAgIHNjb3BlLFxuICAgICAgZXh0cmFUb2tlblBhcmFtcyxcbiAgICAgIHNraXBVc2VySW5mb1xuICAgIH0pO1xuICAgIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwodXJsKTtcbiAgICBwYXJzZWRVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcImNsaWVudF9pZFwiLCBjbGllbnRfaWQpO1xuICAgIHBhcnNlZFVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwicmVkaXJlY3RfdXJpXCIsIHJlZGlyZWN0X3VyaSk7XG4gICAgcGFyc2VkVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJyZXNwb25zZV90eXBlXCIsIHJlc3BvbnNlX3R5cGUpO1xuICAgIGlmICghb21pdFNjb3BlV2hlblJlcXVlc3RpbmcpIHtcbiAgICAgIHBhcnNlZFVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwic2NvcGVcIiwgc2NvcGUpO1xuICAgIH1cbiAgICBpZiAobm9uY2UpIHtcbiAgICAgIHBhcnNlZFVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwibm9uY2VcIiwgbm9uY2UpO1xuICAgIH1cbiAgICBpZiAoZHBvcEprdCkge1xuICAgICAgcGFyc2VkVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJkcG9wX2prdFwiLCBkcG9wSmt0KTtcbiAgICB9XG4gICAgbGV0IHN0YXRlUGFyYW0gPSBzdGF0ZS5pZDtcbiAgICBpZiAodXJsX3N0YXRlKSB7XG4gICAgICBzdGF0ZVBhcmFtID0gYCR7c3RhdGVQYXJhbX0ke1VSTF9TVEFURV9ERUxJTUlURVJ9JHt1cmxfc3RhdGV9YDtcbiAgICB9XG4gICAgcGFyc2VkVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJzdGF0ZVwiLCBzdGF0ZVBhcmFtKTtcbiAgICBpZiAoc3RhdGUuY29kZV9jaGFsbGVuZ2UpIHtcbiAgICAgIHBhcnNlZFVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwiY29kZV9jaGFsbGVuZ2VcIiwgc3RhdGUuY29kZV9jaGFsbGVuZ2UpO1xuICAgICAgcGFyc2VkVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJjb2RlX2NoYWxsZW5nZV9tZXRob2RcIiwgXCJTMjU2XCIpO1xuICAgIH1cbiAgICBpZiAocmVzb3VyY2UpIHtcbiAgICAgIGNvbnN0IHJlc291cmNlcyA9IEFycmF5LmlzQXJyYXkocmVzb3VyY2UpID8gcmVzb3VyY2UgOiBbcmVzb3VyY2VdO1xuICAgICAgcmVzb3VyY2VzLmZvckVhY2goKHIpID0+IHBhcnNlZFVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwicmVzb3VyY2VcIiwgcikpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh7IHJlc3BvbnNlX21vZGUsIC4uLm9wdGlvbmFsUGFyYW1zLCAuLi5leHRyYVF1ZXJ5UGFyYW1zIH0pKSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBwYXJzZWRVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IF9TaWduaW5SZXF1ZXN0KHtcbiAgICAgIHVybDogcGFyc2VkVXJsLmhyZWYsXG4gICAgICBzdGF0ZVxuICAgIH0pO1xuICB9XG59O1xuX1NpZ25pblJlcXVlc3QuX2xvZ2dlciA9IG5ldyBMb2dnZXIoXCJTaWduaW5SZXF1ZXN0XCIpO1xudmFyIFNpZ25pblJlcXVlc3QgPSBfU2lnbmluUmVxdWVzdDtcblxuLy8gc3JjL1NpZ25pblJlc3BvbnNlLnRzXG52YXIgT2lkY1Njb3BlID0gXCJvcGVuaWRcIjtcbnZhciBTaWduaW5SZXNwb25zZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgLyoqIEBzZWUge0BsaW5rIFVzZXIuYWNjZXNzX3Rva2VufSAqL1xuICAgIHRoaXMuYWNjZXNzX3Rva2VuID0gXCJcIjtcbiAgICAvKiogQHNlZSB7QGxpbmsgVXNlci50b2tlbl90eXBlfSAqL1xuICAgIHRoaXMudG9rZW5fdHlwZSA9IFwiXCI7XG4gICAgLyoqIEBzZWUge0BsaW5rIFVzZXIucHJvZmlsZX0gKi9cbiAgICB0aGlzLnByb2ZpbGUgPSB7fTtcbiAgICB0aGlzLnN0YXRlID0gcGFyYW1zLmdldChcInN0YXRlXCIpO1xuICAgIHRoaXMuc2Vzc2lvbl9zdGF0ZSA9IHBhcmFtcy5nZXQoXCJzZXNzaW9uX3N0YXRlXCIpO1xuICAgIGlmICh0aGlzLnN0YXRlKSB7XG4gICAgICBjb25zdCBzcGxpdFN0YXRlID0gZGVjb2RlVVJJQ29tcG9uZW50KHRoaXMuc3RhdGUpLnNwbGl0KFVSTF9TVEFURV9ERUxJTUlURVIpO1xuICAgICAgdGhpcy5zdGF0ZSA9IHNwbGl0U3RhdGVbMF07XG4gICAgICBpZiAoc3BsaXRTdGF0ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMudXJsX3N0YXRlID0gc3BsaXRTdGF0ZS5zbGljZSgxKS5qb2luKFVSTF9TVEFURV9ERUxJTUlURVIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmVycm9yID0gcGFyYW1zLmdldChcImVycm9yXCIpO1xuICAgIHRoaXMuZXJyb3JfZGVzY3JpcHRpb24gPSBwYXJhbXMuZ2V0KFwiZXJyb3JfZGVzY3JpcHRpb25cIik7XG4gICAgdGhpcy5lcnJvcl91cmkgPSBwYXJhbXMuZ2V0KFwiZXJyb3JfdXJpXCIpO1xuICAgIHRoaXMuY29kZSA9IHBhcmFtcy5nZXQoXCJjb2RlXCIpO1xuICB9XG4gIGdldCBleHBpcmVzX2luKCkge1xuICAgIGlmICh0aGlzLmV4cGlyZXNfYXQgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZXhwaXJlc19hdCAtIFRpbWVyLmdldEVwb2NoVGltZSgpO1xuICB9XG4gIHNldCBleHBpcmVzX2luKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikgdmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwICYmIHZhbHVlID49IDApIHtcbiAgICAgIHRoaXMuZXhwaXJlc19hdCA9IE1hdGguZmxvb3IodmFsdWUpICsgVGltZXIuZ2V0RXBvY2hUaW1lKCk7XG4gICAgfVxuICB9XG4gIGdldCBpc09wZW5JZCgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSB0aGlzLnNjb3BlKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc3BsaXQoXCIgXCIpLmluY2x1ZGVzKE9pZGNTY29wZSkpIHx8ICEhdGhpcy5pZF90b2tlbjtcbiAgfVxufTtcblxuLy8gc3JjL1NpZ25vdXRSZXF1ZXN0LnRzXG52YXIgU2lnbm91dFJlcXVlc3QgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB1cmwsXG4gICAgc3RhdGVfZGF0YSxcbiAgICBpZF90b2tlbl9oaW50LFxuICAgIHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSxcbiAgICBleHRyYVF1ZXJ5UGFyYW1zLFxuICAgIHJlcXVlc3RfdHlwZSxcbiAgICBjbGllbnRfaWQsXG4gICAgdXJsX3N0YXRlXG4gIH0pIHtcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiU2lnbm91dFJlcXVlc3RcIik7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihcImN0b3I6IE5vIHVybCBwYXNzZWRcIik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1cmxcIik7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwodXJsKTtcbiAgICBpZiAoaWRfdG9rZW5faGludCkge1xuICAgICAgcGFyc2VkVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJpZF90b2tlbl9oaW50XCIsIGlkX3Rva2VuX2hpbnQpO1xuICAgIH1cbiAgICBpZiAoY2xpZW50X2lkKSB7XG4gICAgICBwYXJzZWRVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcImNsaWVudF9pZFwiLCBjbGllbnRfaWQpO1xuICAgIH1cbiAgICBpZiAocG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpKSB7XG4gICAgICBwYXJzZWRVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcInBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaVwiLCBwb3N0X2xvZ291dF9yZWRpcmVjdF91cmkpO1xuICAgICAgaWYgKHN0YXRlX2RhdGEgfHwgdXJsX3N0YXRlKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgU3RhdGUoeyBkYXRhOiBzdGF0ZV9kYXRhLCByZXF1ZXN0X3R5cGUsIHVybF9zdGF0ZSB9KTtcbiAgICAgICAgbGV0IHN0YXRlUGFyYW0gPSB0aGlzLnN0YXRlLmlkO1xuICAgICAgICBpZiAodXJsX3N0YXRlKSB7XG4gICAgICAgICAgc3RhdGVQYXJhbSA9IGAke3N0YXRlUGFyYW19JHtVUkxfU1RBVEVfREVMSU1JVEVSfSR7dXJsX3N0YXRlfWA7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VkVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJzdGF0ZVwiLCBzdGF0ZVBhcmFtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoeyAuLi5leHRyYVF1ZXJ5UGFyYW1zIH0pKSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBwYXJzZWRVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnVybCA9IHBhcnNlZFVybC5ocmVmO1xuICB9XG59O1xuXG4vLyBzcmMvU2lnbm91dFJlc3BvbnNlLnRzXG52YXIgU2lnbm91dFJlc3BvbnNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICB0aGlzLnN0YXRlID0gcGFyYW1zLmdldChcInN0YXRlXCIpO1xuICAgIGlmICh0aGlzLnN0YXRlKSB7XG4gICAgICBjb25zdCBzcGxpdFN0YXRlID0gZGVjb2RlVVJJQ29tcG9uZW50KHRoaXMuc3RhdGUpLnNwbGl0KFVSTF9TVEFURV9ERUxJTUlURVIpO1xuICAgICAgdGhpcy5zdGF0ZSA9IHNwbGl0U3RhdGVbMF07XG4gICAgICBpZiAoc3BsaXRTdGF0ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMudXJsX3N0YXRlID0gc3BsaXRTdGF0ZS5zbGljZSgxKS5qb2luKFVSTF9TVEFURV9ERUxJTUlURVIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmVycm9yID0gcGFyYW1zLmdldChcImVycm9yXCIpO1xuICAgIHRoaXMuZXJyb3JfZGVzY3JpcHRpb24gPSBwYXJhbXMuZ2V0KFwiZXJyb3JfZGVzY3JpcHRpb25cIik7XG4gICAgdGhpcy5lcnJvcl91cmkgPSBwYXJhbXMuZ2V0KFwiZXJyb3JfdXJpXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvQ2xhaW1zU2VydmljZS50c1xudmFyIERlZmF1bHRQcm90b2NvbENsYWltcyA9IFtcbiAgXCJuYmZcIixcbiAgXCJqdGlcIixcbiAgXCJhdXRoX3RpbWVcIixcbiAgXCJub25jZVwiLFxuICBcImFjclwiLFxuICBcImFtclwiLFxuICBcImF6cFwiLFxuICBcImF0X2hhc2hcIlxuICAvLyBodHRwczovL29wZW5pZC5uZXQvc3BlY3Mvb3BlbmlkLWNvbm5lY3QtY29yZS0xXzAuaHRtbCNDb2RlSURUb2tlblxuXTtcbnZhciBJbnRlcm5hbFJlcXVpcmVkUHJvdG9jb2xDbGFpbXMgPSBbXCJzdWJcIiwgXCJpc3NcIiwgXCJhdWRcIiwgXCJleHBcIiwgXCJpYXRcIl07XG52YXIgQ2xhaW1zU2VydmljZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoX3NldHRpbmdzKSB7XG4gICAgdGhpcy5fc2V0dGluZ3MgPSBfc2V0dGluZ3M7XG4gICAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIkNsYWltc1NlcnZpY2VcIik7XG4gIH1cbiAgZmlsdGVyUHJvdG9jb2xDbGFpbXMoY2xhaW1zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0geyAuLi5jbGFpbXMgfTtcbiAgICBpZiAodGhpcy5fc2V0dGluZ3MuZmlsdGVyUHJvdG9jb2xDbGFpbXMpIHtcbiAgICAgIGxldCBwcm90b2NvbENsYWltcztcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuX3NldHRpbmdzLmZpbHRlclByb3RvY29sQ2xhaW1zKSkge1xuICAgICAgICBwcm90b2NvbENsYWltcyA9IHRoaXMuX3NldHRpbmdzLmZpbHRlclByb3RvY29sQ2xhaW1zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvdG9jb2xDbGFpbXMgPSBEZWZhdWx0UHJvdG9jb2xDbGFpbXM7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGNsYWltIG9mIHByb3RvY29sQ2xhaW1zKSB7XG4gICAgICAgIGlmICghSW50ZXJuYWxSZXF1aXJlZFByb3RvY29sQ2xhaW1zLmluY2x1ZGVzKGNsYWltKSkge1xuICAgICAgICAgIGRlbGV0ZSByZXN1bHRbY2xhaW1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbWVyZ2VDbGFpbXMoY2xhaW1zMSwgY2xhaW1zMikge1xuICAgIGNvbnN0IHJlc3VsdCA9IHsgLi4uY2xhaW1zMSB9O1xuICAgIGZvciAoY29uc3QgW2NsYWltLCB2YWx1ZXNdIG9mIE9iamVjdC5lbnRyaWVzKGNsYWltczIpKSB7XG4gICAgICBpZiAocmVzdWx0W2NsYWltXSAhPT0gdmFsdWVzKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdFtjbGFpbV0pIHx8IEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5tZXJnZUNsYWltc1N0cmF0ZWd5LmFycmF5ID09IFwicmVwbGFjZVwiKSB7XG4gICAgICAgICAgICByZXN1bHRbY2xhaW1dID0gdmFsdWVzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWRWYWx1ZXMgPSBBcnJheS5pc0FycmF5KHJlc3VsdFtjbGFpbV0pID8gcmVzdWx0W2NsYWltXSA6IFtyZXN1bHRbY2xhaW1dXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgQXJyYXkuaXNBcnJheSh2YWx1ZXMpID8gdmFsdWVzIDogW3ZhbHVlc10pIHtcbiAgICAgICAgICAgICAgaWYgKCFtZXJnZWRWYWx1ZXMuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkVmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbY2xhaW1dID0gbWVyZ2VkVmFsdWVzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVzdWx0W2NsYWltXSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWVzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgcmVzdWx0W2NsYWltXSA9IHRoaXMubWVyZ2VDbGFpbXMocmVzdWx0W2NsYWltXSwgdmFsdWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbY2xhaW1dID0gdmFsdWVzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbi8vIHNyYy9EUG9QU3RvcmUudHNcbnZhciBEUG9QU3RhdGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGtleXMsIG5vbmNlKSB7XG4gICAgdGhpcy5rZXlzID0ga2V5cztcbiAgICB0aGlzLm5vbmNlID0gbm9uY2U7XG4gIH1cbn07XG5cbi8vIHNyYy9PaWRjQ2xpZW50LnRzXG52YXIgT2lkY0NsaWVudCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MsIG1ldGFkYXRhU2VydmljZSkge1xuICAgIHRoaXMuX2xvZ2dlciA9IG5ldyBMb2dnZXIoXCJPaWRjQ2xpZW50XCIpO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncyBpbnN0YW5jZW9mIE9pZGNDbGllbnRTZXR0aW5nc1N0b3JlID8gc2V0dGluZ3MgOiBuZXcgT2lkY0NsaWVudFNldHRpbmdzU3RvcmUoc2V0dGluZ3MpO1xuICAgIHRoaXMubWV0YWRhdGFTZXJ2aWNlID0gbWV0YWRhdGFTZXJ2aWNlICE9IG51bGwgPyBtZXRhZGF0YVNlcnZpY2UgOiBuZXcgTWV0YWRhdGFTZXJ2aWNlKHRoaXMuc2V0dGluZ3MpO1xuICAgIHRoaXMuX2NsYWltc1NlcnZpY2UgPSBuZXcgQ2xhaW1zU2VydmljZSh0aGlzLnNldHRpbmdzKTtcbiAgICB0aGlzLl92YWxpZGF0b3IgPSBuZXcgUmVzcG9uc2VWYWxpZGF0b3IodGhpcy5zZXR0aW5ncywgdGhpcy5tZXRhZGF0YVNlcnZpY2UsIHRoaXMuX2NsYWltc1NlcnZpY2UpO1xuICAgIHRoaXMuX3Rva2VuQ2xpZW50ID0gbmV3IFRva2VuQ2xpZW50KHRoaXMuc2V0dGluZ3MsIHRoaXMubWV0YWRhdGFTZXJ2aWNlKTtcbiAgfVxuICBhc3luYyBjcmVhdGVTaWduaW5SZXF1ZXN0KHtcbiAgICBzdGF0ZSxcbiAgICByZXF1ZXN0LFxuICAgIHJlcXVlc3RfdXJpLFxuICAgIHJlcXVlc3RfdHlwZSxcbiAgICBpZF90b2tlbl9oaW50LFxuICAgIGxvZ2luX2hpbnQsXG4gICAgc2tpcFVzZXJJbmZvLFxuICAgIG5vbmNlLFxuICAgIHVybF9zdGF0ZSxcbiAgICByZXNwb25zZV90eXBlID0gdGhpcy5zZXR0aW5ncy5yZXNwb25zZV90eXBlLFxuICAgIHNjb3BlID0gdGhpcy5zZXR0aW5ncy5zY29wZSxcbiAgICByZWRpcmVjdF91cmkgPSB0aGlzLnNldHRpbmdzLnJlZGlyZWN0X3VyaSxcbiAgICBwcm9tcHQgPSB0aGlzLnNldHRpbmdzLnByb21wdCxcbiAgICBkaXNwbGF5ID0gdGhpcy5zZXR0aW5ncy5kaXNwbGF5LFxuICAgIG1heF9hZ2UgPSB0aGlzLnNldHRpbmdzLm1heF9hZ2UsXG4gICAgdWlfbG9jYWxlcyA9IHRoaXMuc2V0dGluZ3MudWlfbG9jYWxlcyxcbiAgICBhY3JfdmFsdWVzID0gdGhpcy5zZXR0aW5ncy5hY3JfdmFsdWVzLFxuICAgIHJlc291cmNlID0gdGhpcy5zZXR0aW5ncy5yZXNvdXJjZSxcbiAgICByZXNwb25zZV9tb2RlID0gdGhpcy5zZXR0aW5ncy5yZXNwb25zZV9tb2RlLFxuICAgIGV4dHJhUXVlcnlQYXJhbXMgPSB0aGlzLnNldHRpbmdzLmV4dHJhUXVlcnlQYXJhbXMsXG4gICAgZXh0cmFUb2tlblBhcmFtcyA9IHRoaXMuc2V0dGluZ3MuZXh0cmFUb2tlblBhcmFtcyxcbiAgICBkcG9wSmt0LFxuICAgIG9taXRTY29wZVdoZW5SZXF1ZXN0aW5nID0gdGhpcy5zZXR0aW5ncy5vbWl0U2NvcGVXaGVuUmVxdWVzdGluZ1xuICB9KSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJjcmVhdGVTaWduaW5SZXF1ZXN0XCIpO1xuICAgIGlmIChyZXNwb25zZV90eXBlICE9PSBcImNvZGVcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSB0aGUgQXV0aG9yaXphdGlvbiBDb2RlIGZsb3cgKHdpdGggUEtDRSkgaXMgc3VwcG9ydGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLm1ldGFkYXRhU2VydmljZS5nZXRBdXRob3JpemF0aW9uRW5kcG9pbnQoKTtcbiAgICBsb2dnZXIyLmRlYnVnKFwiUmVjZWl2ZWQgYXV0aG9yaXphdGlvbiBlbmRwb2ludFwiLCB1cmwpO1xuICAgIGNvbnN0IHNpZ25pblJlcXVlc3QgPSBhd2FpdCBTaWduaW5SZXF1ZXN0LmNyZWF0ZSh7XG4gICAgICB1cmwsXG4gICAgICBhdXRob3JpdHk6IHRoaXMuc2V0dGluZ3MuYXV0aG9yaXR5LFxuICAgICAgY2xpZW50X2lkOiB0aGlzLnNldHRpbmdzLmNsaWVudF9pZCxcbiAgICAgIHJlZGlyZWN0X3VyaSxcbiAgICAgIHJlc3BvbnNlX3R5cGUsXG4gICAgICBzY29wZSxcbiAgICAgIHN0YXRlX2RhdGE6IHN0YXRlLFxuICAgICAgdXJsX3N0YXRlLFxuICAgICAgcHJvbXB0LFxuICAgICAgZGlzcGxheSxcbiAgICAgIG1heF9hZ2UsXG4gICAgICB1aV9sb2NhbGVzLFxuICAgICAgaWRfdG9rZW5faGludCxcbiAgICAgIGxvZ2luX2hpbnQsXG4gICAgICBhY3JfdmFsdWVzLFxuICAgICAgZHBvcEprdCxcbiAgICAgIHJlc291cmNlLFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHJlcXVlc3RfdXJpLFxuICAgICAgZXh0cmFRdWVyeVBhcmFtcyxcbiAgICAgIGV4dHJhVG9rZW5QYXJhbXMsXG4gICAgICByZXF1ZXN0X3R5cGUsXG4gICAgICByZXNwb25zZV9tb2RlLFxuICAgICAgY2xpZW50X3NlY3JldDogdGhpcy5zZXR0aW5ncy5jbGllbnRfc2VjcmV0LFxuICAgICAgc2tpcFVzZXJJbmZvLFxuICAgICAgbm9uY2UsXG4gICAgICBkaXNhYmxlUEtDRTogdGhpcy5zZXR0aW5ncy5kaXNhYmxlUEtDRSxcbiAgICAgIG9taXRTY29wZVdoZW5SZXF1ZXN0aW5nXG4gICAgfSk7XG4gICAgYXdhaXQgdGhpcy5jbGVhclN0YWxlU3RhdGUoKTtcbiAgICBjb25zdCBzaWduaW5TdGF0ZSA9IHNpZ25pblJlcXVlc3Quc3RhdGU7XG4gICAgYXdhaXQgdGhpcy5zZXR0aW5ncy5zdGF0ZVN0b3JlLnNldChzaWduaW5TdGF0ZS5pZCwgc2lnbmluU3RhdGUudG9TdG9yYWdlU3RyaW5nKCkpO1xuICAgIHJldHVybiBzaWduaW5SZXF1ZXN0O1xuICB9XG4gIGFzeW5jIHJlYWRTaWduaW5SZXNwb25zZVN0YXRlKHVybCwgcmVtb3ZlU3RhdGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwicmVhZFNpZ25pblJlc3BvbnNlU3RhdGVcIik7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBuZXcgU2lnbmluUmVzcG9uc2UoVXJsVXRpbHMucmVhZFBhcmFtcyh1cmwsIHRoaXMuc2V0dGluZ3MucmVzcG9uc2VfbW9kZSkpO1xuICAgIGlmICghcmVzcG9uc2Uuc3RhdGUpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiTm8gc3RhdGUgaW4gcmVzcG9uc2VcIikpO1xuICAgICAgdGhyb3cgbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc3RvcmVkU3RhdGVTdHJpbmcgPSBhd2FpdCB0aGlzLnNldHRpbmdzLnN0YXRlU3RvcmVbcmVtb3ZlU3RhdGUgPyBcInJlbW92ZVwiIDogXCJnZXRcIl0ocmVzcG9uc2Uuc3RhdGUpO1xuICAgIGlmICghc3RvcmVkU3RhdGVTdHJpbmcpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiTm8gbWF0Y2hpbmcgc3RhdGUgZm91bmQgaW4gc3RvcmFnZVwiKSk7XG4gICAgICB0aHJvdyBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzdGF0ZSA9IGF3YWl0IFNpZ25pblN0YXRlLmZyb21TdG9yYWdlU3RyaW5nKHN0b3JlZFN0YXRlU3RyaW5nKTtcbiAgICByZXR1cm4geyBzdGF0ZSwgcmVzcG9uc2UgfTtcbiAgfVxuICBhc3luYyBwcm9jZXNzU2lnbmluUmVzcG9uc2UodXJsLCBleHRyYUhlYWRlcnMsIHJlbW92ZVN0YXRlID0gdHJ1ZSkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwicHJvY2Vzc1NpZ25pblJlc3BvbnNlXCIpO1xuICAgIGNvbnN0IHsgc3RhdGUsIHJlc3BvbnNlIH0gPSBhd2FpdCB0aGlzLnJlYWRTaWduaW5SZXNwb25zZVN0YXRlKHVybCwgcmVtb3ZlU3RhdGUpO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJyZWNlaXZlZCBzdGF0ZSBmcm9tIHN0b3JhZ2U7IHZhbGlkYXRpbmcgcmVzcG9uc2VcIik7XG4gICAgaWYgKHRoaXMuc2V0dGluZ3MuZHBvcCAmJiB0aGlzLnNldHRpbmdzLmRwb3Auc3RvcmUpIHtcbiAgICAgIGNvbnN0IGRwb3BQcm9vZiA9IGF3YWl0IHRoaXMuZ2V0RHBvcFByb29mKHRoaXMuc2V0dGluZ3MuZHBvcC5zdG9yZSk7XG4gICAgICBleHRyYUhlYWRlcnMgPSB7IC4uLmV4dHJhSGVhZGVycywgXCJEUG9QXCI6IGRwb3BQcm9vZiB9O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5fdmFsaWRhdG9yLnZhbGlkYXRlU2lnbmluUmVzcG9uc2UocmVzcG9uc2UsIHN0YXRlLCBleHRyYUhlYWRlcnMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yRFBvUE5vbmNlICYmIHRoaXMuc2V0dGluZ3MuZHBvcCkge1xuICAgICAgICBjb25zdCBkcG9wUHJvb2YgPSBhd2FpdCB0aGlzLmdldERwb3BQcm9vZih0aGlzLnNldHRpbmdzLmRwb3Auc3RvcmUsIGVyci5ub25jZSk7XG4gICAgICAgIGV4dHJhSGVhZGVyc1tcIkRQb1BcIl0gPSBkcG9wUHJvb2Y7XG4gICAgICAgIGF3YWl0IHRoaXMuX3ZhbGlkYXRvci52YWxpZGF0ZVNpZ25pblJlc3BvbnNlKHJlc3BvbnNlLCBzdGF0ZSwgZXh0cmFIZWFkZXJzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIGFzeW5jIGdldERwb3BQcm9vZihkcG9wU3RvcmUsIG5vbmNlKSB7XG4gICAgbGV0IGtleVBhaXI7XG4gICAgbGV0IGRwb3BTdGF0ZTtcbiAgICBpZiAoIShhd2FpdCBkcG9wU3RvcmUuZ2V0QWxsS2V5cygpKS5pbmNsdWRlcyh0aGlzLnNldHRpbmdzLmNsaWVudF9pZCkpIHtcbiAgICAgIGtleVBhaXIgPSBhd2FpdCBDcnlwdG9VdGlscy5nZW5lcmF0ZURQb1BLZXlzKCk7XG4gICAgICBkcG9wU3RhdGUgPSBuZXcgRFBvUFN0YXRlKGtleVBhaXIsIG5vbmNlKTtcbiAgICAgIGF3YWl0IGRwb3BTdG9yZS5zZXQodGhpcy5zZXR0aW5ncy5jbGllbnRfaWQsIGRwb3BTdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRwb3BTdGF0ZSA9IGF3YWl0IGRwb3BTdG9yZS5nZXQodGhpcy5zZXR0aW5ncy5jbGllbnRfaWQpO1xuICAgICAgaWYgKGRwb3BTdGF0ZS5ub25jZSAhPT0gbm9uY2UgJiYgbm9uY2UpIHtcbiAgICAgICAgZHBvcFN0YXRlLm5vbmNlID0gbm9uY2U7XG4gICAgICAgIGF3YWl0IGRwb3BTdG9yZS5zZXQodGhpcy5zZXR0aW5ncy5jbGllbnRfaWQsIGRwb3BTdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBDcnlwdG9VdGlscy5nZW5lcmF0ZURQb1BQcm9vZih7XG4gICAgICB1cmw6IGF3YWl0IHRoaXMubWV0YWRhdGFTZXJ2aWNlLmdldFRva2VuRW5kcG9pbnQoZmFsc2UpLFxuICAgICAgaHR0cE1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBrZXlQYWlyOiBkcG9wU3RhdGUua2V5cyxcbiAgICAgIG5vbmNlOiBkcG9wU3RhdGUubm9uY2VcbiAgICB9KTtcbiAgfVxuICBhc3luYyBwcm9jZXNzUmVzb3VyY2VPd25lclBhc3N3b3JkQ3JlZGVudGlhbHMoe1xuICAgIHVzZXJuYW1lLFxuICAgIHBhc3N3b3JkLFxuICAgIHNraXBVc2VySW5mbyA9IGZhbHNlLFxuICAgIGV4dHJhVG9rZW5QYXJhbXMgPSB7fVxuICB9KSB7XG4gICAgY29uc3QgdG9rZW5SZXNwb25zZSA9IGF3YWl0IHRoaXMuX3Rva2VuQ2xpZW50LmV4Y2hhbmdlQ3JlZGVudGlhbHMoeyB1c2VybmFtZSwgcGFzc3dvcmQsIC4uLmV4dHJhVG9rZW5QYXJhbXMgfSk7XG4gICAgY29uc3Qgc2lnbmluUmVzcG9uc2UgPSBuZXcgU2lnbmluUmVzcG9uc2UobmV3IFVSTFNlYXJjaFBhcmFtcygpKTtcbiAgICBPYmplY3QuYXNzaWduKHNpZ25pblJlc3BvbnNlLCB0b2tlblJlc3BvbnNlKTtcbiAgICBhd2FpdCB0aGlzLl92YWxpZGF0b3IudmFsaWRhdGVDcmVkZW50aWFsc1Jlc3BvbnNlKHNpZ25pblJlc3BvbnNlLCBza2lwVXNlckluZm8pO1xuICAgIHJldHVybiBzaWduaW5SZXNwb25zZTtcbiAgfVxuICBhc3luYyB1c2VSZWZyZXNoVG9rZW4oe1xuICAgIHN0YXRlLFxuICAgIHJlZGlyZWN0X3VyaSxcbiAgICByZXNvdXJjZSxcbiAgICB0aW1lb3V0SW5TZWNvbmRzLFxuICAgIGV4dHJhSGVhZGVycyxcbiAgICBleHRyYVRva2VuUGFyYW1zXG4gIH0pIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJ1c2VSZWZyZXNoVG9rZW5cIik7XG4gICAgbGV0IHNjb3BlO1xuICAgIGlmICh0aGlzLnNldHRpbmdzLnJlZnJlc2hUb2tlbkFsbG93ZWRTY29wZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzY29wZSA9IHN0YXRlLnNjb3BlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBhbGxvd2FibGVTY29wZXMgPSB0aGlzLnNldHRpbmdzLnJlZnJlc2hUb2tlbkFsbG93ZWRTY29wZS5zcGxpdChcIiBcIik7XG4gICAgICBjb25zdCBwcm92aWRlZFNjb3BlcyA9ICgoX2EgPSBzdGF0ZS5zY29wZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNwbGl0KFwiIFwiKSkgfHwgW107XG4gICAgICBzY29wZSA9IHByb3ZpZGVkU2NvcGVzLmZpbHRlcigocykgPT4gYWxsb3dhYmxlU2NvcGVzLmluY2x1ZGVzKHMpKS5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2V0dGluZ3MuZHBvcCAmJiB0aGlzLnNldHRpbmdzLmRwb3Auc3RvcmUpIHtcbiAgICAgIGNvbnN0IGRwb3BQcm9vZiA9IGF3YWl0IHRoaXMuZ2V0RHBvcFByb29mKHRoaXMuc2V0dGluZ3MuZHBvcC5zdG9yZSk7XG4gICAgICBleHRyYUhlYWRlcnMgPSB7IC4uLmV4dHJhSGVhZGVycywgXCJEUG9QXCI6IGRwb3BQcm9vZiB9O1xuICAgIH1cbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLl90b2tlbkNsaWVudC5leGNoYW5nZVJlZnJlc2hUb2tlbih7XG4gICAgICAgIHJlZnJlc2hfdG9rZW46IHN0YXRlLnJlZnJlc2hfdG9rZW4sXG4gICAgICAgIC8vIHByb3ZpZGUgdGhlIChwb3NzaWJsZSBmaWx0ZXJlZCkgc2NvcGUgbGlzdFxuICAgICAgICBzY29wZSxcbiAgICAgICAgcmVkaXJlY3RfdXJpLFxuICAgICAgICByZXNvdXJjZSxcbiAgICAgICAgdGltZW91dEluU2Vjb25kcyxcbiAgICAgICAgZXh0cmFIZWFkZXJzLFxuICAgICAgICAuLi5leHRyYVRva2VuUGFyYW1zXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvckRQb1BOb25jZSAmJiB0aGlzLnNldHRpbmdzLmRwb3ApIHtcbiAgICAgICAgZXh0cmFIZWFkZXJzW1wiRFBvUFwiXSA9IGF3YWl0IHRoaXMuZ2V0RHBvcFByb29mKHRoaXMuc2V0dGluZ3MuZHBvcC5zdG9yZSwgZXJyLm5vbmNlKTtcbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5fdG9rZW5DbGllbnQuZXhjaGFuZ2VSZWZyZXNoVG9rZW4oe1xuICAgICAgICAgIHJlZnJlc2hfdG9rZW46IHN0YXRlLnJlZnJlc2hfdG9rZW4sXG4gICAgICAgICAgLy8gcHJvdmlkZSB0aGUgKHBvc3NpYmxlIGZpbHRlcmVkKSBzY29wZSBsaXN0XG4gICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgcmVkaXJlY3RfdXJpLFxuICAgICAgICAgIHJlc291cmNlLFxuICAgICAgICAgIHRpbWVvdXRJblNlY29uZHMsXG4gICAgICAgICAgZXh0cmFIZWFkZXJzLFxuICAgICAgICAgIC4uLmV4dHJhVG9rZW5QYXJhbXNcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gbmV3IFNpZ25pblJlc3BvbnNlKG5ldyBVUkxTZWFyY2hQYXJhbXMoKSk7XG4gICAgT2JqZWN0LmFzc2lnbihyZXNwb25zZSwgcmVzdWx0KTtcbiAgICBsb2dnZXIyLmRlYnVnKFwidmFsaWRhdGluZyByZXNwb25zZVwiLCByZXNwb25zZSk7XG4gICAgYXdhaXQgdGhpcy5fdmFsaWRhdG9yLnZhbGlkYXRlUmVmcmVzaFJlc3BvbnNlKHJlc3BvbnNlLCB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIC8vIG92ZXJyaWRlIHRoZSBzY29wZSBpbiB0aGUgc3RhdGUgaGFuZGVkIG92ZXIgdG8gdGhlIHZhbGlkYXRvclxuICAgICAgLy8gc28gaXQgY2FuIHNldCB0aGUgZ3JhbnRlZCBzY29wZSB0byB0aGUgcmVxdWVzdGVkIHNjb3BlIGluIGNhc2Ugbm9uZSBpcyBpbmNsdWRlZCBpbiB0aGUgcmVzcG9uc2VcbiAgICAgIHNjb3BlXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIGFzeW5jIGNyZWF0ZVNpZ25vdXRSZXF1ZXN0KHtcbiAgICBzdGF0ZSxcbiAgICBpZF90b2tlbl9oaW50LFxuICAgIGNsaWVudF9pZCxcbiAgICByZXF1ZXN0X3R5cGUsXG4gICAgdXJsX3N0YXRlLFxuICAgIHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSA9IHRoaXMuc2V0dGluZ3MucG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpLFxuICAgIGV4dHJhUXVlcnlQYXJhbXMgPSB0aGlzLnNldHRpbmdzLmV4dHJhUXVlcnlQYXJhbXNcbiAgfSA9IHt9KSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJjcmVhdGVTaWdub3V0UmVxdWVzdFwiKTtcbiAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLm1ldGFkYXRhU2VydmljZS5nZXRFbmRTZXNzaW9uRW5kcG9pbnQoKTtcbiAgICBpZiAoIXVybCkge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJObyBlbmQgc2Vzc2lvbiBlbmRwb2ludFwiKSk7XG4gICAgICB0aHJvdyBudWxsO1xuICAgIH1cbiAgICBsb2dnZXIyLmRlYnVnKFwiUmVjZWl2ZWQgZW5kIHNlc3Npb24gZW5kcG9pbnRcIiwgdXJsKTtcbiAgICBpZiAoIWNsaWVudF9pZCAmJiBwb3N0X2xvZ291dF9yZWRpcmVjdF91cmkgJiYgIWlkX3Rva2VuX2hpbnQpIHtcbiAgICAgIGNsaWVudF9pZCA9IHRoaXMuc2V0dGluZ3MuY2xpZW50X2lkO1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFNpZ25vdXRSZXF1ZXN0KHtcbiAgICAgIHVybCxcbiAgICAgIGlkX3Rva2VuX2hpbnQsXG4gICAgICBjbGllbnRfaWQsXG4gICAgICBwb3N0X2xvZ291dF9yZWRpcmVjdF91cmksXG4gICAgICBzdGF0ZV9kYXRhOiBzdGF0ZSxcbiAgICAgIGV4dHJhUXVlcnlQYXJhbXMsXG4gICAgICByZXF1ZXN0X3R5cGUsXG4gICAgICB1cmxfc3RhdGVcbiAgICB9KTtcbiAgICBhd2FpdCB0aGlzLmNsZWFyU3RhbGVTdGF0ZSgpO1xuICAgIGNvbnN0IHNpZ25vdXRTdGF0ZSA9IHJlcXVlc3Quc3RhdGU7XG4gICAgaWYgKHNpZ25vdXRTdGF0ZSkge1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcIlNpZ25vdXQgcmVxdWVzdCBoYXMgc3RhdGUgdG8gcGVyc2lzdFwiKTtcbiAgICAgIGF3YWl0IHRoaXMuc2V0dGluZ3Muc3RhdGVTdG9yZS5zZXQoc2lnbm91dFN0YXRlLmlkLCBzaWdub3V0U3RhdGUudG9TdG9yYWdlU3RyaW5nKCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfVxuICBhc3luYyByZWFkU2lnbm91dFJlc3BvbnNlU3RhdGUodXJsLCByZW1vdmVTdGF0ZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJyZWFkU2lnbm91dFJlc3BvbnNlU3RhdGVcIik7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBuZXcgU2lnbm91dFJlc3BvbnNlKFVybFV0aWxzLnJlYWRQYXJhbXModXJsLCB0aGlzLnNldHRpbmdzLnJlc3BvbnNlX21vZGUpKTtcbiAgICBpZiAoIXJlc3BvbnNlLnN0YXRlKSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwiTm8gc3RhdGUgaW4gcmVzcG9uc2VcIik7XG4gICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyMi53YXJuKFwiUmVzcG9uc2Ugd2FzIGVycm9yOlwiLCByZXNwb25zZS5lcnJvcik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvclJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHN0YXRlOiB2b2lkIDAsIHJlc3BvbnNlIH07XG4gICAgfVxuICAgIGNvbnN0IHN0b3JlZFN0YXRlU3RyaW5nID0gYXdhaXQgdGhpcy5zZXR0aW5ncy5zdGF0ZVN0b3JlW3JlbW92ZVN0YXRlID8gXCJyZW1vdmVcIiA6IFwiZ2V0XCJdKHJlc3BvbnNlLnN0YXRlKTtcbiAgICBpZiAoIXN0b3JlZFN0YXRlU3RyaW5nKSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIk5vIG1hdGNoaW5nIHN0YXRlIGZvdW5kIGluIHN0b3JhZ2VcIikpO1xuICAgICAgdGhyb3cgbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc3RhdGUgPSBhd2FpdCBTdGF0ZS5mcm9tU3RvcmFnZVN0cmluZyhzdG9yZWRTdGF0ZVN0cmluZyk7XG4gICAgcmV0dXJuIHsgc3RhdGUsIHJlc3BvbnNlIH07XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc1NpZ25vdXRSZXNwb25zZSh1cmwpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInByb2Nlc3NTaWdub3V0UmVzcG9uc2VcIik7XG4gICAgY29uc3QgeyBzdGF0ZSwgcmVzcG9uc2UgfSA9IGF3YWl0IHRoaXMucmVhZFNpZ25vdXRSZXNwb25zZVN0YXRlKHVybCwgdHJ1ZSk7XG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwiUmVjZWl2ZWQgc3RhdGUgZnJvbSBzdG9yYWdlOyB2YWxpZGF0aW5nIHJlc3BvbnNlXCIpO1xuICAgICAgdGhpcy5fdmFsaWRhdG9yLnZhbGlkYXRlU2lnbm91dFJlc3BvbnNlKHJlc3BvbnNlLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJObyBzdGF0ZSBmcm9tIHN0b3JhZ2U7IHNraXBwaW5nIHJlc3BvbnNlIHZhbGlkYXRpb25cIik7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICBjbGVhclN0YWxlU3RhdGUoKSB7XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShcImNsZWFyU3RhbGVTdGF0ZVwiKTtcbiAgICByZXR1cm4gU3RhdGUuY2xlYXJTdGFsZVN0YXRlKHRoaXMuc2V0dGluZ3Muc3RhdGVTdG9yZSwgdGhpcy5zZXR0aW5ncy5zdGFsZVN0YXRlQWdlSW5TZWNvbmRzKTtcbiAgfVxuICBhc3luYyByZXZva2VUb2tlbih0b2tlbiwgdHlwZSkge1xuICAgIHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJyZXZva2VUb2tlblwiKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fdG9rZW5DbGllbnQucmV2b2tlKHtcbiAgICAgIHRva2VuLFxuICAgICAgdG9rZW5fdHlwZV9oaW50OiB0eXBlXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9TZXNzaW9uTW9uaXRvci50c1xudmFyIFNlc3Npb25Nb25pdG9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihfdXNlck1hbmFnZXIpIHtcbiAgICB0aGlzLl91c2VyTWFuYWdlciA9IF91c2VyTWFuYWdlcjtcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiU2Vzc2lvbk1vbml0b3JcIik7XG4gICAgdGhpcy5fc3RhcnQgPSBhc3luYyAodXNlcikgPT4ge1xuICAgICAgY29uc3Qgc2Vzc2lvbl9zdGF0ZSA9IHVzZXIuc2Vzc2lvbl9zdGF0ZTtcbiAgICAgIGlmICghc2Vzc2lvbl9zdGF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIl9zdGFydFwiKTtcbiAgICAgIGlmICh1c2VyLnByb2ZpbGUpIHtcbiAgICAgICAgdGhpcy5fc3ViID0gdXNlci5wcm9maWxlLnN1YjtcbiAgICAgICAgbG9nZ2VyMi5kZWJ1ZyhcInNlc3Npb25fc3RhdGVcIiwgc2Vzc2lvbl9zdGF0ZSwgXCIsIHN1YlwiLCB0aGlzLl9zdWIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc3ViID0gdm9pZCAwO1xuICAgICAgICBsb2dnZXIyLmRlYnVnKFwic2Vzc2lvbl9zdGF0ZVwiLCBzZXNzaW9uX3N0YXRlLCBcIiwgYW5vbnltb3VzIHVzZXJcIik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fY2hlY2tTZXNzaW9uSUZyYW1lKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrU2Vzc2lvbklGcmFtZS5zdGFydChzZXNzaW9uX3N0YXRlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdXJsID0gYXdhaXQgdGhpcy5fdXNlck1hbmFnZXIubWV0YWRhdGFTZXJ2aWNlLmdldENoZWNrU2Vzc2lvbklmcmFtZSgpO1xuICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgbG9nZ2VyMi5kZWJ1ZyhcImluaXRpYWxpemluZyBjaGVjayBzZXNzaW9uIGlmcmFtZVwiKTtcbiAgICAgICAgICBjb25zdCBjbGllbnRfaWQgPSB0aGlzLl91c2VyTWFuYWdlci5zZXR0aW5ncy5jbGllbnRfaWQ7XG4gICAgICAgICAgY29uc3QgaW50ZXJ2YWxJblNlY29uZHMgPSB0aGlzLl91c2VyTWFuYWdlci5zZXR0aW5ncy5jaGVja1Nlc3Npb25JbnRlcnZhbEluU2Vjb25kcztcbiAgICAgICAgICBjb25zdCBzdG9wT25FcnJvciA9IHRoaXMuX3VzZXJNYW5hZ2VyLnNldHRpbmdzLnN0b3BDaGVja1Nlc3Npb25PbkVycm9yO1xuICAgICAgICAgIGNvbnN0IGNoZWNrU2Vzc2lvbklGcmFtZSA9IG5ldyBDaGVja1Nlc3Npb25JRnJhbWUodGhpcy5fY2FsbGJhY2ssIGNsaWVudF9pZCwgdXJsLCBpbnRlcnZhbEluU2Vjb25kcywgc3RvcE9uRXJyb3IpO1xuICAgICAgICAgIGF3YWl0IGNoZWNrU2Vzc2lvbklGcmFtZS5sb2FkKCk7XG4gICAgICAgICAgdGhpcy5fY2hlY2tTZXNzaW9uSUZyYW1lID0gY2hlY2tTZXNzaW9uSUZyYW1lO1xuICAgICAgICAgIGNoZWNrU2Vzc2lvbklGcmFtZS5zdGFydChzZXNzaW9uX3N0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIyLndhcm4oXCJubyBjaGVjayBzZXNzaW9uIGlmcmFtZSBmb3VuZCBpbiB0aGUgbWV0YWRhdGFcIik7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dnZXIyLmVycm9yKFwiRXJyb3IgZnJvbSBnZXRDaGVja1Nlc3Npb25JZnJhbWU6XCIsIGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBlcnIpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fc3RvcCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiX3N0b3BcIik7XG4gICAgICB0aGlzLl9zdWIgPSB2b2lkIDA7XG4gICAgICBpZiAodGhpcy5fY2hlY2tTZXNzaW9uSUZyYW1lKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrU2Vzc2lvbklGcmFtZS5zdG9wKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fdXNlck1hbmFnZXIuc2V0dGluZ3MubW9uaXRvckFub255bW91c1Nlc3Npb24pIHtcbiAgICAgICAgY29uc3QgdGltZXJIYW5kbGUgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lckhhbmRsZSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCB0aGlzLl91c2VyTWFuYWdlci5xdWVyeVNlc3Npb25TdGF0dXMoKTtcbiAgICAgICAgICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRtcFVzZXIgPSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbl9zdGF0ZTogc2Vzc2lvbi5zZXNzaW9uX3N0YXRlLFxuICAgICAgICAgICAgICAgIHByb2ZpbGU6IHNlc3Npb24uc3ViID8ge1xuICAgICAgICAgICAgICAgICAgc3ViOiBzZXNzaW9uLnN1YlxuICAgICAgICAgICAgICAgIH0gOiBudWxsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHZvaWQgdGhpcy5fc3RhcnQodG1wVXNlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBsb2dnZXIyLmVycm9yKFwiZXJyb3IgZnJvbSBxdWVyeVNlc3Npb25TdGF0dXNcIiwgZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAxZTMpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fY2FsbGJhY2sgPSBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIl9jYWxsYmFja1wiKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCB0aGlzLl91c2VyTWFuYWdlci5xdWVyeVNlc3Npb25TdGF0dXMoKTtcbiAgICAgICAgbGV0IHJhaXNlRXZlbnQgPSB0cnVlO1xuICAgICAgICBpZiAoc2Vzc2lvbiAmJiB0aGlzLl9jaGVja1Nlc3Npb25JRnJhbWUpIHtcbiAgICAgICAgICBpZiAoc2Vzc2lvbi5zdWIgPT09IHRoaXMuX3N1Yikge1xuICAgICAgICAgICAgcmFpc2VFdmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tTZXNzaW9uSUZyYW1lLnN0YXJ0KHNlc3Npb24uc2Vzc2lvbl9zdGF0ZSk7XG4gICAgICAgICAgICBsb2dnZXIyLmRlYnVnKFwic2FtZSBzdWIgc3RpbGwgbG9nZ2VkIGluIGF0IE9QLCBzZXNzaW9uIHN0YXRlIGhhcyBjaGFuZ2VkLCByZXN0YXJ0aW5nIGNoZWNrIHNlc3Npb24gaWZyYW1lOyBzZXNzaW9uX3N0YXRlXCIsIHNlc3Npb24uc2Vzc2lvbl9zdGF0ZSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl91c2VyTWFuYWdlci5ldmVudHMuX3JhaXNlVXNlclNlc3Npb25DaGFuZ2VkKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlcjIuZGVidWcoXCJkaWZmZXJlbnQgc3ViamVjdCBzaWduZWQgaW50byBPUFwiLCBzZXNzaW9uLnN1Yik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlcjIuZGVidWcoXCJzdWJqZWN0IG5vIGxvbmdlciBzaWduZWQgaW50byBPUFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmFpc2VFdmVudCkge1xuICAgICAgICAgIGlmICh0aGlzLl9zdWIpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3VzZXJNYW5hZ2VyLmV2ZW50cy5fcmFpc2VVc2VyU2lnbmVkT3V0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3VzZXJNYW5hZ2VyLmV2ZW50cy5fcmFpc2VVc2VyU2lnbmVkSW4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyMi5kZWJ1ZyhcIm5vIGNoYW5nZSBpbiBzZXNzaW9uIGRldGVjdGVkLCBubyBldmVudCB0byByYWlzZVwiKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdWIpIHtcbiAgICAgICAgICBsb2dnZXIyLmRlYnVnKFwiRXJyb3IgY2FsbGluZyBxdWVyeUN1cnJlbnRTaWduaW5TZXNzaW9uOyByYWlzaW5nIHNpZ25lZCBvdXQgZXZlbnRcIiwgZXJyKTtcbiAgICAgICAgICBhd2FpdCB0aGlzLl91c2VyTWFuYWdlci5ldmVudHMuX3JhaXNlVXNlclNpZ25lZE91dCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoIV91c2VyTWFuYWdlcikge1xuICAgICAgdGhpcy5fbG9nZ2VyLnRocm93KG5ldyBFcnJvcihcIk5vIHVzZXIgbWFuYWdlciBwYXNzZWRcIikpO1xuICAgIH1cbiAgICB0aGlzLl91c2VyTWFuYWdlci5ldmVudHMuYWRkVXNlckxvYWRlZCh0aGlzLl9zdGFydCk7XG4gICAgdGhpcy5fdXNlck1hbmFnZXIuZXZlbnRzLmFkZFVzZXJVbmxvYWRlZCh0aGlzLl9zdG9wKTtcbiAgICB0aGlzLl9pbml0KCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGVycik7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgX2luaXQoKSB7XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIl9pbml0XCIpO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLl91c2VyTWFuYWdlci5nZXRVc2VyKCk7XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIHZvaWQgdGhpcy5fc3RhcnQodXNlcik7XG4gICAgfSBlbHNlIGlmICh0aGlzLl91c2VyTWFuYWdlci5zZXR0aW5ncy5tb25pdG9yQW5vbnltb3VzU2Vzc2lvbikge1xuICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IHRoaXMuX3VzZXJNYW5hZ2VyLnF1ZXJ5U2Vzc2lvblN0YXR1cygpO1xuICAgICAgaWYgKHNlc3Npb24pIHtcbiAgICAgICAgY29uc3QgdG1wVXNlciA9IHtcbiAgICAgICAgICBzZXNzaW9uX3N0YXRlOiBzZXNzaW9uLnNlc3Npb25fc3RhdGUsXG4gICAgICAgICAgcHJvZmlsZTogc2Vzc2lvbi5zdWIgPyB7XG4gICAgICAgICAgICBzdWI6IHNlc3Npb24uc3ViXG4gICAgICAgICAgfSA6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgdm9pZCB0aGlzLl9zdGFydCh0bXBVc2VyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9Vc2VyLnRzXG52YXIgVXNlciA9IGNsYXNzIF9Vc2VyIHtcbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHZhciBfYTtcbiAgICB0aGlzLmlkX3Rva2VuID0gYXJncy5pZF90b2tlbjtcbiAgICB0aGlzLnNlc3Npb25fc3RhdGUgPSAoX2EgPSBhcmdzLnNlc3Npb25fc3RhdGUpICE9IG51bGwgPyBfYSA6IG51bGw7XG4gICAgdGhpcy5hY2Nlc3NfdG9rZW4gPSBhcmdzLmFjY2Vzc190b2tlbjtcbiAgICB0aGlzLnJlZnJlc2hfdG9rZW4gPSBhcmdzLnJlZnJlc2hfdG9rZW47XG4gICAgdGhpcy50b2tlbl90eXBlID0gYXJncy50b2tlbl90eXBlO1xuICAgIHRoaXMuc2NvcGUgPSBhcmdzLnNjb3BlO1xuICAgIHRoaXMucHJvZmlsZSA9IGFyZ3MucHJvZmlsZTtcbiAgICB0aGlzLmV4cGlyZXNfYXQgPSBhcmdzLmV4cGlyZXNfYXQ7XG4gICAgdGhpcy5zdGF0ZSA9IGFyZ3MudXNlclN0YXRlO1xuICAgIHRoaXMudXJsX3N0YXRlID0gYXJncy51cmxfc3RhdGU7XG4gIH1cbiAgLyoqIENvbXB1dGVkIG51bWJlciBvZiBzZWNvbmRzIHRoZSBhY2Nlc3MgdG9rZW4gaGFzIHJlbWFpbmluZy4gKi9cbiAgZ2V0IGV4cGlyZXNfaW4oKSB7XG4gICAgaWYgKHRoaXMuZXhwaXJlc19hdCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5leHBpcmVzX2F0IC0gVGltZXIuZ2V0RXBvY2hUaW1lKCk7XG4gIH1cbiAgc2V0IGV4cGlyZXNfaW4odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5leHBpcmVzX2F0ID0gTWF0aC5mbG9vcih2YWx1ZSkgKyBUaW1lci5nZXRFcG9jaFRpbWUoKTtcbiAgICB9XG4gIH1cbiAgLyoqIENvbXB1dGVkIHZhbHVlIGluZGljYXRpbmcgaWYgdGhlIGFjY2VzcyB0b2tlbiBpcyBleHBpcmVkLiAqL1xuICBnZXQgZXhwaXJlZCgpIHtcbiAgICBjb25zdCBleHBpcmVzX2luID0gdGhpcy5leHBpcmVzX2luO1xuICAgIGlmIChleHBpcmVzX2luID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBleHBpcmVzX2luIDw9IDA7XG4gIH1cbiAgLyoqIEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGFyc2VkIHZhbHVlcyBmcm9tIHRoZSBgc2NvcGVgLiAqL1xuICBnZXQgc2NvcGVzKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuc2NvcGUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zcGxpdChcIiBcIikpICE9IG51bGwgPyBfYiA6IFtdO1xuICB9XG4gIHRvU3RvcmFnZVN0cmluZygpIHtcbiAgICBuZXcgTG9nZ2VyKFwiVXNlclwiKS5jcmVhdGUoXCJ0b1N0b3JhZ2VTdHJpbmdcIik7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIGlkX3Rva2VuOiB0aGlzLmlkX3Rva2VuLFxuICAgICAgc2Vzc2lvbl9zdGF0ZTogdGhpcy5zZXNzaW9uX3N0YXRlLFxuICAgICAgYWNjZXNzX3Rva2VuOiB0aGlzLmFjY2Vzc190b2tlbixcbiAgICAgIHJlZnJlc2hfdG9rZW46IHRoaXMucmVmcmVzaF90b2tlbixcbiAgICAgIHRva2VuX3R5cGU6IHRoaXMudG9rZW5fdHlwZSxcbiAgICAgIHNjb3BlOiB0aGlzLnNjb3BlLFxuICAgICAgcHJvZmlsZTogdGhpcy5wcm9maWxlLFxuICAgICAgZXhwaXJlc19hdDogdGhpcy5leHBpcmVzX2F0XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGZyb21TdG9yYWdlU3RyaW5nKHN0b3JhZ2VTdHJpbmcpIHtcbiAgICBMb2dnZXIuY3JlYXRlU3RhdGljKFwiVXNlclwiLCBcImZyb21TdG9yYWdlU3RyaW5nXCIpO1xuICAgIHJldHVybiBuZXcgX1VzZXIoSlNPTi5wYXJzZShzdG9yYWdlU3RyaW5nKSk7XG4gIH1cbn07XG5cbi8vIHNyYy9uYXZpZ2F0b3JzL0Fic3RyYWN0Q2hpbGRXaW5kb3cudHNcbnZhciBtZXNzYWdlU291cmNlID0gXCJvaWRjLWNsaWVudFwiO1xudmFyIEFic3RyYWN0Q2hpbGRXaW5kb3cgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2Fib3J0ID0gbmV3IEV2ZW50KFwiV2luZG93IG5hdmlnYXRpb24gYWJvcnRlZFwiKTtcbiAgICB0aGlzLl9kaXNwb3NlSGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuX3dpbmRvdyA9IG51bGw7XG4gIH1cbiAgYXN5bmMgbmF2aWdhdGUocGFyYW1zKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJuYXZpZ2F0ZVwiKTtcbiAgICBpZiAoIXRoaXMuX3dpbmRvdykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIG5hdmlnYXRlIG9uIGEgZGlzcG9zZWQgd2luZG93XCIpO1xuICAgIH1cbiAgICBsb2dnZXIyLmRlYnVnKFwic2V0dGluZyBVUkwgaW4gd2luZG93XCIpO1xuICAgIHRoaXMuX3dpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHBhcmFtcy51cmwpO1xuICAgIGNvbnN0IHsgdXJsLCBrZWVwT3BlbiB9ID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgbGlzdGVuZXIgPSAoZSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBlLmRhdGE7XG4gICAgICAgIGNvbnN0IG9yaWdpbiA9IChfYSA9IHBhcmFtcy5zY3JpcHRPcmlnaW4pICE9IG51bGwgPyBfYSA6IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XG4gICAgICAgIGlmIChlLm9yaWdpbiAhPT0gb3JpZ2luIHx8IChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLnNvdXJjZSkgIT09IG1lc3NhZ2VTb3VyY2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IFVybFV0aWxzLnJlYWRQYXJhbXMoZGF0YS51cmwsIHBhcmFtcy5yZXNwb25zZV9tb2RlKS5nZXQoXCJzdGF0ZVwiKTtcbiAgICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICBsb2dnZXIyLndhcm4oXCJubyBzdGF0ZSBmb3VuZCBpbiByZXNwb25zZSB1cmxcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlLnNvdXJjZSAhPT0gdGhpcy5fd2luZG93ICYmIHN0YXRlICE9PSBwYXJhbXMuc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHRoaXMuX2Rpc3Bvc2UoKTtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCByZXNwb25zZSBmcm9tIHdpbmRvd1wiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgIH07XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgIHRoaXMuX2Rpc3Bvc2VIYW5kbGVycy5hZGQoKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGxpc3RlbmVyLCBmYWxzZSkpO1xuICAgICAgY29uc3QgY2hhbm5lbCA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKGBvaWRjLWNsaWVudC1wb3B1cC0ke3BhcmFtcy5zdGF0ZX1gKTtcbiAgICAgIGNoYW5uZWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgIHRoaXMuX2Rpc3Bvc2VIYW5kbGVycy5hZGQoKCkgPT4gY2hhbm5lbC5jbG9zZSgpKTtcbiAgICAgIHRoaXMuX2Rpc3Bvc2VIYW5kbGVycy5hZGQodGhpcy5fYWJvcnQuYWRkSGFuZGxlcigocmVhc29uKSA9PiB7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2UoKTtcbiAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICB9KSk7XG4gICAgfSk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcImdvdCByZXNwb25zZSBmcm9tIHdpbmRvd1wiKTtcbiAgICB0aGlzLl9kaXNwb3NlKCk7XG4gICAgaWYgKCFrZWVwT3Blbikge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgICByZXR1cm4geyB1cmwgfTtcbiAgfVxuICBfZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiX2Rpc3Bvc2VcIik7XG4gICAgZm9yIChjb25zdCBkaXNwb3NlIG9mIHRoaXMuX2Rpc3Bvc2VIYW5kbGVycykge1xuICAgICAgZGlzcG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLl9kaXNwb3NlSGFuZGxlcnMuY2xlYXIoKTtcbiAgfVxuICBzdGF0aWMgX25vdGlmeVBhcmVudChwYXJlbnQsIHVybCwga2VlcE9wZW4gPSBmYWxzZSwgdGFyZ2V0T3JpZ2luID0gd2luZG93LmxvY2F0aW9uLm9yaWdpbikge1xuICAgIGNvbnN0IG1zZ0RhdGEgPSB7XG4gICAgICBzb3VyY2U6IG1lc3NhZ2VTb3VyY2UsXG4gICAgICB1cmwsXG4gICAgICBrZWVwT3BlblxuICAgIH07XG4gICAgY29uc3QgbG9nZ2VyMiA9IG5ldyBMb2dnZXIoXCJfbm90aWZ5UGFyZW50XCIpO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJXaXRoIHBhcmVudC4gVXNpbmcgcGFyZW50LnBvc3RNZXNzYWdlLlwiKTtcbiAgICAgIHBhcmVudC5wb3N0TWVzc2FnZShtc2dEYXRhLCB0YXJnZXRPcmlnaW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwiTm8gcGFyZW50LiBVc2luZyBCcm9hZGNhc3RDaGFubmVsLlwiKTtcbiAgICAgIGNvbnN0IHN0YXRlID0gbmV3IFVSTCh1cmwpLnNlYXJjaFBhcmFtcy5nZXQoXCJzdGF0ZVwiKTtcbiAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcGFyZW50IGFuZCBubyBzdGF0ZSBpbiBVUkwuIENhbid0IGNvbXBsZXRlIG5vdGlmaWNhdGlvbi5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoYG9pZGMtY2xpZW50LXBvcHVwLSR7c3RhdGV9YCk7XG4gICAgICBjaGFubmVsLnBvc3RNZXNzYWdlKG1zZ0RhdGEpO1xuICAgICAgY2hhbm5lbC5jbG9zZSgpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL1VzZXJNYW5hZ2VyU2V0dGluZ3MudHNcbnZhciBEZWZhdWx0UG9wdXBXaW5kb3dGZWF0dXJlcyA9IHtcbiAgbG9jYXRpb246IGZhbHNlLFxuICB0b29sYmFyOiBmYWxzZSxcbiAgaGVpZ2h0OiA2NDAsXG4gIGNsb3NlUG9wdXBXaW5kb3dBZnRlckluU2Vjb25kczogLTFcbn07XG52YXIgRGVmYXVsdFBvcHVwVGFyZ2V0ID0gXCJfYmxhbmtcIjtcbnZhciBEZWZhdWx0QWNjZXNzVG9rZW5FeHBpcmluZ05vdGlmaWNhdGlvblRpbWVJblNlY29uZHMgPSA2MDtcbnZhciBEZWZhdWx0Q2hlY2tTZXNzaW9uSW50ZXJ2YWxJblNlY29uZHMgPSAyO1xudmFyIERlZmF1bHRTaWxlbnRSZXF1ZXN0VGltZW91dEluU2Vjb25kcyA9IDEwO1xudmFyIFVzZXJNYW5hZ2VyU2V0dGluZ3NTdG9yZSA9IGNsYXNzIGV4dGVuZHMgT2lkY0NsaWVudFNldHRpbmdzU3RvcmUge1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgY29uc3Qge1xuICAgICAgcG9wdXBfcmVkaXJlY3RfdXJpID0gYXJncy5yZWRpcmVjdF91cmksXG4gICAgICBwb3B1cF9wb3N0X2xvZ291dF9yZWRpcmVjdF91cmkgPSBhcmdzLnBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSxcbiAgICAgIHBvcHVwV2luZG93RmVhdHVyZXMgPSBEZWZhdWx0UG9wdXBXaW5kb3dGZWF0dXJlcyxcbiAgICAgIHBvcHVwV2luZG93VGFyZ2V0ID0gRGVmYXVsdFBvcHVwVGFyZ2V0LFxuICAgICAgcmVkaXJlY3RNZXRob2QgPSBcImFzc2lnblwiLFxuICAgICAgcmVkaXJlY3RUYXJnZXQgPSBcInNlbGZcIixcbiAgICAgIGlmcmFtZU5vdGlmeVBhcmVudE9yaWdpbiA9IGFyZ3MuaWZyYW1lTm90aWZ5UGFyZW50T3JpZ2luLFxuICAgICAgaWZyYW1lU2NyaXB0T3JpZ2luID0gYXJncy5pZnJhbWVTY3JpcHRPcmlnaW4sXG4gICAgICByZXF1ZXN0VGltZW91dEluU2Vjb25kcyxcbiAgICAgIHNpbGVudF9yZWRpcmVjdF91cmkgPSBhcmdzLnJlZGlyZWN0X3VyaSxcbiAgICAgIHNpbGVudFJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzLFxuICAgICAgYXV0b21hdGljU2lsZW50UmVuZXcgPSB0cnVlLFxuICAgICAgdmFsaWRhdGVTdWJPblNpbGVudFJlbmV3ID0gdHJ1ZSxcbiAgICAgIGluY2x1ZGVJZFRva2VuSW5TaWxlbnRSZW5ldyA9IGZhbHNlLFxuICAgICAgbW9uaXRvclNlc3Npb24gPSBmYWxzZSxcbiAgICAgIG1vbml0b3JBbm9ueW1vdXNTZXNzaW9uID0gZmFsc2UsXG4gICAgICBjaGVja1Nlc3Npb25JbnRlcnZhbEluU2Vjb25kcyA9IERlZmF1bHRDaGVja1Nlc3Npb25JbnRlcnZhbEluU2Vjb25kcyxcbiAgICAgIHF1ZXJ5X3N0YXR1c19yZXNwb25zZV90eXBlID0gXCJjb2RlXCIsXG4gICAgICBzdG9wQ2hlY2tTZXNzaW9uT25FcnJvciA9IHRydWUsXG4gICAgICByZXZva2VUb2tlblR5cGVzID0gW1wiYWNjZXNzX3Rva2VuXCIsIFwicmVmcmVzaF90b2tlblwiXSxcbiAgICAgIHJldm9rZVRva2Vuc09uU2lnbm91dCA9IGZhbHNlLFxuICAgICAgaW5jbHVkZUlkVG9rZW5JblNpbGVudFNpZ25vdXQgPSBmYWxzZSxcbiAgICAgIGFjY2Vzc1Rva2VuRXhwaXJpbmdOb3RpZmljYXRpb25UaW1lSW5TZWNvbmRzID0gRGVmYXVsdEFjY2Vzc1Rva2VuRXhwaXJpbmdOb3RpZmljYXRpb25UaW1lSW5TZWNvbmRzLFxuICAgICAgdXNlclN0b3JlXG4gICAgfSA9IGFyZ3M7XG4gICAgc3VwZXIoYXJncyk7XG4gICAgdGhpcy5wb3B1cF9yZWRpcmVjdF91cmkgPSBwb3B1cF9yZWRpcmVjdF91cmk7XG4gICAgdGhpcy5wb3B1cF9wb3N0X2xvZ291dF9yZWRpcmVjdF91cmkgPSBwb3B1cF9wb3N0X2xvZ291dF9yZWRpcmVjdF91cmk7XG4gICAgdGhpcy5wb3B1cFdpbmRvd0ZlYXR1cmVzID0gcG9wdXBXaW5kb3dGZWF0dXJlcztcbiAgICB0aGlzLnBvcHVwV2luZG93VGFyZ2V0ID0gcG9wdXBXaW5kb3dUYXJnZXQ7XG4gICAgdGhpcy5yZWRpcmVjdE1ldGhvZCA9IHJlZGlyZWN0TWV0aG9kO1xuICAgIHRoaXMucmVkaXJlY3RUYXJnZXQgPSByZWRpcmVjdFRhcmdldDtcbiAgICB0aGlzLmlmcmFtZU5vdGlmeVBhcmVudE9yaWdpbiA9IGlmcmFtZU5vdGlmeVBhcmVudE9yaWdpbjtcbiAgICB0aGlzLmlmcmFtZVNjcmlwdE9yaWdpbiA9IGlmcmFtZVNjcmlwdE9yaWdpbjtcbiAgICB0aGlzLnNpbGVudF9yZWRpcmVjdF91cmkgPSBzaWxlbnRfcmVkaXJlY3RfdXJpO1xuICAgIHRoaXMuc2lsZW50UmVxdWVzdFRpbWVvdXRJblNlY29uZHMgPSBzaWxlbnRSZXF1ZXN0VGltZW91dEluU2Vjb25kcyB8fCByZXF1ZXN0VGltZW91dEluU2Vjb25kcyB8fCBEZWZhdWx0U2lsZW50UmVxdWVzdFRpbWVvdXRJblNlY29uZHM7XG4gICAgdGhpcy5hdXRvbWF0aWNTaWxlbnRSZW5ldyA9IGF1dG9tYXRpY1NpbGVudFJlbmV3O1xuICAgIHRoaXMudmFsaWRhdGVTdWJPblNpbGVudFJlbmV3ID0gdmFsaWRhdGVTdWJPblNpbGVudFJlbmV3O1xuICAgIHRoaXMuaW5jbHVkZUlkVG9rZW5JblNpbGVudFJlbmV3ID0gaW5jbHVkZUlkVG9rZW5JblNpbGVudFJlbmV3O1xuICAgIHRoaXMubW9uaXRvclNlc3Npb24gPSBtb25pdG9yU2Vzc2lvbjtcbiAgICB0aGlzLm1vbml0b3JBbm9ueW1vdXNTZXNzaW9uID0gbW9uaXRvckFub255bW91c1Nlc3Npb247XG4gICAgdGhpcy5jaGVja1Nlc3Npb25JbnRlcnZhbEluU2Vjb25kcyA9IGNoZWNrU2Vzc2lvbkludGVydmFsSW5TZWNvbmRzO1xuICAgIHRoaXMuc3RvcENoZWNrU2Vzc2lvbk9uRXJyb3IgPSBzdG9wQ2hlY2tTZXNzaW9uT25FcnJvcjtcbiAgICB0aGlzLnF1ZXJ5X3N0YXR1c19yZXNwb25zZV90eXBlID0gcXVlcnlfc3RhdHVzX3Jlc3BvbnNlX3R5cGU7XG4gICAgdGhpcy5yZXZva2VUb2tlblR5cGVzID0gcmV2b2tlVG9rZW5UeXBlcztcbiAgICB0aGlzLnJldm9rZVRva2Vuc09uU2lnbm91dCA9IHJldm9rZVRva2Vuc09uU2lnbm91dDtcbiAgICB0aGlzLmluY2x1ZGVJZFRva2VuSW5TaWxlbnRTaWdub3V0ID0gaW5jbHVkZUlkVG9rZW5JblNpbGVudFNpZ25vdXQ7XG4gICAgdGhpcy5hY2Nlc3NUb2tlbkV4cGlyaW5nTm90aWZpY2F0aW9uVGltZUluU2Vjb25kcyA9IGFjY2Vzc1Rva2VuRXhwaXJpbmdOb3RpZmljYXRpb25UaW1lSW5TZWNvbmRzO1xuICAgIGlmICh1c2VyU3RvcmUpIHtcbiAgICAgIHRoaXMudXNlclN0b3JlID0gdXNlclN0b3JlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdG9yZSA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UgOiBuZXcgSW5NZW1vcnlXZWJTdG9yYWdlKCk7XG4gICAgICB0aGlzLnVzZXJTdG9yZSA9IG5ldyBXZWJTdG9yYWdlU3RhdGVTdG9yZSh7IHN0b3JlIH0pO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL25hdmlnYXRvcnMvSUZyYW1lV2luZG93LnRzXG52YXIgSUZyYW1lV2luZG93ID0gY2xhc3MgX0lGcmFtZVdpbmRvdyBleHRlbmRzIEFic3RyYWN0Q2hpbGRXaW5kb3cge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgc2lsZW50UmVxdWVzdFRpbWVvdXRJblNlY29uZHMgPSBEZWZhdWx0U2lsZW50UmVxdWVzdFRpbWVvdXRJblNlY29uZHNcbiAgfSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIklGcmFtZVdpbmRvd1wiKTtcbiAgICB0aGlzLl90aW1lb3V0SW5TZWNvbmRzID0gc2lsZW50UmVxdWVzdFRpbWVvdXRJblNlY29uZHM7XG4gICAgdGhpcy5fZnJhbWUgPSBfSUZyYW1lV2luZG93LmNyZWF0ZUhpZGRlbklmcmFtZSgpO1xuICAgIHRoaXMuX3dpbmRvdyA9IHRoaXMuX2ZyYW1lLmNvbnRlbnRXaW5kb3c7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUhpZGRlbklmcmFtZSgpIHtcbiAgICBjb25zdCBpZnJhbWUgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICBpZnJhbWUuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgaWZyYW1lLnN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xuICAgIGlmcmFtZS5zdHlsZS5sZWZ0ID0gXCItMTAwMHB4XCI7XG4gICAgaWZyYW1lLnN0eWxlLnRvcCA9IFwiMFwiO1xuICAgIGlmcmFtZS53aWR0aCA9IFwiMFwiO1xuICAgIGlmcmFtZS5oZWlnaHQgPSBcIjBcIjtcbiAgICB3aW5kb3cuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIHJldHVybiBpZnJhbWU7XG4gIH1cbiAgYXN5bmMgbmF2aWdhdGUocGFyYW1zKSB7XG4gICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwibmF2aWdhdGU6IFVzaW5nIHRpbWVvdXQgb2Y6XCIsIHRoaXMuX3RpbWVvdXRJblNlY29uZHMpO1xuICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB2b2lkIHRoaXMuX2Fib3J0LnJhaXNlKG5ldyBFcnJvclRpbWVvdXQoXCJJRnJhbWUgdGltZWQgb3V0IHdpdGhvdXQgYSByZXNwb25zZVwiKSksIHRoaXMuX3RpbWVvdXRJblNlY29uZHMgKiAxZTMpO1xuICAgIHRoaXMuX2Rpc3Bvc2VIYW5kbGVycy5hZGQoKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVyKSk7XG4gICAgcmV0dXJuIGF3YWl0IHN1cGVyLm5hdmlnYXRlKHBhcmFtcyk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICh0aGlzLl9mcmFtZSkge1xuICAgICAgaWYgKHRoaXMuX2ZyYW1lLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGhpcy5fZnJhbWUuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKGV2KSA9PiB7XG4gICAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgICBjb25zdCBmcmFtZSA9IGV2LnRhcmdldDtcbiAgICAgICAgICAoX2EyID0gZnJhbWUucGFyZW50Tm9kZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5yZW1vdmVDaGlsZChmcmFtZSk7XG4gICAgICAgICAgdm9pZCB0aGlzLl9hYm9ydC5yYWlzZShuZXcgRXJyb3IoXCJJRnJhbWUgcmVtb3ZlZCBmcm9tIERPTVwiKSk7XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICAoX2EgPSB0aGlzLl9mcmFtZS5jb250ZW50V2luZG93KSA9PSBudWxsID8gdm9pZCAwIDogX2EubG9jYXRpb24ucmVwbGFjZShcImFib3V0OmJsYW5rXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZnJhbWUgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLl93aW5kb3cgPSBudWxsO1xuICB9XG4gIHN0YXRpYyBub3RpZnlQYXJlbnQodXJsLCB0YXJnZXRPcmlnaW4pIHtcbiAgICByZXR1cm4gc3VwZXIuX25vdGlmeVBhcmVudCh3aW5kb3cucGFyZW50LCB1cmwsIGZhbHNlLCB0YXJnZXRPcmlnaW4pO1xuICB9XG59O1xuXG4vLyBzcmMvbmF2aWdhdG9ycy9JRnJhbWVOYXZpZ2F0b3IudHNcbnZhciBJRnJhbWVOYXZpZ2F0b3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKF9zZXR0aW5ncykge1xuICAgIHRoaXMuX3NldHRpbmdzID0gX3NldHRpbmdzO1xuICAgIHRoaXMuX2xvZ2dlciA9IG5ldyBMb2dnZXIoXCJJRnJhbWVOYXZpZ2F0b3JcIik7XG4gIH1cbiAgYXN5bmMgcHJlcGFyZSh7XG4gICAgc2lsZW50UmVxdWVzdFRpbWVvdXRJblNlY29uZHMgPSB0aGlzLl9zZXR0aW5ncy5zaWxlbnRSZXF1ZXN0VGltZW91dEluU2Vjb25kc1xuICB9KSB7XG4gICAgcmV0dXJuIG5ldyBJRnJhbWVXaW5kb3coeyBzaWxlbnRSZXF1ZXN0VGltZW91dEluU2Vjb25kcyB9KTtcbiAgfVxuICBhc3luYyBjYWxsYmFjayh1cmwpIHtcbiAgICB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiY2FsbGJhY2tcIik7XG4gICAgSUZyYW1lV2luZG93Lm5vdGlmeVBhcmVudCh1cmwsIHRoaXMuX3NldHRpbmdzLmlmcmFtZU5vdGlmeVBhcmVudE9yaWdpbik7XG4gIH1cbn07XG5cbi8vIHNyYy9uYXZpZ2F0b3JzL1BvcHVwV2luZG93LnRzXG52YXIgY2hlY2tGb3JQb3B1cENsb3NlZEludGVydmFsID0gNTAwO1xudmFyIHNlY29uZCA9IDFlMztcbnZhciBQb3B1cFdpbmRvdyA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RDaGlsZFdpbmRvdyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwb3B1cFdpbmRvd1RhcmdldCA9IERlZmF1bHRQb3B1cFRhcmdldCxcbiAgICBwb3B1cFdpbmRvd0ZlYXR1cmVzID0ge30sXG4gICAgcG9wdXBTaWduYWxcbiAgfSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIlBvcHVwV2luZG93XCIpO1xuICAgIGNvbnN0IGNlbnRlcmVkUG9wdXAgPSBQb3B1cFV0aWxzLmNlbnRlcih7IC4uLkRlZmF1bHRQb3B1cFdpbmRvd0ZlYXR1cmVzLCAuLi5wb3B1cFdpbmRvd0ZlYXR1cmVzIH0pO1xuICAgIHRoaXMuX3dpbmRvdyA9IHdpbmRvdy5vcGVuKHZvaWQgMCwgcG9wdXBXaW5kb3dUYXJnZXQsIFBvcHVwVXRpbHMuc2VyaWFsaXplKGNlbnRlcmVkUG9wdXApKTtcbiAgICBpZiAocG9wdXBTaWduYWwpIHtcbiAgICAgIHBvcHVwU2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdm9pZCB0aGlzLl9hYm9ydC5yYWlzZShuZXcgRXJyb3IoKF9hID0gcG9wdXBTaWduYWwucmVhc29uKSAhPSBudWxsID8gX2EgOiBcIlBvcHVwIGFib3J0ZWRcIikpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwb3B1cFdpbmRvd0ZlYXR1cmVzLmNsb3NlUG9wdXBXaW5kb3dBZnRlckluU2Vjb25kcyAmJiBwb3B1cFdpbmRvd0ZlYXR1cmVzLmNsb3NlUG9wdXBXaW5kb3dBZnRlckluU2Vjb25kcyA+IDApIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuX3dpbmRvdyB8fCB0eXBlb2YgdGhpcy5fd2luZG93LmNsb3NlZCAhPT0gXCJib29sZWFuXCIgfHwgdGhpcy5fd2luZG93LmNsb3NlZCkge1xuICAgICAgICAgIHZvaWQgdGhpcy5fYWJvcnQucmFpc2UobmV3IEVycm9yKFwiUG9wdXAgYmxvY2tlZCBieSB1c2VyXCIpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfSwgcG9wdXBXaW5kb3dGZWF0dXJlcy5jbG9zZVBvcHVwV2luZG93QWZ0ZXJJblNlY29uZHMgKiBzZWNvbmQpO1xuICAgIH1cbiAgfVxuICBhc3luYyBuYXZpZ2F0ZShwYXJhbXMpIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gdGhpcy5fd2luZG93KSA9PSBudWxsID8gdm9pZCAwIDogX2EuZm9jdXMoKTtcbiAgICBjb25zdCBwb3B1cENsb3NlZEludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl93aW5kb3cgfHwgdGhpcy5fd2luZG93LmNsb3NlZCkge1xuICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoXCJQb3B1cCBjbG9zZWQgYnkgdXNlciBvciBpc29sYXRlZCBieSByZWRpcmVjdFwiKTtcbiAgICAgICAgY2xlYXJQb3B1cENsb3NlZEludGVydmFsKCk7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VIYW5kbGVycy5kZWxldGUoY2xlYXJQb3B1cENsb3NlZEludGVydmFsKTtcbiAgICAgIH1cbiAgICB9LCBjaGVja0ZvclBvcHVwQ2xvc2VkSW50ZXJ2YWwpO1xuICAgIGNvbnN0IGNsZWFyUG9wdXBDbG9zZWRJbnRlcnZhbCA9ICgpID0+IGNsZWFySW50ZXJ2YWwocG9wdXBDbG9zZWRJbnRlcnZhbCk7XG4gICAgdGhpcy5fZGlzcG9zZUhhbmRsZXJzLmFkZChjbGVhclBvcHVwQ2xvc2VkSW50ZXJ2YWwpO1xuICAgIHJldHVybiBhd2FpdCBzdXBlci5uYXZpZ2F0ZShwYXJhbXMpO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIGlmICh0aGlzLl93aW5kb3cpIHtcbiAgICAgIGlmICghdGhpcy5fd2luZG93LmNsb3NlZCkge1xuICAgICAgICB0aGlzLl93aW5kb3cuY2xvc2UoKTtcbiAgICAgICAgdm9pZCB0aGlzLl9hYm9ydC5yYWlzZShuZXcgRXJyb3IoXCJQb3B1cCBjbG9zZWRcIikpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl93aW5kb3cgPSBudWxsO1xuICB9XG4gIHN0YXRpYyBub3RpZnlPcGVuZXIodXJsLCBrZWVwT3Blbikge1xuICAgIHN1cGVyLl9ub3RpZnlQYXJlbnQod2luZG93Lm9wZW5lciwgdXJsLCBrZWVwT3Blbik7XG4gICAgaWYgKCFrZWVwT3BlbiAmJiAhd2luZG93Lm9wZW5lcikge1xuICAgICAgd2luZG93LmNsb3NlKCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvbmF2aWdhdG9ycy9Qb3B1cE5hdmlnYXRvci50c1xudmFyIFBvcHVwTmF2aWdhdG9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihfc2V0dGluZ3MpIHtcbiAgICB0aGlzLl9zZXR0aW5ncyA9IF9zZXR0aW5ncztcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiUG9wdXBOYXZpZ2F0b3JcIik7XG4gIH1cbiAgYXN5bmMgcHJlcGFyZSh7XG4gICAgcG9wdXBXaW5kb3dGZWF0dXJlcyA9IHRoaXMuX3NldHRpbmdzLnBvcHVwV2luZG93RmVhdHVyZXMsXG4gICAgcG9wdXBXaW5kb3dUYXJnZXQgPSB0aGlzLl9zZXR0aW5ncy5wb3B1cFdpbmRvd1RhcmdldCxcbiAgICBwb3B1cFNpZ25hbFxuICB9KSB7XG4gICAgcmV0dXJuIG5ldyBQb3B1cFdpbmRvdyh7IHBvcHVwV2luZG93RmVhdHVyZXMsIHBvcHVwV2luZG93VGFyZ2V0LCBwb3B1cFNpZ25hbCB9KTtcbiAgfVxuICBhc3luYyBjYWxsYmFjayh1cmwsIHsga2VlcE9wZW4gPSBmYWxzZSB9KSB7XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShcImNhbGxiYWNrXCIpO1xuICAgIFBvcHVwV2luZG93Lm5vdGlmeU9wZW5lcih1cmwsIGtlZXBPcGVuKTtcbiAgfVxufTtcblxuLy8gc3JjL25hdmlnYXRvcnMvUmVkaXJlY3ROYXZpZ2F0b3IudHNcbnZhciBSZWRpcmVjdE5hdmlnYXRvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoX3NldHRpbmdzKSB7XG4gICAgdGhpcy5fc2V0dGluZ3MgPSBfc2V0dGluZ3M7XG4gICAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIlJlZGlyZWN0TmF2aWdhdG9yXCIpO1xuICB9XG4gIGFzeW5jIHByZXBhcmUoe1xuICAgIHJlZGlyZWN0TWV0aG9kID0gdGhpcy5fc2V0dGluZ3MucmVkaXJlY3RNZXRob2QsXG4gICAgcmVkaXJlY3RUYXJnZXQgPSB0aGlzLl9zZXR0aW5ncy5yZWRpcmVjdFRhcmdldFxuICB9KSB7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJwcmVwYXJlXCIpO1xuICAgIGxldCB0YXJnZXRXaW5kb3cgPSB3aW5kb3cuc2VsZjtcbiAgICBpZiAocmVkaXJlY3RUYXJnZXQgPT09IFwidG9wXCIpIHtcbiAgICAgIHRhcmdldFdpbmRvdyA9IChfYSA9IHdpbmRvdy50b3ApICE9IG51bGwgPyBfYSA6IHdpbmRvdy5zZWxmO1xuICAgIH1cbiAgICBjb25zdCByZWRpcmVjdCA9IHRhcmdldFdpbmRvdy5sb2NhdGlvbltyZWRpcmVjdE1ldGhvZF0uYmluZCh0YXJnZXRXaW5kb3cubG9jYXRpb24pO1xuICAgIGxldCBhYm9ydDtcbiAgICByZXR1cm4ge1xuICAgICAgbmF2aWdhdGU6IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIm5hdmlnYXRlXCIpO1xuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGFib3J0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgcmVkaXJlY3QocGFyYW1zLnVybCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBwcm9taXNlO1xuICAgICAgfSxcbiAgICAgIGNsb3NlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJjbG9zZVwiKTtcbiAgICAgICAgYWJvcnQgPT0gbnVsbCA/IHZvaWQgMCA6IGFib3J0KG5ldyBFcnJvcihcIlJlZGlyZWN0IGFib3J0ZWRcIikpO1xuICAgICAgICB0YXJnZXRXaW5kb3cuc3RvcCgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgYXN5bmMgY2FsbGJhY2soKSB7XG4gICAgcmV0dXJuO1xuICB9XG59O1xuXG4vLyBzcmMvVXNlck1hbmFnZXJFdmVudHMudHNcbnZhciBVc2VyTWFuYWdlckV2ZW50cyA9IGNsYXNzIGV4dGVuZHMgQWNjZXNzVG9rZW5FdmVudHMge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHsgZXhwaXJpbmdOb3RpZmljYXRpb25UaW1lSW5TZWNvbmRzOiBzZXR0aW5ncy5hY2Nlc3NUb2tlbkV4cGlyaW5nTm90aWZpY2F0aW9uVGltZUluU2Vjb25kcyB9KTtcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiVXNlck1hbmFnZXJFdmVudHNcIik7XG4gICAgdGhpcy5fdXNlckxvYWRlZCA9IG5ldyBFdmVudChcIlVzZXIgbG9hZGVkXCIpO1xuICAgIHRoaXMuX3VzZXJVbmxvYWRlZCA9IG5ldyBFdmVudChcIlVzZXIgdW5sb2FkZWRcIik7XG4gICAgdGhpcy5fc2lsZW50UmVuZXdFcnJvciA9IG5ldyBFdmVudChcIlNpbGVudCByZW5ldyBlcnJvclwiKTtcbiAgICB0aGlzLl91c2VyU2lnbmVkSW4gPSBuZXcgRXZlbnQoXCJVc2VyIHNpZ25lZCBpblwiKTtcbiAgICB0aGlzLl91c2VyU2lnbmVkT3V0ID0gbmV3IEV2ZW50KFwiVXNlciBzaWduZWQgb3V0XCIpO1xuICAgIHRoaXMuX3VzZXJTZXNzaW9uQ2hhbmdlZCA9IG5ldyBFdmVudChcIlVzZXIgc2Vzc2lvbiBjaGFuZ2VkXCIpO1xuICB9XG4gIGFzeW5jIGxvYWQodXNlciwgcmFpc2VFdmVudCA9IHRydWUpIHtcbiAgICBhd2FpdCBzdXBlci5sb2FkKHVzZXIpO1xuICAgIGlmIChyYWlzZUV2ZW50KSB7XG4gICAgICBhd2FpdCB0aGlzLl91c2VyTG9hZGVkLnJhaXNlKHVzZXIpO1xuICAgIH1cbiAgfVxuICBhc3luYyB1bmxvYWQoKSB7XG4gICAgYXdhaXQgc3VwZXIudW5sb2FkKCk7XG4gICAgYXdhaXQgdGhpcy5fdXNlclVubG9hZGVkLnJhaXNlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBjYWxsYmFjazogUmFpc2VkIHdoZW4gYSB1c2VyIHNlc3Npb24gaGFzIGJlZW4gZXN0YWJsaXNoZWQgKG9yIHJlLWVzdGFibGlzaGVkKS5cbiAgICovXG4gIGFkZFVzZXJMb2FkZWQoY2IpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlckxvYWRlZC5hZGRIYW5kbGVyKGNiKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGNhbGxiYWNrOiBSYWlzZWQgd2hlbiBhIHVzZXIgc2Vzc2lvbiBoYXMgYmVlbiBlc3RhYmxpc2hlZCAob3IgcmUtZXN0YWJsaXNoZWQpLlxuICAgKi9cbiAgcmVtb3ZlVXNlckxvYWRlZChjYikge1xuICAgIHJldHVybiB0aGlzLl91c2VyTG9hZGVkLnJlbW92ZUhhbmRsZXIoY2IpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgY2FsbGJhY2s6IFJhaXNlZCB3aGVuIGEgdXNlciBzZXNzaW9uIGhhcyBiZWVuIHRlcm1pbmF0ZWQuXG4gICAqL1xuICBhZGRVc2VyVW5sb2FkZWQoY2IpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlclVubG9hZGVkLmFkZEhhbmRsZXIoY2IpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgY2FsbGJhY2s6IFJhaXNlZCB3aGVuIGEgdXNlciBzZXNzaW9uIGhhcyBiZWVuIHRlcm1pbmF0ZWQuXG4gICAqL1xuICByZW1vdmVVc2VyVW5sb2FkZWQoY2IpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlclVubG9hZGVkLnJlbW92ZUhhbmRsZXIoY2IpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgY2FsbGJhY2s6IFJhaXNlZCB3aGVuIHRoZSBhdXRvbWF0aWMgc2lsZW50IHJlbmV3IGhhcyBmYWlsZWQuXG4gICAqL1xuICBhZGRTaWxlbnRSZW5ld0Vycm9yKGNiKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpbGVudFJlbmV3RXJyb3IuYWRkSGFuZGxlcihjYik7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBjYWxsYmFjazogUmFpc2VkIHdoZW4gdGhlIGF1dG9tYXRpYyBzaWxlbnQgcmVuZXcgaGFzIGZhaWxlZC5cbiAgICovXG4gIHJlbW92ZVNpbGVudFJlbmV3RXJyb3IoY2IpIHtcbiAgICByZXR1cm4gdGhpcy5fc2lsZW50UmVuZXdFcnJvci5yZW1vdmVIYW5kbGVyKGNiKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyBfcmFpc2VTaWxlbnRSZW5ld0Vycm9yKGUpIHtcbiAgICBhd2FpdCB0aGlzLl9zaWxlbnRSZW5ld0Vycm9yLnJhaXNlKGUpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgY2FsbGJhY2s6IFJhaXNlZCB3aGVuIHRoZSB1c2VyIGlzIHNpZ25lZCBpbiAod2hlbiBgbW9uaXRvclNlc3Npb25gIGlzIHNldCkuXG4gICAqIEBzZWUge0BsaW5rIFVzZXJNYW5hZ2VyU2V0dGluZ3MubW9uaXRvclNlc3Npb259XG4gICAqL1xuICBhZGRVc2VyU2lnbmVkSW4oY2IpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlclNpZ25lZEluLmFkZEhhbmRsZXIoY2IpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgY2FsbGJhY2s6IFJhaXNlZCB3aGVuIHRoZSB1c2VyIGlzIHNpZ25lZCBpbiAod2hlbiBgbW9uaXRvclNlc3Npb25gIGlzIHNldCkuXG4gICAqL1xuICByZW1vdmVVc2VyU2lnbmVkSW4oY2IpIHtcbiAgICB0aGlzLl91c2VyU2lnbmVkSW4ucmVtb3ZlSGFuZGxlcihjYik7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgX3JhaXNlVXNlclNpZ25lZEluKCkge1xuICAgIGF3YWl0IHRoaXMuX3VzZXJTaWduZWRJbi5yYWlzZSgpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgY2FsbGJhY2s6IFJhaXNlZCB3aGVuIHRoZSB1c2VyJ3Mgc2lnbi1pbiBzdGF0dXMgYXQgdGhlIE9QIGhhcyBjaGFuZ2VkICh3aGVuIGBtb25pdG9yU2Vzc2lvbmAgaXMgc2V0KS5cbiAgICogQHNlZSB7QGxpbmsgVXNlck1hbmFnZXJTZXR0aW5ncy5tb25pdG9yU2Vzc2lvbn1cbiAgICovXG4gIGFkZFVzZXJTaWduZWRPdXQoY2IpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlclNpZ25lZE91dC5hZGRIYW5kbGVyKGNiKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGNhbGxiYWNrOiBSYWlzZWQgd2hlbiB0aGUgdXNlcidzIHNpZ24taW4gc3RhdHVzIGF0IHRoZSBPUCBoYXMgY2hhbmdlZCAod2hlbiBgbW9uaXRvclNlc3Npb25gIGlzIHNldCkuXG4gICAqL1xuICByZW1vdmVVc2VyU2lnbmVkT3V0KGNiKSB7XG4gICAgdGhpcy5fdXNlclNpZ25lZE91dC5yZW1vdmVIYW5kbGVyKGNiKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyBfcmFpc2VVc2VyU2lnbmVkT3V0KCkge1xuICAgIGF3YWl0IHRoaXMuX3VzZXJTaWduZWRPdXQucmFpc2UoKTtcbiAgfVxuICAvKipcbiAgICogQWRkIGNhbGxiYWNrOiBSYWlzZWQgd2hlbiB0aGUgdXNlciBzZXNzaW9uIGNoYW5nZWQgKHdoZW4gYG1vbml0b3JTZXNzaW9uYCBpcyBzZXQpLlxuICAgKiBAc2VlIHtAbGluayBVc2VyTWFuYWdlclNldHRpbmdzLm1vbml0b3JTZXNzaW9ufVxuICAgKi9cbiAgYWRkVXNlclNlc3Npb25DaGFuZ2VkKGNiKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXJTZXNzaW9uQ2hhbmdlZC5hZGRIYW5kbGVyKGNiKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGNhbGxiYWNrOiBSYWlzZWQgd2hlbiB0aGUgdXNlciBzZXNzaW9uIGNoYW5nZWQgKHdoZW4gYG1vbml0b3JTZXNzaW9uYCBpcyBzZXQpLlxuICAgKi9cbiAgcmVtb3ZlVXNlclNlc3Npb25DaGFuZ2VkKGNiKSB7XG4gICAgdGhpcy5fdXNlclNlc3Npb25DaGFuZ2VkLnJlbW92ZUhhbmRsZXIoY2IpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFzeW5jIF9yYWlzZVVzZXJTZXNzaW9uQ2hhbmdlZCgpIHtcbiAgICBhd2FpdCB0aGlzLl91c2VyU2Vzc2lvbkNoYW5nZWQucmFpc2UoKTtcbiAgfVxufTtcblxuLy8gc3JjL1NpbGVudFJlbmV3U2VydmljZS50c1xudmFyIFNpbGVudFJlbmV3U2VydmljZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoX3VzZXJNYW5hZ2VyKSB7XG4gICAgdGhpcy5fdXNlck1hbmFnZXIgPSBfdXNlck1hbmFnZXI7XG4gICAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIlNpbGVudFJlbmV3U2VydmljZVwiKTtcbiAgICB0aGlzLl9pc1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZXRyeVRpbWVyID0gbmV3IFRpbWVyKFwiUmV0cnkgU2lsZW50IFJlbmV3XCIpO1xuICAgIHRoaXMuX3Rva2VuRXhwaXJpbmcgPSBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIl90b2tlbkV4cGlyaW5nXCIpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5fdXNlck1hbmFnZXIuc2lnbmluU2lsZW50KCk7XG4gICAgICAgIGxvZ2dlcjIuZGVidWcoXCJzaWxlbnQgdG9rZW4gcmVuZXdhbCBzdWNjZXNzZnVsXCIpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvclRpbWVvdXQpIHtcbiAgICAgICAgICBsb2dnZXIyLndhcm4oXCJFcnJvclRpbWVvdXQgZnJvbSBzaWduaW5TaWxlbnQ6XCIsIGVyciwgXCJyZXRyeSBpbiA1c1wiKTtcbiAgICAgICAgICB0aGlzLl9yZXRyeVRpbWVyLmluaXQoNSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlcjIuZXJyb3IoXCJFcnJvciBmcm9tIHNpZ25pblNpbGVudDpcIiwgZXJyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fdXNlck1hbmFnZXIuZXZlbnRzLl9yYWlzZVNpbGVudFJlbmV3RXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGFzeW5jIHN0YXJ0KCkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwic3RhcnRcIik7XG4gICAgaWYgKCF0aGlzLl9pc1N0YXJ0ZWQpIHtcbiAgICAgIHRoaXMuX2lzU3RhcnRlZCA9IHRydWU7XG4gICAgICB0aGlzLl91c2VyTWFuYWdlci5ldmVudHMuYWRkQWNjZXNzVG9rZW5FeHBpcmluZyh0aGlzLl90b2tlbkV4cGlyaW5nKTtcbiAgICAgIHRoaXMuX3JldHJ5VGltZXIuYWRkSGFuZGxlcih0aGlzLl90b2tlbkV4cGlyaW5nKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3VzZXJNYW5hZ2VyLmdldFVzZXIoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dnZXIyLmVycm9yKFwiZ2V0VXNlciBlcnJvclwiLCBlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdG9wKCkge1xuICAgIGlmICh0aGlzLl9pc1N0YXJ0ZWQpIHtcbiAgICAgIHRoaXMuX3JldHJ5VGltZXIuY2FuY2VsKCk7XG4gICAgICB0aGlzLl9yZXRyeVRpbWVyLnJlbW92ZUhhbmRsZXIodGhpcy5fdG9rZW5FeHBpcmluZyk7XG4gICAgICB0aGlzLl91c2VyTWFuYWdlci5ldmVudHMucmVtb3ZlQWNjZXNzVG9rZW5FeHBpcmluZyh0aGlzLl90b2tlbkV4cGlyaW5nKTtcbiAgICAgIHRoaXMuX2lzU3RhcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL1JlZnJlc2hTdGF0ZS50c1xudmFyIFJlZnJlc2hTdGF0ZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHRoaXMucmVmcmVzaF90b2tlbiA9IGFyZ3MucmVmcmVzaF90b2tlbjtcbiAgICB0aGlzLmlkX3Rva2VuID0gYXJncy5pZF90b2tlbjtcbiAgICB0aGlzLnNlc3Npb25fc3RhdGUgPSBhcmdzLnNlc3Npb25fc3RhdGU7XG4gICAgdGhpcy5zY29wZSA9IGFyZ3Muc2NvcGU7XG4gICAgdGhpcy5wcm9maWxlID0gYXJncy5wcm9maWxlO1xuICAgIHRoaXMuZGF0YSA9IGFyZ3Muc3RhdGU7XG4gIH1cbn07XG5cbi8vIHNyYy9Vc2VyTWFuYWdlci50c1xudmFyIFVzZXJNYW5hZ2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncywgcmVkaXJlY3ROYXZpZ2F0b3IsIHBvcHVwTmF2aWdhdG9yLCBpZnJhbWVOYXZpZ2F0b3IpIHtcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiVXNlck1hbmFnZXJcIik7XG4gICAgdGhpcy5zZXR0aW5ncyA9IG5ldyBVc2VyTWFuYWdlclNldHRpbmdzU3RvcmUoc2V0dGluZ3MpO1xuICAgIHRoaXMuX2NsaWVudCA9IG5ldyBPaWRjQ2xpZW50KHNldHRpbmdzKTtcbiAgICB0aGlzLl9yZWRpcmVjdE5hdmlnYXRvciA9IHJlZGlyZWN0TmF2aWdhdG9yICE9IG51bGwgPyByZWRpcmVjdE5hdmlnYXRvciA6IG5ldyBSZWRpcmVjdE5hdmlnYXRvcih0aGlzLnNldHRpbmdzKTtcbiAgICB0aGlzLl9wb3B1cE5hdmlnYXRvciA9IHBvcHVwTmF2aWdhdG9yICE9IG51bGwgPyBwb3B1cE5hdmlnYXRvciA6IG5ldyBQb3B1cE5hdmlnYXRvcih0aGlzLnNldHRpbmdzKTtcbiAgICB0aGlzLl9pZnJhbWVOYXZpZ2F0b3IgPSBpZnJhbWVOYXZpZ2F0b3IgIT0gbnVsbCA/IGlmcmFtZU5hdmlnYXRvciA6IG5ldyBJRnJhbWVOYXZpZ2F0b3IodGhpcy5zZXR0aW5ncyk7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IFVzZXJNYW5hZ2VyRXZlbnRzKHRoaXMuc2V0dGluZ3MpO1xuICAgIHRoaXMuX3NpbGVudFJlbmV3U2VydmljZSA9IG5ldyBTaWxlbnRSZW5ld1NlcnZpY2UodGhpcyk7XG4gICAgaWYgKHRoaXMuc2V0dGluZ3MuYXV0b21hdGljU2lsZW50UmVuZXcpIHtcbiAgICAgIHRoaXMuc3RhcnRTaWxlbnRSZW5ldygpO1xuICAgIH1cbiAgICB0aGlzLl9zZXNzaW9uTW9uaXRvciA9IG51bGw7XG4gICAgaWYgKHRoaXMuc2V0dGluZ3MubW9uaXRvclNlc3Npb24pIHtcbiAgICAgIHRoaXMuX3Nlc3Npb25Nb25pdG9yID0gbmV3IFNlc3Npb25Nb25pdG9yKHRoaXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0IG9iamVjdCB1c2VkIHRvIHJlZ2lzdGVyIGZvciBldmVudHMgcmFpc2VkIGJ5IHRoZSBgVXNlck1hbmFnZXJgLlxuICAgKi9cbiAgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fZXZlbnRzO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgb2JqZWN0IHVzZWQgdG8gYWNjZXNzIHRoZSBtZXRhZGF0YSBjb25maWd1cmF0aW9uIG9mIHRoZSBpZGVudGl0eSBwcm92aWRlci5cbiAgICovXG4gIGdldCBtZXRhZGF0YVNlcnZpY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5tZXRhZGF0YVNlcnZpY2U7XG4gIH1cbiAgLyoqXG4gICAqIExvYWQgdGhlIGBVc2VyYCBvYmplY3QgZm9yIHRoZSBjdXJyZW50bHkgYXV0aGVudGljYXRlZCB1c2VyLlxuICAgKlxuICAgKiBAcGFyYW0gcmFpc2VFdmVudCAtIElmIGB0cnVlYCwgdGhlIGBVc2VyTG9hZGVkYCBldmVudCB3aWxsIGJlIHJhaXNlZC4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZVxuICAgKi9cbiAgYXN5bmMgZ2V0VXNlcihyYWlzZUV2ZW50ID0gZmFsc2UpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcImdldFVzZXJcIik7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMuX2xvYWRVc2VyKCk7XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIGxvZ2dlcjIuaW5mbyhcInVzZXIgbG9hZGVkXCIpO1xuICAgICAgYXdhaXQgdGhpcy5fZXZlbnRzLmxvYWQodXNlciwgcmFpc2VFdmVudCk7XG4gICAgICByZXR1cm4gdXNlcjtcbiAgICB9XG4gICAgbG9nZ2VyMi5pbmZvKFwidXNlciBub3QgZm91bmQgaW4gc3RvcmFnZVwiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGZyb20gYW55IHN0b3JhZ2UgdGhlIGN1cnJlbnRseSBhdXRoZW50aWNhdGVkIHVzZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZVxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlVXNlcigpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInJlbW92ZVVzZXJcIik7XG4gICAgYXdhaXQgdGhpcy5zdG9yZVVzZXIobnVsbCk7XG4gICAgbG9nZ2VyMi5pbmZvKFwidXNlciByZW1vdmVkIGZyb20gc3RvcmFnZVwiKTtcbiAgICBhd2FpdCB0aGlzLl9ldmVudHMudW5sb2FkKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRyaWdnZXIgYSByZWRpcmVjdCBvZiB0aGUgY3VycmVudCB3aW5kb3cgdG8gdGhlIGF1dGhvcml6YXRpb24gZW5kcG9pbnQuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZVxuICAgKlxuICAgKiBAdGhyb3dzIGBFcnJvcmAgSW4gY2FzZXMgb2Ygd3JvbmcgYXV0aGVudGljYXRpb24uXG4gICAqL1xuICBhc3luYyBzaWduaW5SZWRpcmVjdChhcmdzID0ge30pIHtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInNpZ25pblJlZGlyZWN0XCIpO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlZGlyZWN0TWV0aG9kLFxuICAgICAgLi4ucmVxdWVzdEFyZ3NcbiAgICB9ID0gYXJncztcbiAgICBsZXQgZHBvcEprdDtcbiAgICBpZiAoKF9hID0gdGhpcy5zZXR0aW5ncy5kcG9wKSA9PSBudWxsID8gdm9pZCAwIDogX2EuYmluZF9hdXRob3JpemF0aW9uX2NvZGUpIHtcbiAgICAgIGRwb3BKa3QgPSBhd2FpdCB0aGlzLmdlbmVyYXRlRFBvUEprdCh0aGlzLnNldHRpbmdzLmRwb3ApO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGUgPSBhd2FpdCB0aGlzLl9yZWRpcmVjdE5hdmlnYXRvci5wcmVwYXJlKHsgcmVkaXJlY3RNZXRob2QgfSk7XG4gICAgYXdhaXQgdGhpcy5fc2lnbmluU3RhcnQoe1xuICAgICAgcmVxdWVzdF90eXBlOiBcInNpOnJcIixcbiAgICAgIGRwb3BKa3QsXG4gICAgICAuLi5yZXF1ZXN0QXJnc1xuICAgIH0sIGhhbmRsZSk7XG4gIH1cbiAgLyoqXG4gICAqIFByb2Nlc3MgdGhlIHJlc3BvbnNlIChjYWxsYmFjaykgZnJvbSB0aGUgYXV0aG9yaXphdGlvbiBlbmRwb2ludC5cbiAgICogSXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIHtAbGluayBVc2VyTWFuYWdlci5zaWduaW5DYWxsYmFja30gaW5zdGVhZC5cbiAgICpcbiAgICogQHJldHVybnMgQSBwcm9taXNlIGNvbnRhaW5pbmcgdGhlIGF1dGhlbnRpY2F0ZWQgYFVzZXJgLlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBVc2VyTWFuYWdlci5zaWduaW5DYWxsYmFja31cbiAgICovXG4gIGFzeW5jIHNpZ25pblJlZGlyZWN0Q2FsbGJhY2sodXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWYpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInNpZ25pblJlZGlyZWN0Q2FsbGJhY2tcIik7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMuX3NpZ25pbkVuZCh1cmwpO1xuICAgIGlmICh1c2VyLnByb2ZpbGUgJiYgdXNlci5wcm9maWxlLnN1Yikge1xuICAgICAgbG9nZ2VyMi5pbmZvKFwic3VjY2Vzcywgc2lnbmVkIGluIHN1YmplY3RcIiwgdXNlci5wcm9maWxlLnN1Yik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlcjIuaW5mbyhcIm5vIHN1YmplY3RcIik7XG4gICAgfVxuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIC8qKlxuICAgKiBUcmlnZ2VyIHRoZSBzaWduaW4gd2l0aCB1c2VyL3Bhc3N3b3JkLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgY29udGFpbmluZyB0aGUgYXV0aGVudGljYXRlZCBgVXNlcmAuXG4gICAqIEB0aHJvd3Mge0BsaW5rIEVycm9yUmVzcG9uc2V9IEluIGNhc2VzIG9mIHdyb25nIGF1dGhlbnRpY2F0aW9uLlxuICAgKi9cbiAgYXN5bmMgc2lnbmluUmVzb3VyY2VPd25lckNyZWRlbnRpYWxzKHtcbiAgICB1c2VybmFtZSxcbiAgICBwYXNzd29yZCxcbiAgICBza2lwVXNlckluZm8gPSBmYWxzZVxuICB9KSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJzaWduaW5SZXNvdXJjZU93bmVyQ3JlZGVudGlhbFwiKTtcbiAgICBjb25zdCBzaWduaW5SZXNwb25zZSA9IGF3YWl0IHRoaXMuX2NsaWVudC5wcm9jZXNzUmVzb3VyY2VPd25lclBhc3N3b3JkQ3JlZGVudGlhbHMoe1xuICAgICAgdXNlcm5hbWUsXG4gICAgICBwYXNzd29yZCxcbiAgICAgIHNraXBVc2VySW5mbyxcbiAgICAgIGV4dHJhVG9rZW5QYXJhbXM6IHRoaXMuc2V0dGluZ3MuZXh0cmFUb2tlblBhcmFtc1xuICAgIH0pO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJnb3Qgc2lnbmluIHJlc3BvbnNlXCIpO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLl9idWlsZFVzZXIoc2lnbmluUmVzcG9uc2UpO1xuICAgIGlmICh1c2VyLnByb2ZpbGUgJiYgdXNlci5wcm9maWxlLnN1Yikge1xuICAgICAgbG9nZ2VyMi5pbmZvKFwic3VjY2Vzcywgc2lnbmVkIGluIHN1YmplY3RcIiwgdXNlci5wcm9maWxlLnN1Yik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlcjIuaW5mbyhcIm5vIHN1YmplY3RcIik7XG4gICAgfVxuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIC8qKlxuICAgKiBUcmlnZ2VyIGEgcmVxdWVzdCAodmlhIGEgcG9wdXAgd2luZG93KSB0byB0aGUgYXV0aG9yaXphdGlvbiBlbmRwb2ludC5cbiAgICpcbiAgICogQHJldHVybnMgQSBwcm9taXNlIGNvbnRhaW5pbmcgdGhlIGF1dGhlbnRpY2F0ZWQgYFVzZXJgLlxuICAgKiBAdGhyb3dzIGBFcnJvcmAgSW4gY2FzZXMgb2Ygd3JvbmcgYXV0aGVudGljYXRpb24uXG4gICAqL1xuICBhc3luYyBzaWduaW5Qb3B1cChhcmdzID0ge30pIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJzaWduaW5Qb3B1cFwiKTtcbiAgICBsZXQgZHBvcEprdDtcbiAgICBpZiAoKF9hID0gdGhpcy5zZXR0aW5ncy5kcG9wKSA9PSBudWxsID8gdm9pZCAwIDogX2EuYmluZF9hdXRob3JpemF0aW9uX2NvZGUpIHtcbiAgICAgIGRwb3BKa3QgPSBhd2FpdCB0aGlzLmdlbmVyYXRlRFBvUEprdCh0aGlzLnNldHRpbmdzLmRwb3ApO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBwb3B1cFdpbmRvd0ZlYXR1cmVzLFxuICAgICAgcG9wdXBXaW5kb3dUYXJnZXQsXG4gICAgICBwb3B1cFNpZ25hbCxcbiAgICAgIC4uLnJlcXVlc3RBcmdzXG4gICAgfSA9IGFyZ3M7XG4gICAgY29uc3QgdXJsID0gdGhpcy5zZXR0aW5ncy5wb3B1cF9yZWRpcmVjdF91cmk7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiTm8gcG9wdXBfcmVkaXJlY3RfdXJpIGNvbmZpZ3VyZWRcIikpO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGUgPSBhd2FpdCB0aGlzLl9wb3B1cE5hdmlnYXRvci5wcmVwYXJlKHsgcG9wdXBXaW5kb3dGZWF0dXJlcywgcG9wdXBXaW5kb3dUYXJnZXQsIHBvcHVwU2lnbmFsIH0pO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLl9zaWduaW4oe1xuICAgICAgcmVxdWVzdF90eXBlOiBcInNpOnBcIixcbiAgICAgIHJlZGlyZWN0X3VyaTogdXJsLFxuICAgICAgZGlzcGxheTogXCJwb3B1cFwiLFxuICAgICAgZHBvcEprdCxcbiAgICAgIC4uLnJlcXVlc3RBcmdzXG4gICAgfSwgaGFuZGxlKTtcbiAgICBpZiAodXNlcikge1xuICAgICAgaWYgKHVzZXIucHJvZmlsZSAmJiB1c2VyLnByb2ZpbGUuc3ViKSB7XG4gICAgICAgIGxvZ2dlcjIuaW5mbyhcInN1Y2Nlc3MsIHNpZ25lZCBpbiBzdWJqZWN0XCIsIHVzZXIucHJvZmlsZS5zdWIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyMi5pbmZvKFwibm8gc3ViamVjdFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVzZXI7XG4gIH1cbiAgLyoqXG4gICAqIE5vdGlmeSB0aGUgb3BlbmluZyB3aW5kb3cgb2YgcmVzcG9uc2UgKGNhbGxiYWNrKSBmcm9tIHRoZSBhdXRob3JpemF0aW9uIGVuZHBvaW50LlxuICAgKiBJdCBpcyByZWNvbW1lbmRlZCB0byB1c2Uge0BsaW5rIFVzZXJNYW5hZ2VyLnNpZ25pbkNhbGxiYWNrfSBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHByb21pc2VcbiAgICpcbiAgICogQHNlZSB7QGxpbmsgVXNlck1hbmFnZXIuc2lnbmluQ2FsbGJhY2t9XG4gICAqL1xuICBhc3luYyBzaWduaW5Qb3B1cENhbGxiYWNrKHVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLCBrZWVwT3BlbiA9IGZhbHNlKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJzaWduaW5Qb3B1cENhbGxiYWNrXCIpO1xuICAgIGF3YWl0IHRoaXMuX3BvcHVwTmF2aWdhdG9yLmNhbGxiYWNrKHVybCwgeyBrZWVwT3BlbiB9KTtcbiAgICBsb2dnZXIyLmluZm8oXCJzdWNjZXNzXCIpO1xuICB9XG4gIC8qKlxuICAgKiBUcmlnZ2VyIGEgc2lsZW50IHJlcXVlc3QgKHZpYSByZWZyZXNoIHRva2VuIG9yIGFuIGlmcmFtZSkgdG8gdGhlIGF1dGhvcml6YXRpb24gZW5kcG9pbnQuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IGNvbnRhaW5zIHRoZSBhdXRoZW50aWNhdGVkIGBVc2VyYC5cbiAgICovXG4gIGFzeW5jIHNpZ25pblNpbGVudChhcmdzID0ge30pIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwic2lnbmluU2lsZW50XCIpO1xuICAgIGNvbnN0IHtcbiAgICAgIHNpbGVudFJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzLFxuICAgICAgLi4ucmVxdWVzdEFyZ3NcbiAgICB9ID0gYXJncztcbiAgICBsZXQgdXNlciA9IGF3YWl0IHRoaXMuX2xvYWRVc2VyKCk7XG4gICAgaWYgKHVzZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHVzZXIucmVmcmVzaF90b2tlbikge1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcInVzaW5nIHJlZnJlc2ggdG9rZW5cIik7XG4gICAgICBjb25zdCBzdGF0ZSA9IG5ldyBSZWZyZXNoU3RhdGUodXNlcik7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlUmVmcmVzaFRva2VuKHtcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHJlZGlyZWN0X3VyaTogcmVxdWVzdEFyZ3MucmVkaXJlY3RfdXJpLFxuICAgICAgICByZXNvdXJjZTogcmVxdWVzdEFyZ3MucmVzb3VyY2UsXG4gICAgICAgIGV4dHJhVG9rZW5QYXJhbXM6IHJlcXVlc3RBcmdzLmV4dHJhVG9rZW5QYXJhbXMsXG4gICAgICAgIHRpbWVvdXRJblNlY29uZHM6IHNpbGVudFJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzXG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IGRwb3BKa3Q7XG4gICAgaWYgKChfYSA9IHRoaXMuc2V0dGluZ3MuZHBvcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmJpbmRfYXV0aG9yaXphdGlvbl9jb2RlKSB7XG4gICAgICBkcG9wSmt0ID0gYXdhaXQgdGhpcy5nZW5lcmF0ZURQb1BKa3QodGhpcy5zZXR0aW5ncy5kcG9wKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gdGhpcy5zZXR0aW5ncy5zaWxlbnRfcmVkaXJlY3RfdXJpO1xuICAgIGlmICghdXJsKSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIk5vIHNpbGVudF9yZWRpcmVjdF91cmkgY29uZmlndXJlZFwiKSk7XG4gICAgfVxuICAgIGxldCB2ZXJpZnlTdWI7XG4gICAgaWYgKHVzZXIgJiYgdGhpcy5zZXR0aW5ncy52YWxpZGF0ZVN1Yk9uU2lsZW50UmVuZXcpIHtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJzdWJqZWN0IHByaW9yIHRvIHNpbGVudCByZW5ldzpcIiwgdXNlci5wcm9maWxlLnN1Yik7XG4gICAgICB2ZXJpZnlTdWIgPSB1c2VyLnByb2ZpbGUuc3ViO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGUgPSBhd2FpdCB0aGlzLl9pZnJhbWVOYXZpZ2F0b3IucHJlcGFyZSh7IHNpbGVudFJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzIH0pO1xuICAgIHVzZXIgPSBhd2FpdCB0aGlzLl9zaWduaW4oe1xuICAgICAgcmVxdWVzdF90eXBlOiBcInNpOnNcIixcbiAgICAgIHJlZGlyZWN0X3VyaTogdXJsLFxuICAgICAgcHJvbXB0OiBcIm5vbmVcIixcbiAgICAgIGlkX3Rva2VuX2hpbnQ6IHRoaXMuc2V0dGluZ3MuaW5jbHVkZUlkVG9rZW5JblNpbGVudFJlbmV3ID8gdXNlciA9PSBudWxsID8gdm9pZCAwIDogdXNlci5pZF90b2tlbiA6IHZvaWQgMCxcbiAgICAgIGRwb3BKa3QsXG4gICAgICAuLi5yZXF1ZXN0QXJnc1xuICAgIH0sIGhhbmRsZSwgdmVyaWZ5U3ViKTtcbiAgICBpZiAodXNlcikge1xuICAgICAgaWYgKChfYiA9IHVzZXIucHJvZmlsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnN1Yikge1xuICAgICAgICBsb2dnZXIyLmluZm8oXCJzdWNjZXNzLCBzaWduZWQgaW4gc3ViamVjdFwiLCB1c2VyLnByb2ZpbGUuc3ViKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlcjIuaW5mbyhcIm5vIHN1YmplY3RcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIGFzeW5jIF91c2VSZWZyZXNoVG9rZW4oYXJncykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fY2xpZW50LnVzZVJlZnJlc2hUb2tlbih7XG4gICAgICB0aW1lb3V0SW5TZWNvbmRzOiB0aGlzLnNldHRpbmdzLnNpbGVudFJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzLFxuICAgICAgLi4uYXJnc1xuICAgIH0pO1xuICAgIGNvbnN0IHVzZXIgPSBuZXcgVXNlcih7IC4uLmFyZ3Muc3RhdGUsIC4uLnJlc3BvbnNlIH0pO1xuICAgIGF3YWl0IHRoaXMuc3RvcmVVc2VyKHVzZXIpO1xuICAgIGF3YWl0IHRoaXMuX2V2ZW50cy5sb2FkKHVzZXIpO1xuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBOb3RpZnkgdGhlIHBhcmVudCB3aW5kb3cgb2YgcmVzcG9uc2UgKGNhbGxiYWNrKSBmcm9tIHRoZSBhdXRob3JpemF0aW9uIGVuZHBvaW50LlxuICAgKiBJdCBpcyByZWNvbW1lbmRlZCB0byB1c2Uge0BsaW5rIFVzZXJNYW5hZ2VyLnNpZ25pbkNhbGxiYWNrfSBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHByb21pc2VcbiAgICpcbiAgICogQHNlZSB7QGxpbmsgVXNlck1hbmFnZXIuc2lnbmluQ2FsbGJhY2t9XG4gICAqL1xuICBhc3luYyBzaWduaW5TaWxlbnRDYWxsYmFjayh1cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZikge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwic2lnbmluU2lsZW50Q2FsbGJhY2tcIik7XG4gICAgYXdhaXQgdGhpcy5faWZyYW1lTmF2aWdhdG9yLmNhbGxiYWNrKHVybCk7XG4gICAgbG9nZ2VyMi5pbmZvKFwic3VjY2Vzc1wiKTtcbiAgfVxuICAvKipcbiAgICogUHJvY2VzcyBhbnkgcmVzcG9uc2UgKGNhbGxiYWNrKSBmcm9tIHRoZSBhdXRob3JpemF0aW9uIGVuZHBvaW50LCBieSBkaXNwYXRjaGluZyB0aGUgcmVxdWVzdF90eXBlXG4gICAqIGFuZCBleGVjdXRpbmcgb25lIG9mIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zOlxuICAgKiAtIHtAbGluayBVc2VyTWFuYWdlci5zaWduaW5SZWRpcmVjdENhbGxiYWNrfVxuICAgKiAtIHtAbGluayBVc2VyTWFuYWdlci5zaWduaW5Qb3B1cENhbGxiYWNrfVxuICAgKiAtIHtAbGluayBVc2VyTWFuYWdlci5zaWduaW5TaWxlbnRDYWxsYmFja31cbiAgICpcbiAgICogQHRocm93cyBgRXJyb3JgIElmIHJlcXVlc3RfdHlwZSBpcyB1bmtub3duIG9yIHNpZ25pbiBjYW5ub3QgYmUgcHJvY2Vzc2VkLlxuICAgKi9cbiAgYXN5bmMgc2lnbmluQ2FsbGJhY2sodXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWYpIHtcbiAgICBjb25zdCB7IHN0YXRlIH0gPSBhd2FpdCB0aGlzLl9jbGllbnQucmVhZFNpZ25pblJlc3BvbnNlU3RhdGUodXJsKTtcbiAgICBzd2l0Y2ggKHN0YXRlLnJlcXVlc3RfdHlwZSkge1xuICAgICAgY2FzZSBcInNpOnJcIjpcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2lnbmluUmVkaXJlY3RDYWxsYmFjayh1cmwpO1xuICAgICAgY2FzZSBcInNpOnBcIjpcbiAgICAgICAgYXdhaXQgdGhpcy5zaWduaW5Qb3B1cENhbGxiYWNrKHVybCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNpOnNcIjpcbiAgICAgICAgYXdhaXQgdGhpcy5zaWduaW5TaWxlbnRDYWxsYmFjayh1cmwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcmVzcG9uc2VfdHlwZSBpbiBzdGF0ZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogUHJvY2VzcyBhbnkgcmVzcG9uc2UgKGNhbGxiYWNrKSBmcm9tIHRoZSBlbmQgc2Vzc2lvbiBlbmRwb2ludCwgYnkgZGlzcGF0Y2hpbmcgdGhlIHJlcXVlc3RfdHlwZVxuICAgKiBhbmQgZXhlY3V0aW5nIG9uZSBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9uczpcbiAgICogLSB7QGxpbmsgVXNlck1hbmFnZXIuc2lnbm91dFJlZGlyZWN0Q2FsbGJhY2t9XG4gICAqIC0ge0BsaW5rIFVzZXJNYW5hZ2VyLnNpZ25vdXRQb3B1cENhbGxiYWNrfVxuICAgKiAtIHtAbGluayBVc2VyTWFuYWdlci5zaWdub3V0U2lsZW50Q2FsbGJhY2t9XG4gICAqXG4gICAqIEB0aHJvd3MgYEVycm9yYCBJZiByZXF1ZXN0X3R5cGUgaXMgdW5rbm93biBvciBzaWdub3V0IGNhbm5vdCBiZSBwcm9jZXNzZWQuXG4gICAqL1xuICBhc3luYyBzaWdub3V0Q2FsbGJhY2sodXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWYsIGtlZXBPcGVuID0gZmFsc2UpIHtcbiAgICBjb25zdCB7IHN0YXRlIH0gPSBhd2FpdCB0aGlzLl9jbGllbnQucmVhZFNpZ25vdXRSZXNwb25zZVN0YXRlKHVybCk7XG4gICAgaWYgKCFzdGF0ZSkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgc3dpdGNoIChzdGF0ZS5yZXF1ZXN0X3R5cGUpIHtcbiAgICAgIGNhc2UgXCJzbzpyXCI6XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNpZ25vdXRSZWRpcmVjdENhbGxiYWNrKHVybCk7XG4gICAgICBjYXNlIFwic286cFwiOlxuICAgICAgICBhd2FpdCB0aGlzLnNpZ25vdXRQb3B1cENhbGxiYWNrKHVybCwga2VlcE9wZW4pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzbzpzXCI6XG4gICAgICAgIGF3YWl0IHRoaXMuc2lnbm91dFNpbGVudENhbGxiYWNrKHVybCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCByZXNwb25zZV90eXBlIGluIHN0YXRlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBRdWVyeSBPUCBmb3IgdXNlcidzIGN1cnJlbnQgc2lnbmluIHN0YXR1cy5cbiAgICpcbiAgICogQHJldHVybnMgQSBwcm9taXNlIG9iamVjdCB3aXRoIHNlc3Npb25fc3RhdGUgYW5kIHN1YmplY3QgaWRlbnRpZmllci5cbiAgICovXG4gIGFzeW5jIHF1ZXJ5U2Vzc2lvblN0YXR1cyhhcmdzID0ge30pIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInF1ZXJ5U2Vzc2lvblN0YXR1c1wiKTtcbiAgICBjb25zdCB7XG4gICAgICBzaWxlbnRSZXF1ZXN0VGltZW91dEluU2Vjb25kcyxcbiAgICAgIC4uLnJlcXVlc3RBcmdzXG4gICAgfSA9IGFyZ3M7XG4gICAgY29uc3QgdXJsID0gdGhpcy5zZXR0aW5ncy5zaWxlbnRfcmVkaXJlY3RfdXJpO1xuICAgIGlmICghdXJsKSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIk5vIHNpbGVudF9yZWRpcmVjdF91cmkgY29uZmlndXJlZFwiKSk7XG4gICAgfVxuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLl9sb2FkVXNlcigpO1xuICAgIGNvbnN0IGhhbmRsZSA9IGF3YWl0IHRoaXMuX2lmcmFtZU5hdmlnYXRvci5wcmVwYXJlKHsgc2lsZW50UmVxdWVzdFRpbWVvdXRJblNlY29uZHMgfSk7XG4gICAgY29uc3QgbmF2UmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9zaWduaW5TdGFydCh7XG4gICAgICByZXF1ZXN0X3R5cGU6IFwic2k6c1wiLFxuICAgICAgLy8gdGhpcyBhY3RzIGxpa2UgYSBzaWduaW4gc2lsZW50XG4gICAgICByZWRpcmVjdF91cmk6IHVybCxcbiAgICAgIHByb21wdDogXCJub25lXCIsXG4gICAgICBpZF90b2tlbl9oaW50OiB0aGlzLnNldHRpbmdzLmluY2x1ZGVJZFRva2VuSW5TaWxlbnRSZW5ldyA/IHVzZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHVzZXIuaWRfdG9rZW4gOiB2b2lkIDAsXG4gICAgICByZXNwb25zZV90eXBlOiB0aGlzLnNldHRpbmdzLnF1ZXJ5X3N0YXR1c19yZXNwb25zZV90eXBlLFxuICAgICAgc2NvcGU6IFwib3BlbmlkXCIsXG4gICAgICBza2lwVXNlckluZm86IHRydWUsXG4gICAgICAuLi5yZXF1ZXN0QXJnc1xuICAgIH0sIGhhbmRsZSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGV4dHJhSGVhZGVycyA9IHt9O1xuICAgICAgY29uc3Qgc2lnbmluUmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9jbGllbnQucHJvY2Vzc1NpZ25pblJlc3BvbnNlKG5hdlJlc3BvbnNlLnVybCwgZXh0cmFIZWFkZXJzKTtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJnb3Qgc2lnbmluIHJlc3BvbnNlXCIpO1xuICAgICAgaWYgKHNpZ25pblJlc3BvbnNlLnNlc3Npb25fc3RhdGUgJiYgc2lnbmluUmVzcG9uc2UucHJvZmlsZS5zdWIpIHtcbiAgICAgICAgbG9nZ2VyMi5pbmZvKFwic3VjY2VzcyBmb3Igc3ViamVjdFwiLCBzaWduaW5SZXNwb25zZS5wcm9maWxlLnN1Yik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc2Vzc2lvbl9zdGF0ZTogc2lnbmluUmVzcG9uc2Uuc2Vzc2lvbl9zdGF0ZSxcbiAgICAgICAgICBzdWI6IHNpZ25pblJlc3BvbnNlLnByb2ZpbGUuc3ViXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBsb2dnZXIyLmluZm8oXCJzdWNjZXNzLCB1c2VyIG5vdCBhdXRoZW50aWNhdGVkXCIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5tb25pdG9yQW5vbnltb3VzU2Vzc2lvbiAmJiBlcnIgaW5zdGFuY2VvZiBFcnJvclJlc3BvbnNlKSB7XG4gICAgICAgIHN3aXRjaCAoZXJyLmVycm9yKSB7XG4gICAgICAgICAgY2FzZSBcImxvZ2luX3JlcXVpcmVkXCI6XG4gICAgICAgICAgY2FzZSBcImNvbnNlbnRfcmVxdWlyZWRcIjpcbiAgICAgICAgICBjYXNlIFwiaW50ZXJhY3Rpb25fcmVxdWlyZWRcIjpcbiAgICAgICAgICBjYXNlIFwiYWNjb3VudF9zZWxlY3Rpb25fcmVxdWlyZWRcIjpcbiAgICAgICAgICAgIGxvZ2dlcjIuaW5mbyhcInN1Y2Nlc3MgZm9yIGFub255bW91cyB1c2VyXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc2Vzc2lvbl9zdGF0ZTogZXJyLnNlc3Npb25fc3RhdGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgX3NpZ25pbihhcmdzLCBoYW5kbGUsIHZlcmlmeVN1Yikge1xuICAgIGNvbnN0IG5hdlJlc3BvbnNlID0gYXdhaXQgdGhpcy5fc2lnbmluU3RhcnQoYXJncywgaGFuZGxlKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fc2lnbmluRW5kKG5hdlJlc3BvbnNlLnVybCwgdmVyaWZ5U3ViKTtcbiAgfVxuICBhc3luYyBfc2lnbmluU3RhcnQoYXJncywgaGFuZGxlKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJfc2lnbmluU3RhcnRcIik7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNpZ25pblJlcXVlc3QgPSBhd2FpdCB0aGlzLl9jbGllbnQuY3JlYXRlU2lnbmluUmVxdWVzdChhcmdzKTtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJnb3Qgc2lnbmluIHJlcXVlc3RcIik7XG4gICAgICByZXR1cm4gYXdhaXQgaGFuZGxlLm5hdmlnYXRlKHtcbiAgICAgICAgdXJsOiBzaWduaW5SZXF1ZXN0LnVybCxcbiAgICAgICAgc3RhdGU6IHNpZ25pblJlcXVlc3Quc3RhdGUuaWQsXG4gICAgICAgIHJlc3BvbnNlX21vZGU6IHNpZ25pblJlcXVlc3Quc3RhdGUucmVzcG9uc2VfbW9kZSxcbiAgICAgICAgc2NyaXB0T3JpZ2luOiB0aGlzLnNldHRpbmdzLmlmcmFtZVNjcmlwdE9yaWdpblxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwiZXJyb3IgYWZ0ZXIgcHJlcGFyaW5nIG5hdmlnYXRvciwgY2xvc2luZyBuYXZpZ2F0b3Igd2luZG93XCIpO1xuICAgICAgaGFuZGxlLmNsb3NlKCk7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG4gIGFzeW5jIF9zaWduaW5FbmQodXJsLCB2ZXJpZnlTdWIpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIl9zaWduaW5FbmRcIik7XG4gICAgY29uc3QgZXh0cmFIZWFkZXJzID0ge307XG4gICAgY29uc3Qgc2lnbmluUmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9jbGllbnQucHJvY2Vzc1NpZ25pblJlc3BvbnNlKHVybCwgZXh0cmFIZWFkZXJzKTtcbiAgICBsb2dnZXIyLmRlYnVnKFwiZ290IHNpZ25pbiByZXNwb25zZVwiKTtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5fYnVpbGRVc2VyKHNpZ25pblJlc3BvbnNlLCB2ZXJpZnlTdWIpO1xuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIGFzeW5jIF9idWlsZFVzZXIoc2lnbmluUmVzcG9uc2UsIHZlcmlmeVN1Yikge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiX2J1aWxkVXNlclwiKTtcbiAgICBjb25zdCB1c2VyID0gbmV3IFVzZXIoc2lnbmluUmVzcG9uc2UpO1xuICAgIGlmICh2ZXJpZnlTdWIpIHtcbiAgICAgIGlmICh2ZXJpZnlTdWIgIT09IHVzZXIucHJvZmlsZS5zdWIpIHtcbiAgICAgICAgbG9nZ2VyMi5kZWJ1ZyhcImN1cnJlbnQgdXNlciBkb2VzIG5vdCBtYXRjaCB1c2VyIHJldHVybmVkIGZyb20gc2lnbmluLiBzdWIgZnJvbSBzaWduaW46XCIsIHVzZXIucHJvZmlsZS5zdWIpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JSZXNwb25zZSh7IC4uLnNpZ25pblJlc3BvbnNlLCBlcnJvcjogXCJsb2dpbl9yZXF1aXJlZFwiIH0pO1xuICAgICAgfVxuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcImN1cnJlbnQgdXNlciBtYXRjaGVzIHVzZXIgcmV0dXJuZWQgZnJvbSBzaWduaW5cIik7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuc3RvcmVVc2VyKHVzZXIpO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJ1c2VyIHN0b3JlZFwiKTtcbiAgICBhd2FpdCB0aGlzLl9ldmVudHMubG9hZCh1c2VyKTtcbiAgICByZXR1cm4gdXNlcjtcbiAgfVxuICAvKipcbiAgICogVHJpZ2dlciBhIHJlZGlyZWN0IG9mIHRoZSBjdXJyZW50IHdpbmRvdyB0byB0aGUgZW5kIHNlc3Npb24gZW5kcG9pbnQuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZVxuICAgKi9cbiAgYXN5bmMgc2lnbm91dFJlZGlyZWN0KGFyZ3MgPSB7fSkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwic2lnbm91dFJlZGlyZWN0XCIpO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlZGlyZWN0TWV0aG9kLFxuICAgICAgLi4ucmVxdWVzdEFyZ3NcbiAgICB9ID0gYXJncztcbiAgICBjb25zdCBoYW5kbGUgPSBhd2FpdCB0aGlzLl9yZWRpcmVjdE5hdmlnYXRvci5wcmVwYXJlKHsgcmVkaXJlY3RNZXRob2QgfSk7XG4gICAgYXdhaXQgdGhpcy5fc2lnbm91dFN0YXJ0KHtcbiAgICAgIHJlcXVlc3RfdHlwZTogXCJzbzpyXCIsXG4gICAgICBwb3N0X2xvZ291dF9yZWRpcmVjdF91cmk6IHRoaXMuc2V0dGluZ3MucG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpLFxuICAgICAgLi4ucmVxdWVzdEFyZ3NcbiAgICB9LCBoYW5kbGUpO1xuICAgIGxvZ2dlcjIuaW5mbyhcInN1Y2Nlc3NcIik7XG4gIH1cbiAgLyoqXG4gICAqIFByb2Nlc3MgcmVzcG9uc2UgKGNhbGxiYWNrKSBmcm9tIHRoZSBlbmQgc2Vzc2lvbiBlbmRwb2ludC5cbiAgICogSXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIHtAbGluayBVc2VyTWFuYWdlci5zaWdub3V0Q2FsbGJhY2t9IGluc3RlYWQuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSBjb250YWluaW5nIHNpZ25vdXQgcmVzcG9uc2VcbiAgICpcbiAgICogQHNlZSB7QGxpbmsgVXNlck1hbmFnZXIuc2lnbm91dENhbGxiYWNrfVxuICAgKi9cbiAgYXN5bmMgc2lnbm91dFJlZGlyZWN0Q2FsbGJhY2sodXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWYpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInNpZ25vdXRSZWRpcmVjdENhbGxiYWNrXCIpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fc2lnbm91dEVuZCh1cmwpO1xuICAgIGxvZ2dlcjIuaW5mbyhcInN1Y2Nlc3NcIik7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIC8qKlxuICAgKiBUcmlnZ2VyIGEgcmVkaXJlY3Qgb2YgYSBwb3B1cCB3aW5kb3cgdG8gdGhlIGVuZCBzZXNzaW9uIGVuZHBvaW50LlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHByb21pc2VcbiAgICovXG4gIGFzeW5jIHNpZ25vdXRQb3B1cChhcmdzID0ge30pIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInNpZ25vdXRQb3B1cFwiKTtcbiAgICBjb25zdCB7XG4gICAgICBwb3B1cFdpbmRvd0ZlYXR1cmVzLFxuICAgICAgcG9wdXBXaW5kb3dUYXJnZXQsXG4gICAgICBwb3B1cFNpZ25hbCxcbiAgICAgIC4uLnJlcXVlc3RBcmdzXG4gICAgfSA9IGFyZ3M7XG4gICAgY29uc3QgdXJsID0gdGhpcy5zZXR0aW5ncy5wb3B1cF9wb3N0X2xvZ291dF9yZWRpcmVjdF91cmk7XG4gICAgY29uc3QgaGFuZGxlID0gYXdhaXQgdGhpcy5fcG9wdXBOYXZpZ2F0b3IucHJlcGFyZSh7IHBvcHVwV2luZG93RmVhdHVyZXMsIHBvcHVwV2luZG93VGFyZ2V0LCBwb3B1cFNpZ25hbCB9KTtcbiAgICBhd2FpdCB0aGlzLl9zaWdub3V0KHtcbiAgICAgIHJlcXVlc3RfdHlwZTogXCJzbzpwXCIsXG4gICAgICBwb3N0X2xvZ291dF9yZWRpcmVjdF91cmk6IHVybCxcbiAgICAgIC8vIHdlJ3JlIHB1dHRpbmcgYSBkdW1teSBlbnRyeSBpbiBoZXJlIGJlY2F1c2Ugd2VcbiAgICAgIC8vIG5lZWQgYSB1bmlxdWUgaWQgZnJvbSB0aGUgc3RhdGUgZm9yIG5vdGlmaWNhdGlvblxuICAgICAgLy8gdG8gdGhlIHBhcmVudCB3aW5kb3csIHdoaWNoIGlzIG5lY2Vzc2FyeSBpZiB3ZVxuICAgICAgLy8gcGxhbiB0byByZXR1cm4gYmFjayB0byB0aGUgY2xpZW50IGFmdGVyIHNpZ25vdXRcbiAgICAgIC8vIGFuZCBzbyB3ZSBjYW4gY2xvc2UgdGhlIHBvcHVwIGFmdGVyIHNpZ25vdXRcbiAgICAgIHN0YXRlOiB1cmwgPT0gbnVsbCA/IHZvaWQgMCA6IHt9LFxuICAgICAgLi4ucmVxdWVzdEFyZ3NcbiAgICB9LCBoYW5kbGUpO1xuICAgIGxvZ2dlcjIuaW5mbyhcInN1Y2Nlc3NcIik7XG4gIH1cbiAgLyoqXG4gICAqIFByb2Nlc3MgcmVzcG9uc2UgKGNhbGxiYWNrKSBmcm9tIHRoZSBlbmQgc2Vzc2lvbiBlbmRwb2ludCBmcm9tIGEgcG9wdXAgd2luZG93LlxuICAgKiBJdCBpcyByZWNvbW1lbmRlZCB0byB1c2Uge0BsaW5rIFVzZXJNYW5hZ2VyLnNpZ25vdXRDYWxsYmFja30gaW5zdGVhZC5cbiAgICpcbiAgICogQHJldHVybnMgQSBwcm9taXNlXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIFVzZXJNYW5hZ2VyLnNpZ25vdXRDYWxsYmFja31cbiAgICovXG4gIGFzeW5jIHNpZ25vdXRQb3B1cENhbGxiYWNrKHVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLCBrZWVwT3BlbiA9IGZhbHNlKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJzaWdub3V0UG9wdXBDYWxsYmFja1wiKTtcbiAgICBhd2FpdCB0aGlzLl9wb3B1cE5hdmlnYXRvci5jYWxsYmFjayh1cmwsIHsga2VlcE9wZW4gfSk7XG4gICAgbG9nZ2VyMi5pbmZvKFwic3VjY2Vzc1wiKTtcbiAgfVxuICBhc3luYyBfc2lnbm91dChhcmdzLCBoYW5kbGUpIHtcbiAgICBjb25zdCBuYXZSZXNwb25zZSA9IGF3YWl0IHRoaXMuX3NpZ25vdXRTdGFydChhcmdzLCBoYW5kbGUpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl9zaWdub3V0RW5kKG5hdlJlc3BvbnNlLnVybCk7XG4gIH1cbiAgYXN5bmMgX3NpZ25vdXRTdGFydChhcmdzID0ge30sIGhhbmRsZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIl9zaWdub3V0U3RhcnRcIik7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLl9sb2FkVXNlcigpO1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcImxvYWRlZCBjdXJyZW50IHVzZXIgZnJvbSBzdG9yYWdlXCIpO1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MucmV2b2tlVG9rZW5zT25TaWdub3V0KSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3Jldm9rZUludGVybmFsKHVzZXIpO1xuICAgICAgfVxuICAgICAgY29uc3QgaWRfdG9rZW4gPSBhcmdzLmlkX3Rva2VuX2hpbnQgfHwgdXNlciAmJiB1c2VyLmlkX3Rva2VuO1xuICAgICAgaWYgKGlkX3Rva2VuKSB7XG4gICAgICAgIGxvZ2dlcjIuZGVidWcoXCJzZXR0aW5nIGlkX3Rva2VuX2hpbnQgaW4gc2lnbm91dCByZXF1ZXN0XCIpO1xuICAgICAgICBhcmdzLmlkX3Rva2VuX2hpbnQgPSBpZF90b2tlbjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMucmVtb3ZlVXNlcigpO1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcInVzZXIgcmVtb3ZlZCwgY3JlYXRpbmcgc2lnbm91dCByZXF1ZXN0XCIpO1xuICAgICAgY29uc3Qgc2lnbm91dFJlcXVlc3QgPSBhd2FpdCB0aGlzLl9jbGllbnQuY3JlYXRlU2lnbm91dFJlcXVlc3QoYXJncyk7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwiZ290IHNpZ25vdXQgcmVxdWVzdFwiKTtcbiAgICAgIHJldHVybiBhd2FpdCBoYW5kbGUubmF2aWdhdGUoe1xuICAgICAgICB1cmw6IHNpZ25vdXRSZXF1ZXN0LnVybCxcbiAgICAgICAgc3RhdGU6IChfYSA9IHNpZ25vdXRSZXF1ZXN0LnN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaWQsXG4gICAgICAgIHNjcmlwdE9yaWdpbjogdGhpcy5zZXR0aW5ncy5pZnJhbWVTY3JpcHRPcmlnaW5cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcImVycm9yIGFmdGVyIHByZXBhcmluZyBuYXZpZ2F0b3IsIGNsb3NpbmcgbmF2aWdhdG9yIHdpbmRvd1wiKTtcbiAgICAgIGhhbmRsZS5jbG9zZSgpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuICBhc3luYyBfc2lnbm91dEVuZCh1cmwpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIl9zaWdub3V0RW5kXCIpO1xuICAgIGNvbnN0IHNpZ25vdXRSZXNwb25zZSA9IGF3YWl0IHRoaXMuX2NsaWVudC5wcm9jZXNzU2lnbm91dFJlc3BvbnNlKHVybCk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcImdvdCBzaWdub3V0IHJlc3BvbnNlXCIpO1xuICAgIHJldHVybiBzaWdub3V0UmVzcG9uc2U7XG4gIH1cbiAgLyoqXG4gICAqIFRyaWdnZXIgYSBzaWxlbnQgcmVxdWVzdCAodmlhIGFuIGlmcmFtZSkgdG8gdGhlIGVuZCBzZXNzaW9uIGVuZHBvaW50LlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHByb21pc2VcbiAgICovXG4gIGFzeW5jIHNpZ25vdXRTaWxlbnQoYXJncyA9IHt9KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwic2lnbm91dFNpbGVudFwiKTtcbiAgICBjb25zdCB7XG4gICAgICBzaWxlbnRSZXF1ZXN0VGltZW91dEluU2Vjb25kcyxcbiAgICAgIC4uLnJlcXVlc3RBcmdzXG4gICAgfSA9IGFyZ3M7XG4gICAgY29uc3QgaWRfdG9rZW5faGludCA9IHRoaXMuc2V0dGluZ3MuaW5jbHVkZUlkVG9rZW5JblNpbGVudFNpZ25vdXQgPyAoX2EgPSBhd2FpdCB0aGlzLl9sb2FkVXNlcigpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaWRfdG9rZW4gOiB2b2lkIDA7XG4gICAgY29uc3QgdXJsID0gdGhpcy5zZXR0aW5ncy5wb3B1cF9wb3N0X2xvZ291dF9yZWRpcmVjdF91cmk7XG4gICAgY29uc3QgaGFuZGxlID0gYXdhaXQgdGhpcy5faWZyYW1lTmF2aWdhdG9yLnByZXBhcmUoeyBzaWxlbnRSZXF1ZXN0VGltZW91dEluU2Vjb25kcyB9KTtcbiAgICBhd2FpdCB0aGlzLl9zaWdub3V0KHtcbiAgICAgIHJlcXVlc3RfdHlwZTogXCJzbzpzXCIsXG4gICAgICBwb3N0X2xvZ291dF9yZWRpcmVjdF91cmk6IHVybCxcbiAgICAgIGlkX3Rva2VuX2hpbnQsXG4gICAgICAuLi5yZXF1ZXN0QXJnc1xuICAgIH0sIGhhbmRsZSk7XG4gICAgbG9nZ2VyMi5pbmZvKFwic3VjY2Vzc1wiKTtcbiAgfVxuICAvKipcbiAgICogTm90aWZ5IHRoZSBwYXJlbnQgd2luZG93IG9mIHJlc3BvbnNlIChjYWxsYmFjaykgZnJvbSB0aGUgZW5kIHNlc3Npb24gZW5kcG9pbnQuXG4gICAqIEl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSB7QGxpbmsgVXNlck1hbmFnZXIuc2lnbm91dENhbGxiYWNrfSBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHByb21pc2VcbiAgICpcbiAgICogQHNlZSB7QGxpbmsgVXNlck1hbmFnZXIuc2lnbm91dENhbGxiYWNrfVxuICAgKi9cbiAgYXN5bmMgc2lnbm91dFNpbGVudENhbGxiYWNrKHVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJzaWdub3V0U2lsZW50Q2FsbGJhY2tcIik7XG4gICAgYXdhaXQgdGhpcy5faWZyYW1lTmF2aWdhdG9yLmNhbGxiYWNrKHVybCk7XG4gICAgbG9nZ2VyMi5pbmZvKFwic3VjY2Vzc1wiKTtcbiAgfVxuICBhc3luYyByZXZva2VUb2tlbnModHlwZXMpIHtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5fbG9hZFVzZXIoKTtcbiAgICBhd2FpdCB0aGlzLl9yZXZva2VJbnRlcm5hbCh1c2VyLCB0eXBlcyk7XG4gIH1cbiAgYXN5bmMgX3Jldm9rZUludGVybmFsKHVzZXIsIHR5cGVzID0gdGhpcy5zZXR0aW5ncy5yZXZva2VUb2tlblR5cGVzKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJfcmV2b2tlSW50ZXJuYWxcIik7XG4gICAgaWYgKCF1c2VyKSByZXR1cm47XG4gICAgY29uc3QgdHlwZXNQcmVzZW50ID0gdHlwZXMuZmlsdGVyKCh0eXBlKSA9PiB0eXBlb2YgdXNlclt0eXBlXSA9PT0gXCJzdHJpbmdcIik7XG4gICAgaWYgKCF0eXBlc1ByZXNlbnQubGVuZ3RoKSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwibm8gbmVlZCB0byByZXZva2UgZHVlIHRvIG5vIHRva2VuKHMpXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdHlwZXNQcmVzZW50KSB7XG4gICAgICBhd2FpdCB0aGlzLl9jbGllbnQucmV2b2tlVG9rZW4oXG4gICAgICAgIHVzZXJbdHlwZV0sXG4gICAgICAgIHR5cGVcbiAgICAgICk7XG4gICAgICBsb2dnZXIyLmluZm8oYCR7dHlwZX0gcmV2b2tlZCBzdWNjZXNzZnVsbHlgKTtcbiAgICAgIGlmICh0eXBlICE9PSBcImFjY2Vzc190b2tlblwiKSB7XG4gICAgICAgIHVzZXJbdHlwZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBhd2FpdCB0aGlzLnN0b3JlVXNlcih1c2VyKTtcbiAgICBsb2dnZXIyLmRlYnVnKFwidXNlciBzdG9yZWRcIik7XG4gICAgYXdhaXQgdGhpcy5fZXZlbnRzLmxvYWQodXNlcik7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgc2lsZW50IHJlbmV3IGZvciB0aGUgYFVzZXJNYW5hZ2VyYC5cbiAgICovXG4gIHN0YXJ0U2lsZW50UmVuZXcoKSB7XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInN0YXJ0U2lsZW50UmVuZXdcIik7XG4gICAgdm9pZCB0aGlzLl9zaWxlbnRSZW5ld1NlcnZpY2Uuc3RhcnQoKTtcbiAgfVxuICAvKipcbiAgICogRGlzYWJsZXMgc2lsZW50IHJlbmV3IGZvciB0aGUgYFVzZXJNYW5hZ2VyYC5cbiAgICovXG4gIHN0b3BTaWxlbnRSZW5ldygpIHtcbiAgICB0aGlzLl9zaWxlbnRSZW5ld1NlcnZpY2Uuc3RvcCgpO1xuICB9XG4gIGdldCBfdXNlclN0b3JlS2V5KCkge1xuICAgIHJldHVybiBgdXNlcjoke3RoaXMuc2V0dGluZ3MuYXV0aG9yaXR5fToke3RoaXMuc2V0dGluZ3MuY2xpZW50X2lkfWA7XG4gIH1cbiAgYXN5bmMgX2xvYWRVc2VyKCkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiX2xvYWRVc2VyXCIpO1xuICAgIGNvbnN0IHN0b3JhZ2VTdHJpbmcgPSBhd2FpdCB0aGlzLnNldHRpbmdzLnVzZXJTdG9yZS5nZXQodGhpcy5fdXNlclN0b3JlS2V5KTtcbiAgICBpZiAoc3RvcmFnZVN0cmluZykge1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcInVzZXIgc3RvcmFnZVN0cmluZyBsb2FkZWRcIik7XG4gICAgICByZXR1cm4gVXNlci5mcm9tU3RvcmFnZVN0cmluZyhzdG9yYWdlU3RyaW5nKTtcbiAgICB9XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcIm5vIHVzZXIgc3RvcmFnZVN0cmluZ1wiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBhc3luYyBzdG9yZVVzZXIodXNlcikge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwic3RvcmVVc2VyXCIpO1xuICAgIGlmICh1c2VyKSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwic3RvcmluZyB1c2VyXCIpO1xuICAgICAgY29uc3Qgc3RvcmFnZVN0cmluZyA9IHVzZXIudG9TdG9yYWdlU3RyaW5nKCk7XG4gICAgICBhd2FpdCB0aGlzLnNldHRpbmdzLnVzZXJTdG9yZS5zZXQodGhpcy5fdXNlclN0b3JlS2V5LCBzdG9yYWdlU3RyaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwicmVtb3ZpbmcgdXNlclwiKTtcbiAgICAgIGF3YWl0IHRoaXMuc2V0dGluZ3MudXNlclN0b3JlLnJlbW92ZSh0aGlzLl91c2VyU3RvcmVLZXkpO1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZHBvcCkge1xuICAgICAgICBhd2FpdCB0aGlzLnNldHRpbmdzLmRwb3Auc3RvcmUucmVtb3ZlKHRoaXMuc2V0dGluZ3MuY2xpZW50X2lkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgc3RhbGUgc3RhdGUgZW50cmllcyBpbiBzdG9yYWdlIGZvciBpbmNvbXBsZXRlIGF1dGhvcml6ZSByZXF1ZXN0cy5cbiAgICovXG4gIGFzeW5jIGNsZWFyU3RhbGVTdGF0ZSgpIHtcbiAgICBhd2FpdCB0aGlzLl9jbGllbnQuY2xlYXJTdGFsZVN0YXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIER5bmFtaWNhbGx5IGdlbmVyYXRlcyBhIERQb1AgcHJvb2YgZm9yIGEgZ2l2ZW4gdXNlciwgVVJMIGFuZCBvcHRpb25hbCBIdHRwIG1ldGhvZC5cbiAgICogVGhpcyBtZXRob2QgaXMgdXNlZnVsIHdoZW4geW91IG5lZWQgdG8gbWFrZSBhIHJlcXVlc3QgdG8gYSByZXNvdXJjZSBzZXJ2ZXJcbiAgICogd2l0aCBmZXRjaCBvciBzaW1pbGFyLCBhbmQgeW91IG5lZWQgdG8gaW5jbHVkZSBhIERQb1AgcHJvb2YgaW4gYSBEUG9QIGhlYWRlci5cbiAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gZ2VuZXJhdGUgdGhlIERQb1AgcHJvb2YgZm9yXG4gICAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIgdG8gZ2VuZXJhdGUgdGhlIERQb1AgcHJvb2YgZm9yXG4gICAqIEBwYXJhbSBodHRwTWV0aG9kIC0gT3B0aW9uYWwsIGRlZmF1bHRzIHRvIFwiR0VUXCJcbiAgICogQHBhcmFtIG5vbmNlIC0gT3B0aW9uYWwgbm9uY2UgcHJvdmlkZWQgYnkgdGhlIHJlc291cmNlIHNlcnZlclxuICAgKlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgY29udGFpbmluZyB0aGUgRFBvUCBwcm9vZiBvciB1bmRlZmluZWQgaWYgRFBvUCBpcyBub3QgZW5hYmxlZC9ubyB1c2VyIGlzIGZvdW5kLlxuICAgKi9cbiAgYXN5bmMgZHBvcFByb29mKHVybCwgdXNlciwgaHR0cE1ldGhvZCwgbm9uY2UpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGRwb3BTdGF0ZSA9IGF3YWl0ICgoX2IgPSAoX2EgPSB0aGlzLnNldHRpbmdzLmRwb3ApID09IG51bGwgPyB2b2lkIDAgOiBfYS5zdG9yZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmdldCh0aGlzLnNldHRpbmdzLmNsaWVudF9pZCkpO1xuICAgIGlmIChkcG9wU3RhdGUpIHtcbiAgICAgIHJldHVybiBhd2FpdCBDcnlwdG9VdGlscy5nZW5lcmF0ZURQb1BQcm9vZih7XG4gICAgICAgIHVybCxcbiAgICAgICAgYWNjZXNzVG9rZW46IHVzZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHVzZXIuYWNjZXNzX3Rva2VuLFxuICAgICAgICBodHRwTWV0aG9kLFxuICAgICAgICBrZXlQYWlyOiBkcG9wU3RhdGUua2V5cyxcbiAgICAgICAgbm9uY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGFzeW5jIGdlbmVyYXRlRFBvUEprdChkcG9wU2V0dGluZ3MpIHtcbiAgICBsZXQgZHBvcFN0YXRlID0gYXdhaXQgZHBvcFNldHRpbmdzLnN0b3JlLmdldCh0aGlzLnNldHRpbmdzLmNsaWVudF9pZCk7XG4gICAgaWYgKCFkcG9wU3RhdGUpIHtcbiAgICAgIGNvbnN0IGRwb3BLZXlzID0gYXdhaXQgQ3J5cHRvVXRpbHMuZ2VuZXJhdGVEUG9QS2V5cygpO1xuICAgICAgZHBvcFN0YXRlID0gbmV3IERQb1BTdGF0ZShkcG9wS2V5cyk7XG4gICAgICBhd2FpdCBkcG9wU2V0dGluZ3Muc3RvcmUuc2V0KHRoaXMuc2V0dGluZ3MuY2xpZW50X2lkLCBkcG9wU3RhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgQ3J5cHRvVXRpbHMuZ2VuZXJhdGVEUG9QSmt0KGRwb3BTdGF0ZS5rZXlzKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZS5qc29uXG52YXIgdmVyc2lvbiA9IFwiMy4zLjBcIjtcblxuLy8gc3JjL1ZlcnNpb24udHNcbnZhciBWZXJzaW9uID0gdmVyc2lvbjtcblxuLy8gc3JjL0luZGV4ZWREYkRQb1BTdG9yZS50c1xudmFyIEluZGV4ZWREYkRQb1BTdG9yZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fZGJOYW1lID0gXCJvaWRjXCI7XG4gICAgdGhpcy5fc3RvcmVOYW1lID0gXCJkcG9wXCI7XG4gIH1cbiAgYXN5bmMgc2V0KGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBzdG9yZSA9IGF3YWl0IHRoaXMuY3JlYXRlU3RvcmUodGhpcy5fZGJOYW1lLCB0aGlzLl9zdG9yZU5hbWUpO1xuICAgIGF3YWl0IHN0b3JlKFwicmVhZHdyaXRlXCIsIChzdHIpID0+IHtcbiAgICAgIHN0ci5wdXQodmFsdWUsIGtleSk7XG4gICAgICByZXR1cm4gdGhpcy5wcm9taXNpZnlSZXF1ZXN0KHN0ci50cmFuc2FjdGlvbik7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0KGtleSkge1xuICAgIGNvbnN0IHN0b3JlID0gYXdhaXQgdGhpcy5jcmVhdGVTdG9yZSh0aGlzLl9kYk5hbWUsIHRoaXMuX3N0b3JlTmFtZSk7XG4gICAgcmV0dXJuIGF3YWl0IHN0b3JlKFwicmVhZG9ubHlcIiwgKHN0cikgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMucHJvbWlzaWZ5UmVxdWVzdChzdHIuZ2V0KGtleSkpO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIHJlbW92ZShrZXkpIHtcbiAgICBjb25zdCBpdGVtID0gYXdhaXQgdGhpcy5nZXQoa2V5KTtcbiAgICBjb25zdCBzdG9yZSA9IGF3YWl0IHRoaXMuY3JlYXRlU3RvcmUodGhpcy5fZGJOYW1lLCB0aGlzLl9zdG9yZU5hbWUpO1xuICAgIGF3YWl0IHN0b3JlKFwicmVhZHdyaXRlXCIsIChzdHIpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLnByb21pc2lmeVJlcXVlc3Qoc3RyLmRlbGV0ZShrZXkpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuICBhc3luYyBnZXRBbGxLZXlzKCkge1xuICAgIGNvbnN0IHN0b3JlID0gYXdhaXQgdGhpcy5jcmVhdGVTdG9yZSh0aGlzLl9kYk5hbWUsIHRoaXMuX3N0b3JlTmFtZSk7XG4gICAgcmV0dXJuIGF3YWl0IHN0b3JlKFwicmVhZG9ubHlcIiwgKHN0cikgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMucHJvbWlzaWZ5UmVxdWVzdChzdHIuZ2V0QWxsS2V5cygpKTtcbiAgICB9KTtcbiAgfVxuICBwcm9taXNpZnlSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmVxdWVzdC5vbmNvbXBsZXRlID0gcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKHJlcXVlc3QucmVzdWx0KTtcbiAgICAgIHJlcXVlc3Qub25hYm9ydCA9IHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBjcmVhdGVTdG9yZShkYk5hbWUsIHN0b3JlTmFtZSkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIub3BlbihkYk5hbWUpO1xuICAgIHJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gKCkgPT4gcmVxdWVzdC5yZXN1bHQuY3JlYXRlT2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICBjb25zdCBkYiA9IGF3YWl0IHRoaXMucHJvbWlzaWZ5UmVxdWVzdChyZXF1ZXN0KTtcbiAgICByZXR1cm4gYXN5bmMgKHR4TW9kZSwgY2FsbGJhY2spID0+IHtcbiAgICAgIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oc3RvcmVOYW1lLCB0eE1vZGUpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB0eC5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgICAgcmV0dXJuIGF3YWl0IGNhbGxiYWNrKHN0b3JlKTtcbiAgICB9O1xuICB9XG59O1xuZXhwb3J0IHtcbiAgQWNjZXNzVG9rZW5FdmVudHMsXG4gIENoZWNrU2Vzc2lvbklGcmFtZSxcbiAgRFBvUFN0YXRlLFxuICBFcnJvclJlc3BvbnNlLFxuICBFcnJvclRpbWVvdXQsXG4gIEluTWVtb3J5V2ViU3RvcmFnZSxcbiAgSW5kZXhlZERiRFBvUFN0b3JlLFxuICBMb2csXG4gIExvZ2dlcixcbiAgTWV0YWRhdGFTZXJ2aWNlLFxuICBPaWRjQ2xpZW50LFxuICBPaWRjQ2xpZW50U2V0dGluZ3NTdG9yZSxcbiAgU2Vzc2lvbk1vbml0b3IsXG4gIFNpZ25pblJlc3BvbnNlLFxuICBTaWduaW5TdGF0ZSxcbiAgU2lnbm91dFJlc3BvbnNlLFxuICBTdGF0ZSxcbiAgVXNlcixcbiAgVXNlck1hbmFnZXIsXG4gIFVzZXJNYW5hZ2VyU2V0dGluZ3NTdG9yZSxcbiAgVmVyc2lvbixcbiAgV2ViU3RvcmFnZVN0YXRlU3RvcmVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vaWRjLWNsaWVudC10cy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/oidc-client-ts/dist/esm/oidc-client-ts.js\n");

/***/ })

};
;