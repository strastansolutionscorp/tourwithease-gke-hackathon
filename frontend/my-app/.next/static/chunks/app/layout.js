/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/layout"],{

/***/ "(app-pages-browser)/../../node_modules/crypto-js/core.js":
/*!********************************************!*\
  !*** ../../node_modules/crypto-js/core.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory();\n\t}\n\telse {}\n}(this, function () {\n\n\t/*globals window, global, require*/\n\n\t/**\n\t * CryptoJS core components.\n\t */\n\tvar CryptoJS = CryptoJS || (function (Math, undefined) {\n\n\t    var crypto;\n\n\t    // Native crypto from window (Browser)\n\t    if (typeof window !== 'undefined' && window.crypto) {\n\t        crypto = window.crypto;\n\t    }\n\n\t    // Native crypto in web worker (Browser)\n\t    if (typeof self !== 'undefined' && self.crypto) {\n\t        crypto = self.crypto;\n\t    }\n\n\t    // Native crypto from worker\n\t    if (typeof globalThis !== 'undefined' && globalThis.crypto) {\n\t        crypto = globalThis.crypto;\n\t    }\n\n\t    // Native (experimental IE 11) crypto from window (Browser)\n\t    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {\n\t        crypto = window.msCrypto;\n\t    }\n\n\t    // Native crypto from global (NodeJS)\n\t    if (!crypto && typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.crypto) {\n\t        crypto = __webpack_require__.g.crypto;\n\t    }\n\n\t    // Native crypto import via require (NodeJS)\n\t    if (!crypto && \"function\" === 'function') {\n\t        try {\n\t            crypto = __webpack_require__(/*! crypto */ \"?8495\");\n\t        } catch (err) {}\n\t    }\n\n\t    /*\n\t     * Cryptographically secure pseudorandom number generator\n\t     *\n\t     * As Math.random() is cryptographically not safe to use\n\t     */\n\t    var cryptoSecureRandomInt = function () {\n\t        if (crypto) {\n\t            // Use getRandomValues method (Browser)\n\t            if (typeof crypto.getRandomValues === 'function') {\n\t                try {\n\t                    return crypto.getRandomValues(new Uint32Array(1))[0];\n\t                } catch (err) {}\n\t            }\n\n\t            // Use randomBytes method (NodeJS)\n\t            if (typeof crypto.randomBytes === 'function') {\n\t                try {\n\t                    return crypto.randomBytes(4).readInt32LE();\n\t                } catch (err) {}\n\t            }\n\t        }\n\n\t        throw new Error('Native crypto module could not be used to get secure random number.');\n\t    };\n\n\t    /*\n\t     * Local polyfill of Object.create\n\n\t     */\n\t    var create = Object.create || (function () {\n\t        function F() {}\n\n\t        return function (obj) {\n\t            var subtype;\n\n\t            F.prototype = obj;\n\n\t            subtype = new F();\n\n\t            F.prototype = null;\n\n\t            return subtype;\n\t        };\n\t    }());\n\n\t    /**\n\t     * CryptoJS namespace.\n\t     */\n\t    var C = {};\n\n\t    /**\n\t     * Library namespace.\n\t     */\n\t    var C_lib = C.lib = {};\n\n\t    /**\n\t     * Base object for prototypal inheritance.\n\t     */\n\t    var Base = C_lib.Base = (function () {\n\n\n\t        return {\n\t            /**\n\t             * Creates a new object that inherits from this object.\n\t             *\n\t             * @param {Object} overrides Properties to copy into the new object.\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         field: 'value',\n\t             *\n\t             *         method: function () {\n\t             *         }\n\t             *     });\n\t             */\n\t            extend: function (overrides) {\n\t                // Spawn\n\t                var subtype = create(this);\n\n\t                // Augment\n\t                if (overrides) {\n\t                    subtype.mixIn(overrides);\n\t                }\n\n\t                // Create default initializer\n\t                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {\n\t                    subtype.init = function () {\n\t                        subtype.$super.init.apply(this, arguments);\n\t                    };\n\t                }\n\n\t                // Initializer's prototype is the subtype object\n\t                subtype.init.prototype = subtype;\n\n\t                // Reference supertype\n\t                subtype.$super = this;\n\n\t                return subtype;\n\t            },\n\n\t            /**\n\t             * Extends this object and runs the init method.\n\t             * Arguments to create() will be passed to init().\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var instance = MyType.create();\n\t             */\n\t            create: function () {\n\t                var instance = this.extend();\n\t                instance.init.apply(instance, arguments);\n\n\t                return instance;\n\t            },\n\n\t            /**\n\t             * Initializes a newly created object.\n\t             * Override this method to add some logic when your objects are created.\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         init: function () {\n\t             *             // ...\n\t             *         }\n\t             *     });\n\t             */\n\t            init: function () {\n\t            },\n\n\t            /**\n\t             * Copies properties into this object.\n\t             *\n\t             * @param {Object} properties The properties to mix in.\n\t             *\n\t             * @example\n\t             *\n\t             *     MyType.mixIn({\n\t             *         field: 'value'\n\t             *     });\n\t             */\n\t            mixIn: function (properties) {\n\t                for (var propertyName in properties) {\n\t                    if (properties.hasOwnProperty(propertyName)) {\n\t                        this[propertyName] = properties[propertyName];\n\t                    }\n\t                }\n\n\t                // IE won't copy toString using the loop above\n\t                if (properties.hasOwnProperty('toString')) {\n\t                    this.toString = properties.toString;\n\t                }\n\t            },\n\n\t            /**\n\t             * Creates a copy of this object.\n\t             *\n\t             * @return {Object} The clone.\n\t             *\n\t             * @example\n\t             *\n\t             *     var clone = instance.clone();\n\t             */\n\t            clone: function () {\n\t                return this.init.prototype.extend(this);\n\t            }\n\t        };\n\t    }());\n\n\t    /**\n\t     * An array of 32-bit words.\n\t     *\n\t     * @property {Array} words The array of 32-bit words.\n\t     * @property {number} sigBytes The number of significant bytes in this word array.\n\t     */\n\t    var WordArray = C_lib.WordArray = Base.extend({\n\t        /**\n\t         * Initializes a newly created word array.\n\t         *\n\t         * @param {Array} words (Optional) An array of 32-bit words.\n\t         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.create();\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n\t         */\n\t        init: function (words, sigBytes) {\n\t            words = this.words = words || [];\n\n\t            if (sigBytes != undefined) {\n\t                this.sigBytes = sigBytes;\n\t            } else {\n\t                this.sigBytes = words.length * 4;\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts this word array to a string.\n\t         *\n\t         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n\t         *\n\t         * @return {string} The stringified word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     var string = wordArray + '';\n\t         *     var string = wordArray.toString();\n\t         *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n\t         */\n\t        toString: function (encoder) {\n\t            return (encoder || Hex).stringify(this);\n\t        },\n\n\t        /**\n\t         * Concatenates a word array to this word array.\n\t         *\n\t         * @param {WordArray} wordArray The word array to append.\n\t         *\n\t         * @return {WordArray} This word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray1.concat(wordArray2);\n\t         */\n\t        concat: function (wordArray) {\n\t            // Shortcuts\n\t            var thisWords = this.words;\n\t            var thatWords = wordArray.words;\n\t            var thisSigBytes = this.sigBytes;\n\t            var thatSigBytes = wordArray.sigBytes;\n\n\t            // Clamp excess bits\n\t            this.clamp();\n\n\t            // Concat\n\t            if (thisSigBytes % 4) {\n\t                // Copy one byte at a time\n\t                for (var i = 0; i < thatSigBytes; i++) {\n\t                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n\t                }\n\t            } else {\n\t                // Copy one word at a time\n\t                for (var j = 0; j < thatSigBytes; j += 4) {\n\t                    thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];\n\t                }\n\t            }\n\t            this.sigBytes += thatSigBytes;\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Removes insignificant bits.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray.clamp();\n\t         */\n\t        clamp: function () {\n\t            // Shortcuts\n\t            var words = this.words;\n\t            var sigBytes = this.sigBytes;\n\n\t            // Clamp\n\t            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n\t            words.length = Math.ceil(sigBytes / 4);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this word array.\n\t         *\n\t         * @return {WordArray} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = wordArray.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone.words = this.words.slice(0);\n\n\t            return clone;\n\t        },\n\n\t        /**\n\t         * Creates a word array filled with random bytes.\n\t         *\n\t         * @param {number} nBytes The number of random bytes to generate.\n\t         *\n\t         * @return {WordArray} The random word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.random(16);\n\t         */\n\t        random: function (nBytes) {\n\t            var words = [];\n\n\t            for (var i = 0; i < nBytes; i += 4) {\n\t                words.push(cryptoSecureRandomInt());\n\t            }\n\n\t            return new WordArray.init(words, nBytes);\n\t        }\n\t    });\n\n\t    /**\n\t     * Encoder namespace.\n\t     */\n\t    var C_enc = C.enc = {};\n\n\t    /**\n\t     * Hex encoding strategy.\n\t     */\n\t    var Hex = C_enc.Hex = {\n\t        /**\n\t         * Converts a word array to a hex string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The hex string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var hexChars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                hexChars.push((bite >>> 4).toString(16));\n\t                hexChars.push((bite & 0x0f).toString(16));\n\t            }\n\n\t            return hexChars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a hex string to a word array.\n\t         *\n\t         * @param {string} hexStr The hex string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n\t         */\n\t        parse: function (hexStr) {\n\t            // Shortcut\n\t            var hexStrLength = hexStr.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < hexStrLength; i += 2) {\n\t                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n\t            }\n\n\t            return new WordArray.init(words, hexStrLength / 2);\n\t        }\n\t    };\n\n\t    /**\n\t     * Latin1 encoding strategy.\n\t     */\n\t    var Latin1 = C_enc.Latin1 = {\n\t        /**\n\t         * Converts a word array to a Latin1 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The Latin1 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var latin1Chars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                latin1Chars.push(String.fromCharCode(bite));\n\t            }\n\n\t            return latin1Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a Latin1 string to a word array.\n\t         *\n\t         * @param {string} latin1Str The Latin1 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n\t         */\n\t        parse: function (latin1Str) {\n\t            // Shortcut\n\t            var latin1StrLength = latin1Str.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < latin1StrLength; i++) {\n\t                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n\t            }\n\n\t            return new WordArray.init(words, latin1StrLength);\n\t        }\n\t    };\n\n\t    /**\n\t     * UTF-8 encoding strategy.\n\t     */\n\t    var Utf8 = C_enc.Utf8 = {\n\t        /**\n\t         * Converts a word array to a UTF-8 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The UTF-8 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            try {\n\t                return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n\t            } catch (e) {\n\t                throw new Error('Malformed UTF-8 data');\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts a UTF-8 string to a word array.\n\t         *\n\t         * @param {string} utf8Str The UTF-8 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n\t         */\n\t        parse: function (utf8Str) {\n\t            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n\t        }\n\t    };\n\n\t    /**\n\t     * Abstract buffered block algorithm template.\n\t     *\n\t     * The property blockSize must be implemented in a concrete subtype.\n\t     *\n\t     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0\n\t     */\n\t    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n\t        /**\n\t         * Resets this block algorithm's data buffer to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm.reset();\n\t         */\n\t        reset: function () {\n\t            // Initial values\n\t            this._data = new WordArray.init();\n\t            this._nDataBytes = 0;\n\t        },\n\n\t        /**\n\t         * Adds new data to this block algorithm's buffer.\n\t         *\n\t         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm._append('data');\n\t         *     bufferedBlockAlgorithm._append(wordArray);\n\t         */\n\t        _append: function (data) {\n\t            // Convert string to WordArray, else assume WordArray already\n\t            if (typeof data == 'string') {\n\t                data = Utf8.parse(data);\n\t            }\n\n\t            // Append\n\t            this._data.concat(data);\n\t            this._nDataBytes += data.sigBytes;\n\t        },\n\n\t        /**\n\t         * Processes available data blocks.\n\t         *\n\t         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n\t         *\n\t         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n\t         *\n\t         * @return {WordArray} The processed data.\n\t         *\n\t         * @example\n\t         *\n\t         *     var processedData = bufferedBlockAlgorithm._process();\n\t         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\n\t         */\n\t        _process: function (doFlush) {\n\t            var processedWords;\n\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\t            var dataSigBytes = data.sigBytes;\n\t            var blockSize = this.blockSize;\n\t            var blockSizeBytes = blockSize * 4;\n\n\t            // Count blocks ready\n\t            var nBlocksReady = dataSigBytes / blockSizeBytes;\n\t            if (doFlush) {\n\t                // Round up to include partial blocks\n\t                nBlocksReady = Math.ceil(nBlocksReady);\n\t            } else {\n\t                // Round down to include only full blocks,\n\t                // less the number of blocks that must remain in the buffer\n\t                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n\t            }\n\n\t            // Count words ready\n\t            var nWordsReady = nBlocksReady * blockSize;\n\n\t            // Count bytes ready\n\t            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n\t            // Process blocks\n\t            if (nWordsReady) {\n\t                for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n\t                    // Perform concrete-algorithm logic\n\t                    this._doProcessBlock(dataWords, offset);\n\t                }\n\n\t                // Remove processed words\n\t                processedWords = dataWords.splice(0, nWordsReady);\n\t                data.sigBytes -= nBytesReady;\n\t            }\n\n\t            // Return processed words\n\t            return new WordArray.init(processedWords, nBytesReady);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this object.\n\t         *\n\t         * @return {Object} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = bufferedBlockAlgorithm.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone._data = this._data.clone();\n\n\t            return clone;\n\t        },\n\n\t        _minBufferSize: 0\n\t    });\n\n\t    /**\n\t     * Abstract hasher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n\t     */\n\t    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n\t        /**\n\t         * Configuration options.\n\t         */\n\t        cfg: Base.extend(),\n\n\t        /**\n\t         * Initializes a newly created hasher.\n\t         *\n\t         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hasher = CryptoJS.algo.SHA256.create();\n\t         */\n\t        init: function (cfg) {\n\t            // Apply config defaults\n\t            this.cfg = this.cfg.extend(cfg);\n\n\t            // Set initial values\n\t            this.reset();\n\t        },\n\n\t        /**\n\t         * Resets this hasher to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.reset();\n\t         */\n\t        reset: function () {\n\t            // Reset data buffer\n\t            BufferedBlockAlgorithm.reset.call(this);\n\n\t            // Perform concrete-hasher logic\n\t            this._doReset();\n\t        },\n\n\t        /**\n\t         * Updates this hasher with a message.\n\t         *\n\t         * @param {WordArray|string} messageUpdate The message to append.\n\t         *\n\t         * @return {Hasher} This hasher.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.update('message');\n\t         *     hasher.update(wordArray);\n\t         */\n\t        update: function (messageUpdate) {\n\t            // Append\n\t            this._append(messageUpdate);\n\n\t            // Update the hash\n\t            this._process();\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Finalizes the hash computation.\n\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t         *\n\t         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n\t         *\n\t         * @return {WordArray} The hash.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hash = hasher.finalize();\n\t         *     var hash = hasher.finalize('message');\n\t         *     var hash = hasher.finalize(wordArray);\n\t         */\n\t        finalize: function (messageUpdate) {\n\t            // Final message update\n\t            if (messageUpdate) {\n\t                this._append(messageUpdate);\n\t            }\n\n\t            // Perform concrete-hasher logic\n\t            var hash = this._doFinalize();\n\n\t            return hash;\n\t        },\n\n\t        blockSize: 512/32,\n\n\t        /**\n\t         * Creates a shortcut function to a hasher's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to create a helper for.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHelper: function (hasher) {\n\t            return function (message, cfg) {\n\t                return new hasher.init(cfg).finalize(message);\n\t            };\n\t        },\n\n\t        /**\n\t         * Creates a shortcut function to the HMAC's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to use in this HMAC helper.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHmacHelper: function (hasher) {\n\t            return function (message, key) {\n\t                return new C_algo.HMAC.init(hasher, key).finalize(message);\n\t            };\n\t        }\n\t    });\n\n\t    /**\n\t     * Algorithm namespace.\n\t     */\n\t    var C_algo = C.algo = {};\n\n\t    return C;\n\t}(Math));\n\n\n\treturn CryptoJS;\n\n}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NvcmUuanMiLCJtYXBwaW5ncyI6IkFBQUEsQ0FBQztBQUNELEtBQUssSUFBMkI7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsTUFBTSxFQU9KO0FBQ0YsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixxQkFBTSxvQkFBb0IscUJBQU07QUFDM0Qsa0JBQWtCLHFCQUFNO0FBQ3hCOztBQUVBO0FBQ0Esb0JBQW9CLFVBQWM7QUFDbEM7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyxxQkFBUTtBQUN0QyxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixZQUFZO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsY0FBYztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixxQkFBcUI7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7QUFFVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIkQ6XFxUV0UgR0tFXFx0b3Vyd2l0aGVhc2UtZ2tlLWhhY2thdGhvblxcbm9kZV9tb2R1bGVzXFxjcnlwdG8tanNcXGNvcmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdHJvb3QuQ3J5cHRvSlMgPSBmYWN0b3J5KCk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuXG5cdC8qZ2xvYmFscyB3aW5kb3csIGdsb2JhbCwgcmVxdWlyZSovXG5cblx0LyoqXG5cdCAqIENyeXB0b0pTIGNvcmUgY29tcG9uZW50cy5cblx0ICovXG5cdHZhciBDcnlwdG9KUyA9IENyeXB0b0pTIHx8IChmdW5jdGlvbiAoTWF0aCwgdW5kZWZpbmVkKSB7XG5cblx0ICAgIHZhciBjcnlwdG87XG5cblx0ICAgIC8vIE5hdGl2ZSBjcnlwdG8gZnJvbSB3aW5kb3cgKEJyb3dzZXIpXG5cdCAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNyeXB0bykge1xuXHQgICAgICAgIGNyeXB0byA9IHdpbmRvdy5jcnlwdG87XG5cdCAgICB9XG5cblx0ICAgIC8vIE5hdGl2ZSBjcnlwdG8gaW4gd2ViIHdvcmtlciAoQnJvd3Nlcilcblx0ICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5jcnlwdG8pIHtcblx0ICAgICAgICBjcnlwdG8gPSBzZWxmLmNyeXB0bztcblx0ICAgIH1cblxuXHQgICAgLy8gTmF0aXZlIGNyeXB0byBmcm9tIHdvcmtlclxuXHQgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWxUaGlzLmNyeXB0bykge1xuXHQgICAgICAgIGNyeXB0byA9IGdsb2JhbFRoaXMuY3J5cHRvO1xuXHQgICAgfVxuXG5cdCAgICAvLyBOYXRpdmUgKGV4cGVyaW1lbnRhbCBJRSAxMSkgY3J5cHRvIGZyb20gd2luZG93IChCcm93c2VyKVxuXHQgICAgaWYgKCFjcnlwdG8gJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lm1zQ3J5cHRvKSB7XG5cdCAgICAgICAgY3J5cHRvID0gd2luZG93Lm1zQ3J5cHRvO1xuXHQgICAgfVxuXG5cdCAgICAvLyBOYXRpdmUgY3J5cHRvIGZyb20gZ2xvYmFsIChOb2RlSlMpXG5cdCAgICBpZiAoIWNyeXB0byAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwuY3J5cHRvKSB7XG5cdCAgICAgICAgY3J5cHRvID0gZ2xvYmFsLmNyeXB0bztcblx0ICAgIH1cblxuXHQgICAgLy8gTmF0aXZlIGNyeXB0byBpbXBvcnQgdmlhIHJlcXVpcmUgKE5vZGVKUylcblx0ICAgIGlmICghY3J5cHRvICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cdCAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgfVxuXG5cdCAgICAvKlxuXHQgICAgICogQ3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHBzZXVkb3JhbmRvbSBudW1iZXIgZ2VuZXJhdG9yXG5cdCAgICAgKlxuXHQgICAgICogQXMgTWF0aC5yYW5kb20oKSBpcyBjcnlwdG9ncmFwaGljYWxseSBub3Qgc2FmZSB0byB1c2Vcblx0ICAgICAqL1xuXHQgICAgdmFyIGNyeXB0b1NlY3VyZVJhbmRvbUludCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAoY3J5cHRvKSB7XG5cdCAgICAgICAgICAgIC8vIFVzZSBnZXRSYW5kb21WYWx1ZXMgbWV0aG9kIChCcm93c2VyKVxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDEpKVswXTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFVzZSByYW5kb21CeXRlcyBtZXRob2QgKE5vZGVKUylcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8ucmFuZG9tQnl0ZXMgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyeXB0by5yYW5kb21CeXRlcyg0KS5yZWFkSW50MzJMRSgpO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOYXRpdmUgY3J5cHRvIG1vZHVsZSBjb3VsZCBub3QgYmUgdXNlZCB0byBnZXQgc2VjdXJlIHJhbmRvbSBudW1iZXIuJyk7XG5cdCAgICB9O1xuXG5cdCAgICAvKlxuXHQgICAgICogTG9jYWwgcG9seWZpbGwgb2YgT2JqZWN0LmNyZWF0ZVxuXG5cdCAgICAgKi9cblx0ICAgIHZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZnVuY3Rpb24gRigpIHt9XG5cblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgICAgICB2YXIgc3VidHlwZTtcblxuXHQgICAgICAgICAgICBGLnByb3RvdHlwZSA9IG9iajtcblxuXHQgICAgICAgICAgICBzdWJ0eXBlID0gbmV3IEYoKTtcblxuXHQgICAgICAgICAgICBGLnByb3RvdHlwZSA9IG51bGw7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHN1YnR5cGU7XG5cdCAgICAgICAgfTtcblx0ICAgIH0oKSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQ3J5cHRvSlMgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQyA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIExpYnJhcnkgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYiA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEJhc2Ugb2JqZWN0IGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQmFzZSA9IENfbGliLkJhc2UgPSAoZnVuY3Rpb24gKCkge1xuXG5cblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3ZlcnJpZGVzIFByb3BlcnRpZXMgdG8gY29weSBpbnRvIHRoZSBuZXcgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuZXcgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgTXlUeXBlID0gQ3J5cHRvSlMubGliLkJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgICogICAgICAgICBmaWVsZDogJ3ZhbHVlJyxcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICogICAgICAgICB9XG5cdCAgICAgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGV4dGVuZDogZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuXHQgICAgICAgICAgICAgICAgLy8gU3Bhd25cblx0ICAgICAgICAgICAgICAgIHZhciBzdWJ0eXBlID0gY3JlYXRlKHRoaXMpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBBdWdtZW50XG5cdCAgICAgICAgICAgICAgICBpZiAob3ZlcnJpZGVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3VidHlwZS5taXhJbihvdmVycmlkZXMpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBDcmVhdGUgZGVmYXVsdCBpbml0aWFsaXplclxuXHQgICAgICAgICAgICAgICAgaWYgKCFzdWJ0eXBlLmhhc093blByb3BlcnR5KCdpbml0JykgfHwgdGhpcy5pbml0ID09PSBzdWJ0eXBlLmluaXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN1YnR5cGUuJHN1cGVyLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBJbml0aWFsaXplcidzIHByb3RvdHlwZSBpcyB0aGUgc3VidHlwZSBvYmplY3Rcblx0ICAgICAgICAgICAgICAgIHN1YnR5cGUuaW5pdC5wcm90b3R5cGUgPSBzdWJ0eXBlO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZWZlcmVuY2Ugc3VwZXJ0eXBlXG5cdCAgICAgICAgICAgICAgICBzdWJ0eXBlLiRzdXBlciA9IHRoaXM7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBzdWJ0eXBlO1xuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBFeHRlbmRzIHRoaXMgb2JqZWN0IGFuZCBydW5zIHRoZSBpbml0IG1ldGhvZC5cblx0ICAgICAgICAgICAgICogQXJndW1lbnRzIHRvIGNyZWF0ZSgpIHdpbGwgYmUgcGFzc2VkIHRvIGluaXQoKS5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbmV3IG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIGluc3RhbmNlID0gTXlUeXBlLmNyZWF0ZSgpO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzLmV4dGVuZCgpO1xuXHQgICAgICAgICAgICAgICAgaW5zdGFuY2UuaW5pdC5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKTtcblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBhZGQgc29tZSBsb2dpYyB3aGVuIHlvdXIgb2JqZWN0cyBhcmUgY3JlYXRlZC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBNeVR5cGUgPSBDcnlwdG9KUy5saWIuQmFzZS5leHRlbmQoe1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICogICAgICAgICAgICAgLy8gLi4uXG5cdCAgICAgICAgICAgICAqICAgICAgICAgfVxuXHQgICAgICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIENvcGllcyBwcm9wZXJ0aWVzIGludG8gdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIFRoZSBwcm9wZXJ0aWVzIHRvIG1peCBpbi5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIE15VHlwZS5taXhJbih7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgZmllbGQ6ICd2YWx1ZSdcblx0ICAgICAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgbWl4SW46IGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gcHJvcGVydGllcykge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1twcm9wZXJ0eU5hbWVdID0gcHJvcGVydGllc1twcm9wZXJ0eU5hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gSUUgd29uJ3QgY29weSB0b1N0cmluZyB1c2luZyB0aGUgbG9vcCBhYm92ZVxuXHQgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoJ3RvU3RyaW5nJykpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvU3RyaW5nID0gcHJvcGVydGllcy50b1N0cmluZztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNsb25lLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gaW5zdGFuY2UuY2xvbmUoKTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0LnByb3RvdHlwZS5leHRlbmQodGhpcyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgfSgpKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtBcnJheX0gd29yZHMgVGhlIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaWdCeXRlcyBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoaXMgd29yZCBhcnJheS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheSA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIChPcHRpb25hbCkgQW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaWdCeXRlcyAoT3B0aW9uYWwpIFRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgYnl0ZXMgaW4gdGhlIHdvcmRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFsweDAwMDEwMjAzLCAweDA0MDUwNjA3XSk7XG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMHgwMDAxMDIwMywgMHgwNDA1MDYwN10sIDYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uICh3b3Jkcywgc2lnQnl0ZXMpIHtcblx0ICAgICAgICAgICAgd29yZHMgPSB0aGlzLndvcmRzID0gd29yZHMgfHwgW107XG5cblx0ICAgICAgICAgICAgaWYgKHNpZ0J5dGVzICE9IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyA9IHNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyA9IHdvcmRzLmxlbmd0aCAqIDQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgdGhpcyB3b3JkIGFycmF5IHRvIGEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyIChPcHRpb25hbCkgVGhlIGVuY29kaW5nIHN0cmF0ZWd5IHRvIHVzZS4gRGVmYXVsdDogQ3J5cHRvSlMuZW5jLkhleFxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5naWZpZWQgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheSArICcnO1xuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5LnRvU3RyaW5nKCk7XG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkudG9TdHJpbmcoQ3J5cHRvSlMuZW5jLlV0ZjgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoZW5jb2Rlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gKGVuY29kZXIgfHwgSGV4KS5zdHJpbmdpZnkodGhpcyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmNhdGVuYXRlcyBhIHdvcmQgYXJyYXkgdG8gdGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheSB0byBhcHBlbmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoaXMgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgd29yZEFycmF5MS5jb25jYXQod29yZEFycmF5Mik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY29uY2F0OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgdGhpc1dvcmRzID0gdGhpcy53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHRoYXRXb3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHRoaXNTaWdCeXRlcyA9IHRoaXMuc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIHZhciB0aGF0U2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ2xhbXAgZXhjZXNzIGJpdHNcblx0ICAgICAgICAgICAgdGhpcy5jbGFtcCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbmNhdFxuXHQgICAgICAgICAgICBpZiAodGhpc1NpZ0J5dGVzICUgNCkge1xuXHQgICAgICAgICAgICAgICAgLy8gQ29weSBvbmUgYnl0ZSBhdCBhIHRpbWVcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdFNpZ0J5dGVzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdGhhdEJ5dGUgPSAodGhhdFdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzV29yZHNbKHRoaXNTaWdCeXRlcyArIGkpID4+PiAyXSB8PSB0aGF0Qnl0ZSA8PCAoMjQgLSAoKHRoaXNTaWdCeXRlcyArIGkpICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIC8vIENvcHkgb25lIHdvcmQgYXQgYSB0aW1lXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoYXRTaWdCeXRlczsgaiArPSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpc1dvcmRzWyh0aGlzU2lnQnl0ZXMgKyBqKSA+Pj4gMl0gPSB0aGF0V29yZHNbaiA+Pj4gMl07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyArPSB0aGF0U2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ2hhaW5hYmxlXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZW1vdmVzIGluc2lnbmlmaWNhbnQgYml0cy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgd29yZEFycmF5LmNsYW1wKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2xhbXA6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHRoaXMud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHRoaXMuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ2xhbXBcblx0ICAgICAgICAgICAgd29yZHNbc2lnQnl0ZXMgPj4+IDJdICY9IDB4ZmZmZmZmZmYgPDwgKDMyIC0gKHNpZ0J5dGVzICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgd29yZHMubGVuZ3RoID0gTWF0aC5jZWlsKHNpZ0J5dGVzIC8gNCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGNsb25lLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSB3b3JkQXJyYXkuY2xvbmUoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBCYXNlLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLndvcmRzID0gdGhpcy53b3Jkcy5zbGljZSgwKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSB3b3JkIGFycmF5IGZpbGxlZCB3aXRoIHJhbmRvbSBieXRlcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuQnl0ZXMgVGhlIG51bWJlciBvZiByYW5kb20gYnl0ZXMgdG8gZ2VuZXJhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSByYW5kb20gd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkucmFuZG9tKDE2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByYW5kb206IGZ1bmN0aW9uIChuQnl0ZXMpIHtcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuQnl0ZXM7IGkgKz0gNCkge1xuXHQgICAgICAgICAgICAgICAgd29yZHMucHVzaChjcnlwdG9TZWN1cmVSYW5kb21JbnQoKSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBuQnl0ZXMpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEVuY29kZXIgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYyA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEhleCBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEhleCA9IENfZW5jLkhleCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBoZXggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGhleCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBoZXhTdHJpbmcgPSBDcnlwdG9KUy5lbmMuSGV4LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgaGV4Q2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYml0ZSA9ICh3b3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICBoZXhDaGFycy5wdXNoKChiaXRlID4+PiA0KS50b1N0cmluZygxNikpO1xuXHQgICAgICAgICAgICAgICAgaGV4Q2hhcnMucHVzaCgoYml0ZSAmIDB4MGYpLnRvU3RyaW5nKDE2KSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gaGV4Q2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgaGV4IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaGV4U3RyIFRoZSBoZXggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5IZXgucGFyc2UoaGV4U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGhleFN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgaGV4U3RyTGVuZ3RoID0gaGV4U3RyLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhleFN0ckxlbmd0aDsgaSArPSAyKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAzXSB8PSBwYXJzZUludChoZXhTdHIuc3Vic3RyKGksIDIpLCAxNikgPDwgKDI0IC0gKGkgJSA4KSAqIDQpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgaGV4U3RyTGVuZ3RoIC8gMik7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBMYXRpbjEgZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBMYXRpbjEgPSBDX2VuYy5MYXRpbjEgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgTGF0aW4xIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBMYXRpbjEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgbGF0aW4xU3RyaW5nID0gQ3J5cHRvSlMuZW5jLkxhdGluMS5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIGxhdGluMUNoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJpdGUgPSAod29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgbGF0aW4xQ2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJpdGUpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBsYXRpbjFDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBMYXRpbjEgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXRpbjFTdHIgVGhlIExhdGluMSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkxhdGluMS5wYXJzZShsYXRpbjFTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAobGF0aW4xU3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBsYXRpbjFTdHJMZW5ndGggPSBsYXRpbjFTdHIubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0aW4xU3RyTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDJdIHw9IChsYXRpbjFTdHIuY2hhckNvZGVBdChpKSAmIDB4ZmYpIDw8ICgyNCAtIChpICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIGxhdGluMVN0ckxlbmd0aCk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBVVEYtOCBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFV0ZjggPSBDX2VuYy5VdGY4ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIFVURi04IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVVEYtOCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB1dGY4U3RyaW5nID0gQ3J5cHRvSlMuZW5jLlV0Zjguc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShMYXRpbjEuc3RyaW5naWZ5KHdvcmRBcnJheSkpKTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgVVRGLTggZGF0YScpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgVVRGLTggc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1dGY4U3RyIFRoZSBVVEYtOCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLlV0ZjgucGFyc2UodXRmOFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uICh1dGY4U3RyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBMYXRpbjEucGFyc2UodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHV0ZjhTdHIpKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBidWZmZXJlZCBibG9jayBhbGdvcml0aG0gdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogVGhlIHByb3BlcnR5IGJsb2NrU2l6ZSBtdXN0IGJlIGltcGxlbWVudGVkIGluIGEgY29uY3JldGUgc3VidHlwZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gX21pbkJ1ZmZlclNpemUgVGhlIG51bWJlciBvZiBibG9ja3MgdGhhdCBzaG91bGQgYmUga2VwdCB1bnByb2Nlc3NlZCBpbiB0aGUgYnVmZmVyLiBEZWZhdWx0OiAwXG5cdCAgICAgKi9cblx0ICAgIHZhciBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQ19saWIuQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBibG9jayBhbGdvcml0aG0ncyBkYXRhIGJ1ZmZlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIEluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgV29yZEFycmF5LmluaXQoKTtcblx0ICAgICAgICAgICAgdGhpcy5fbkRhdGFCeXRlcyA9IDA7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEFkZHMgbmV3IGRhdGEgdG8gdGhpcyBibG9jayBhbGdvcml0aG0ncyBidWZmZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYXBwZW5kLiBTdHJpbmdzIGFyZSBjb252ZXJ0ZWQgdG8gYSBXb3JkQXJyYXkgdXNpbmcgVVRGLTguXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX2FwcGVuZCgnZGF0YScpO1xuXHQgICAgICAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9hcHBlbmQod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfYXBwZW5kOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBXb3JkQXJyYXksIGVsc2UgYXNzdW1lIFdvcmRBcnJheSBhbHJlYWR5XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICAgICAgZGF0YSA9IFV0ZjgucGFyc2UoZGF0YSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBBcHBlbmRcblx0ICAgICAgICAgICAgdGhpcy5fZGF0YS5jb25jYXQoZGF0YSk7XG5cdCAgICAgICAgICAgIHRoaXMuX25EYXRhQnl0ZXMgKz0gZGF0YS5zaWdCeXRlcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUHJvY2Vzc2VzIGF2YWlsYWJsZSBkYXRhIGJsb2Nrcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIFRoaXMgbWV0aG9kIGludm9rZXMgX2RvUHJvY2Vzc0Jsb2NrKG9mZnNldCksIHdoaWNoIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgYSBjb25jcmV0ZSBzdWJ0eXBlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBkb0ZsdXNoIFdoZXRoZXIgYWxsIGJsb2NrcyBhbmQgcGFydGlhbCBibG9ja3Mgc2hvdWxkIGJlIHByb2Nlc3NlZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHByb2Nlc3NlZCBkYXRhLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgcHJvY2Vzc2VkRGF0YSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX3Byb2Nlc3MoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHByb2Nlc3NlZERhdGEgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX3Byb2Nlc3M6IGZ1bmN0aW9uIChkb0ZsdXNoKSB7XG5cdCAgICAgICAgICAgIHZhciBwcm9jZXNzZWRXb3JkcztcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGRhdGFTaWdCeXRlcyA9IGRhdGEuc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSB0aGlzLmJsb2NrU2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZUJ5dGVzID0gYmxvY2tTaXplICogNDtcblxuXHQgICAgICAgICAgICAvLyBDb3VudCBibG9ja3MgcmVhZHlcblx0ICAgICAgICAgICAgdmFyIG5CbG9ja3NSZWFkeSA9IGRhdGFTaWdCeXRlcyAvIGJsb2NrU2l6ZUJ5dGVzO1xuXHQgICAgICAgICAgICBpZiAoZG9GbHVzaCkge1xuXHQgICAgICAgICAgICAgICAgLy8gUm91bmQgdXAgdG8gaW5jbHVkZSBwYXJ0aWFsIGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgbkJsb2Nrc1JlYWR5ID0gTWF0aC5jZWlsKG5CbG9ja3NSZWFkeSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvLyBSb3VuZCBkb3duIHRvIGluY2x1ZGUgb25seSBmdWxsIGJsb2Nrcyxcblx0ICAgICAgICAgICAgICAgIC8vIGxlc3MgdGhlIG51bWJlciBvZiBibG9ja3MgdGhhdCBtdXN0IHJlbWFpbiBpbiB0aGUgYnVmZmVyXG5cdCAgICAgICAgICAgICAgICBuQmxvY2tzUmVhZHkgPSBNYXRoLm1heCgobkJsb2Nrc1JlYWR5IHwgMCkgLSB0aGlzLl9taW5CdWZmZXJTaXplLCAwKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENvdW50IHdvcmRzIHJlYWR5XG5cdCAgICAgICAgICAgIHZhciBuV29yZHNSZWFkeSA9IG5CbG9ja3NSZWFkeSAqIGJsb2NrU2l6ZTtcblxuXHQgICAgICAgICAgICAvLyBDb3VudCBieXRlcyByZWFkeVxuXHQgICAgICAgICAgICB2YXIgbkJ5dGVzUmVhZHkgPSBNYXRoLm1pbihuV29yZHNSZWFkeSAqIDQsIGRhdGFTaWdCeXRlcyk7XG5cblx0ICAgICAgICAgICAgLy8gUHJvY2VzcyBibG9ja3Ncblx0ICAgICAgICAgICAgaWYgKG5Xb3Jkc1JlYWR5KSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBuV29yZHNSZWFkeTsgb2Zmc2V0ICs9IGJsb2NrU2l6ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtYWxnb3JpdGhtIGxvZ2ljXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9Qcm9jZXNzQmxvY2soZGF0YVdvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1vdmUgcHJvY2Vzc2VkIHdvcmRzXG5cdCAgICAgICAgICAgICAgICBwcm9jZXNzZWRXb3JkcyA9IGRhdGFXb3Jkcy5zcGxpY2UoMCwgbldvcmRzUmVhZHkpO1xuXHQgICAgICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyAtPSBuQnl0ZXNSZWFkeTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBwcm9jZXNzZWQgd29yZHNcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdChwcm9jZXNzZWRXb3JkcywgbkJ5dGVzUmVhZHkpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNsb25lLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLmNsb25lKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gQmFzZS5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5fZGF0YSA9IHRoaXMuX2RhdGEuY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9taW5CdWZmZXJTaXplOiAwXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBoYXNoZXIgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbnVtYmVyIG9mIDMyLWJpdCB3b3JkcyB0aGlzIGhhc2hlciBvcGVyYXRlcyBvbi4gRGVmYXVsdDogMTYgKDUxMiBiaXRzKVxuXHQgICAgICovXG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyID0gQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKCksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgaGFzaGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIGhhc2ggY29tcHV0YXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBoYXNoZXIgPSBDcnlwdG9KUy5hbGdvLlNIQTI1Ni5jcmVhdGUoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICB0aGlzLmNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlc2V0cyB0aGlzIGhhc2hlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgaGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gUmVzZXQgZGF0YSBidWZmZXJcblx0ICAgICAgICAgICAgQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldC5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtaGFzaGVyIGxvZ2ljXG5cdCAgICAgICAgICAgIHRoaXMuX2RvUmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogVXBkYXRlcyB0aGlzIGhhc2hlciB3aXRoIGEgbWVzc2FnZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSBUaGUgbWVzc2FnZSB0byBhcHBlbmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtIYXNoZXJ9IFRoaXMgaGFzaGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBoYXNoZXIudXBkYXRlKCdtZXNzYWdlJyk7XG5cdCAgICAgICAgICogICAgIGhhc2hlci51cGRhdGUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGVuZFxuXHQgICAgICAgICAgICB0aGlzLl9hcHBlbmQobWVzc2FnZVVwZGF0ZSk7XG5cblx0ICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBoYXNoXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBDaGFpbmFibGVcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEZpbmFsaXplcyB0aGUgaGFzaCBjb21wdXRhdGlvbi5cblx0ICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIChPcHRpb25hbCkgQSBmaW5hbCBtZXNzYWdlIHVwZGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKCk7XG5cdCAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKCdtZXNzYWdlJyk7XG5cdCAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIEZpbmFsIG1lc3NhZ2UgdXBkYXRlXG5cdCAgICAgICAgICAgIGlmIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9hcHBlbmQobWVzc2FnZVVwZGF0ZSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWhhc2hlciBsb2dpY1xuXHQgICAgICAgICAgICB2YXIgaGFzaCA9IHRoaXMuX2RvRmluYWxpemUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYmxvY2tTaXplOiA1MTIvMzIsXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgc2hvcnRjdXQgZnVuY3Rpb24gdG8gYSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaGVyIHRvIGNyZWF0ZSBhIGhlbHBlciBmb3IuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIHNob3J0Y3V0IGZ1bmN0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgU0hBMjU2ID0gQ3J5cHRvSlMubGliLkhhc2hlci5fY3JlYXRlSGVscGVyKENyeXB0b0pTLmFsZ28uU0hBMjU2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfY3JlYXRlSGVscGVyOiBmdW5jdGlvbiAoaGFzaGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwgY2ZnKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGhhc2hlci5pbml0KGNmZykuZmluYWxpemUobWVzc2FnZSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBzaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoZXIgdG8gdXNlIGluIHRoaXMgSE1BQyBoZWxwZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIHNob3J0Y3V0IGZ1bmN0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgSG1hY1NIQTI1NiA9IENyeXB0b0pTLmxpYi5IYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoQ3J5cHRvSlMuYWxnby5TSEEyNTYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9jcmVhdGVIbWFjSGVscGVyOiBmdW5jdGlvbiAoaGFzaGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwga2V5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENfYWxnby5ITUFDLmluaXQoaGFzaGVyLCBrZXkpLmZpbmFsaXplKG1lc3NhZ2UpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFsZ29yaXRobSBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ28gPSB7fTtcblxuXHQgICAgcmV0dXJuIEM7XG5cdH0oTWF0aCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTO1xuXG59KSk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/crypto-js/core.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/crypto-js/enc-base64.js":
/*!**************************************************!*\
  !*** ../../node_modules/crypto-js/enc-base64.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"(app-pages-browser)/../../node_modules/crypto-js/core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_enc = C.enc;\n\n\t    /**\n\t     * Base64 encoding strategy.\n\t     */\n\t    var Base64 = C_enc.Base64 = {\n\t        /**\n\t         * Converts a word array to a Base64 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The Base64 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\t            var map = this._map;\n\n\t            // Clamp excess bits\n\t            wordArray.clamp();\n\n\t            // Convert\n\t            var base64Chars = [];\n\t            for (var i = 0; i < sigBytes; i += 3) {\n\t                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;\n\t                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;\n\t                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;\n\n\t                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;\n\n\t                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {\n\t                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));\n\t                }\n\t            }\n\n\t            // Add padding\n\t            var paddingChar = map.charAt(64);\n\t            if (paddingChar) {\n\t                while (base64Chars.length % 4) {\n\t                    base64Chars.push(paddingChar);\n\t                }\n\t            }\n\n\t            return base64Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a Base64 string to a word array.\n\t         *\n\t         * @param {string} base64Str The Base64 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);\n\t         */\n\t        parse: function (base64Str) {\n\t            // Shortcuts\n\t            var base64StrLength = base64Str.length;\n\t            var map = this._map;\n\t            var reverseMap = this._reverseMap;\n\n\t            if (!reverseMap) {\n\t                    reverseMap = this._reverseMap = [];\n\t                    for (var j = 0; j < map.length; j++) {\n\t                        reverseMap[map.charCodeAt(j)] = j;\n\t                    }\n\t            }\n\n\t            // Ignore padding\n\t            var paddingChar = map.charAt(64);\n\t            if (paddingChar) {\n\t                var paddingIndex = base64Str.indexOf(paddingChar);\n\t                if (paddingIndex !== -1) {\n\t                    base64StrLength = paddingIndex;\n\t                }\n\t            }\n\n\t            // Convert\n\t            return parseLoop(base64Str, base64StrLength, reverseMap);\n\n\t        },\n\n\t        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='\n\t    };\n\n\t    function parseLoop(base64Str, base64StrLength, reverseMap) {\n\t      var words = [];\n\t      var nBytes = 0;\n\t      for (var i = 0; i < base64StrLength; i++) {\n\t          if (i % 4) {\n\t              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);\n\t              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);\n\t              var bitsCombined = bits1 | bits2;\n\t              words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);\n\t              nBytes++;\n\t          }\n\t      }\n\t      return WordArray.create(words, nBytes);\n\t    }\n\t}());\n\n\n\treturn CryptoJS.enc.Base64;\n\n}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2VuYy1iYXNlNjQuanMiLCJtYXBwaW5ncyI6IkFBQUEsQ0FBQztBQUNELEtBQUssSUFBMkI7QUFDaEM7QUFDQSxxQ0FBcUMsbUJBQU8sQ0FBQyx3RUFBUTtBQUNyRDtBQUNBLE1BQU0sRUFPSjtBQUNGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlDQUFpQyxzQ0FBc0M7QUFDdkU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLGdCQUFnQjtBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFVBQVU7O0FBRVY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsiRDpcXFRXRSBHS0VcXHRvdXJ3aXRoZWFzZS1na2UtaGFja2F0aG9uXFxub2RlX21vZHVsZXNcXGNyeXB0by1qc1xcZW5jLWJhc2U2NC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcblxuXHQgICAgLyoqXG5cdCAgICAgKiBCYXNlNjQgZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBCYXNlNjQgPSBDX2VuYy5CYXNlNjQgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgQmFzZTY0IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBCYXNlNjQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgYmFzZTY0U3RyaW5nID0gQ3J5cHRvSlMuZW5jLkJhc2U2NC5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdCAgICAgICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG5cdCAgICAgICAgICAgIHdvcmRBcnJheS5jbGFtcCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIGJhc2U2NENoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkgKz0gMykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJ5dGUxID0gKHdvcmRzW2kgPj4+IDJdICAgICAgID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICAgICAgICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIHZhciBieXRlMiA9ICh3b3Jkc1soaSArIDEpID4+PiAyXSA+Pj4gKDI0IC0gKChpICsgMSkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICB2YXIgYnl0ZTMgPSAod29yZHNbKGkgKyAyKSA+Pj4gMl0gPj4+ICgyNCAtICgoaSArIDIpICUgNCkgKiA4KSkgJiAweGZmO1xuXG5cdCAgICAgICAgICAgICAgICB2YXIgdHJpcGxldCA9IChieXRlMSA8PCAxNikgfCAoYnl0ZTIgPDwgOCkgfCBieXRlMztcblxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IChqIDwgNCkgJiYgKGkgKyBqICogMC43NSA8IHNpZ0J5dGVzKTsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmFzZTY0Q2hhcnMucHVzaChtYXAuY2hhckF0KCh0cmlwbGV0ID4+PiAoNiAqICgzIC0gaikpKSAmIDB4M2YpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nQ2hhciA9IG1hcC5jaGFyQXQoNjQpO1xuXHQgICAgICAgICAgICBpZiAocGFkZGluZ0NoYXIpIHtcblx0ICAgICAgICAgICAgICAgIHdoaWxlIChiYXNlNjRDaGFycy5sZW5ndGggJSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmFzZTY0Q2hhcnMucHVzaChwYWRkaW5nQ2hhcik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gYmFzZTY0Q2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgQmFzZTY0IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZTY0U3RyIFRoZSBCYXNlNjQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5CYXNlNjQucGFyc2UoYmFzZTY0U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGJhc2U2NFN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGJhc2U2NFN0ckxlbmd0aCA9IGJhc2U2NFN0ci5sZW5ndGg7XG5cdCAgICAgICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cdCAgICAgICAgICAgIHZhciByZXZlcnNlTWFwID0gdGhpcy5fcmV2ZXJzZU1hcDtcblxuXHQgICAgICAgICAgICBpZiAoIXJldmVyc2VNYXApIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXZlcnNlTWFwID0gdGhpcy5fcmV2ZXJzZU1hcCA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWFwLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2VNYXBbbWFwLmNoYXJDb2RlQXQoaildID0gajtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJZ25vcmUgcGFkZGluZ1xuXHQgICAgICAgICAgICB2YXIgcGFkZGluZ0NoYXIgPSBtYXAuY2hhckF0KDY0KTtcblx0ICAgICAgICAgICAgaWYgKHBhZGRpbmdDaGFyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcGFkZGluZ0luZGV4ID0gYmFzZTY0U3RyLmluZGV4T2YocGFkZGluZ0NoYXIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHBhZGRpbmdJbmRleCAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgICAgICBiYXNlNjRTdHJMZW5ndGggPSBwYWRkaW5nSW5kZXg7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHJldHVybiBwYXJzZUxvb3AoYmFzZTY0U3RyLCBiYXNlNjRTdHJMZW5ndGgsIHJldmVyc2VNYXApO1xuXG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9tYXA6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSdcblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIHBhcnNlTG9vcChiYXNlNjRTdHIsIGJhc2U2NFN0ckxlbmd0aCwgcmV2ZXJzZU1hcCkge1xuXHQgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgdmFyIG5CeXRlcyA9IDA7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFzZTY0U3RyTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIGlmIChpICUgNCkge1xuXHQgICAgICAgICAgICAgIHZhciBiaXRzMSA9IHJldmVyc2VNYXBbYmFzZTY0U3RyLmNoYXJDb2RlQXQoaSAtIDEpXSA8PCAoKGkgJSA0KSAqIDIpO1xuXHQgICAgICAgICAgICAgIHZhciBiaXRzMiA9IHJldmVyc2VNYXBbYmFzZTY0U3RyLmNoYXJDb2RlQXQoaSldID4+PiAoNiAtIChpICUgNCkgKiAyKTtcblx0ICAgICAgICAgICAgICB2YXIgYml0c0NvbWJpbmVkID0gYml0czEgfCBiaXRzMjtcblx0ICAgICAgICAgICAgICB3b3Jkc1tuQnl0ZXMgPj4+IDJdIHw9IGJpdHNDb21iaW5lZCA8PCAoMjQgLSAobkJ5dGVzICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgICBuQnl0ZXMrKztcblx0ICAgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gV29yZEFycmF5LmNyZWF0ZSh3b3JkcywgbkJ5dGVzKTtcblx0ICAgIH1cblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5lbmMuQmFzZTY0O1xuXG59KSk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/crypto-js/enc-base64.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/crypto-js/enc-utf8.js":
/*!************************************************!*\
  !*** ../../node_modules/crypto-js/enc-utf8.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"(app-pages-browser)/../../node_modules/crypto-js/core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\treturn CryptoJS.enc.Utf8;\n\n}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2VuYy11dGY4LmpzIiwibWFwcGluZ3MiOiJBQUFBLENBQUM7QUFDRCxLQUFLLElBQTJCO0FBQ2hDO0FBQ0EscUNBQXFDLG1CQUFPLENBQUMsd0VBQVE7QUFDckQ7QUFDQSxNQUFNLEVBT0o7QUFDRixDQUFDOztBQUVEOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIkQ6XFxUV0UgR0tFXFx0b3Vyd2l0aGVhc2UtZ2tlLWhhY2thdGhvblxcbm9kZV9tb2R1bGVzXFxjcnlwdG8tanNcXGVuYy11dGY4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0cmV0dXJuIENyeXB0b0pTLmVuYy5VdGY4O1xuXG59KSk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/crypto-js/enc-utf8.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/crypto-js/sha256.js":
/*!**********************************************!*\
  !*** ../../node_modules/crypto-js/sha256.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"(app-pages-browser)/../../node_modules/crypto-js/core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Initialization and round constants tables\n\t    var H = [];\n\t    var K = [];\n\n\t    // Compute constants\n\t    (function () {\n\t        function isPrime(n) {\n\t            var sqrtN = Math.sqrt(n);\n\t            for (var factor = 2; factor <= sqrtN; factor++) {\n\t                if (!(n % factor)) {\n\t                    return false;\n\t                }\n\t            }\n\n\t            return true;\n\t        }\n\n\t        function getFractionalBits(n) {\n\t            return ((n - (n | 0)) * 0x100000000) | 0;\n\t        }\n\n\t        var n = 2;\n\t        var nPrime = 0;\n\t        while (nPrime < 64) {\n\t            if (isPrime(n)) {\n\t                if (nPrime < 8) {\n\t                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\n\t                }\n\t                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\n\n\t                nPrime++;\n\t            }\n\n\t            n++;\n\t        }\n\t    }());\n\n\t    // Reusable object\n\t    var W = [];\n\n\t    /**\n\t     * SHA-256 hash algorithm.\n\t     */\n\t    var SHA256 = C_algo.SHA256 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init(H.slice(0));\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcut\n\t            var H = this._hash.words;\n\n\t            // Working variables\n\t            var a = H[0];\n\t            var b = H[1];\n\t            var c = H[2];\n\t            var d = H[3];\n\t            var e = H[4];\n\t            var f = H[5];\n\t            var g = H[6];\n\t            var h = H[7];\n\n\t            // Computation\n\t            for (var i = 0; i < 64; i++) {\n\t                if (i < 16) {\n\t                    W[i] = M[offset + i] | 0;\n\t                } else {\n\t                    var gamma0x = W[i - 15];\n\t                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^\n\t                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^\n\t                                   (gamma0x >>> 3);\n\n\t                    var gamma1x = W[i - 2];\n\t                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^\n\t                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^\n\t                                   (gamma1x >>> 10);\n\n\t                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n\t                }\n\n\t                var ch  = (e & f) ^ (~e & g);\n\t                var maj = (a & b) ^ (a & c) ^ (b & c);\n\n\t                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n\t                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));\n\n\t                var t1 = h + sigma1 + ch + K[i] + W[i];\n\t                var t2 = sigma0 + maj;\n\n\t                h = g;\n\t                g = f;\n\t                f = e;\n\t                e = (d + t1) | 0;\n\t                d = c;\n\t                c = b;\n\t                b = a;\n\t                a = (t1 + t2) | 0;\n\t            }\n\n\t            // Intermediate hash value\n\t            H[0] = (H[0] + a) | 0;\n\t            H[1] = (H[1] + b) | 0;\n\t            H[2] = (H[2] + c) | 0;\n\t            H[3] = (H[3] + d) | 0;\n\t            H[4] = (H[4] + e) | 0;\n\t            H[5] = (H[5] + f) | 0;\n\t            H[6] = (H[6] + g) | 0;\n\t            H[7] = (H[7] + h) | 0;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Return final computed hash\n\t            return this._hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA256('message');\n\t     *     var hash = CryptoJS.SHA256(wordArray);\n\t     */\n\t    C.SHA256 = Hasher._createHelper(SHA256);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA256(message, key);\n\t     */\n\t    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);\n\t}(Math));\n\n\n\treturn CryptoJS.SHA256;\n\n}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTI1Ni5qcyIsIm1hcHBpbmdzIjoiQUFBQSxDQUFDO0FBQ0QsS0FBSyxJQUEyQjtBQUNoQztBQUNBLHFDQUFxQyxtQkFBTyxDQUFDLHdFQUFRO0FBQ3JEO0FBQ0EsTUFBTSxFQU9KO0FBQ0YsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQSxpQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsiRDpcXFRXRSBHS0VcXHRvdXJ3aXRoZWFzZS1na2UtaGFja2F0aG9uXFxub2RlX21vZHVsZXNcXGNyeXB0by1qc1xcc2hhMjU2LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uIChNYXRoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gSW5pdGlhbGl6YXRpb24gYW5kIHJvdW5kIGNvbnN0YW50cyB0YWJsZXNcblx0ICAgIHZhciBIID0gW107XG5cdCAgICB2YXIgSyA9IFtdO1xuXG5cdCAgICAvLyBDb21wdXRlIGNvbnN0YW50c1xuXHQgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmdW5jdGlvbiBpc1ByaW1lKG4pIHtcblx0ICAgICAgICAgICAgdmFyIHNxcnROID0gTWF0aC5zcXJ0KG4pO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBmYWN0b3IgPSAyOyBmYWN0b3IgPD0gc3FydE47IGZhY3RvcisrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIShuICUgZmFjdG9yKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZ1bmN0aW9uIGdldEZyYWN0aW9uYWxCaXRzKG4pIHtcblx0ICAgICAgICAgICAgcmV0dXJuICgobiAtIChuIHwgMCkpICogMHgxMDAwMDAwMDApIHwgMDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgbiA9IDI7XG5cdCAgICAgICAgdmFyIG5QcmltZSA9IDA7XG5cdCAgICAgICAgd2hpbGUgKG5QcmltZSA8IDY0KSB7XG5cdCAgICAgICAgICAgIGlmIChpc1ByaW1lKG4pKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoblByaW1lIDwgOCkge1xuXHQgICAgICAgICAgICAgICAgICAgIEhbblByaW1lXSA9IGdldEZyYWN0aW9uYWxCaXRzKE1hdGgucG93KG4sIDEgLyAyKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBLW25QcmltZV0gPSBnZXRGcmFjdGlvbmFsQml0cyhNYXRoLnBvdyhuLCAxIC8gMykpO1xuXG5cdCAgICAgICAgICAgICAgICBuUHJpbWUrKztcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIG4rKztcblx0ICAgICAgICB9XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvLyBSZXVzYWJsZSBvYmplY3Rcblx0ICAgIHZhciBXID0gW107XG5cblx0ICAgIC8qKlxuXHQgICAgICogU0hBLTI1NiBoYXNoIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFNIQTI1NiA9IENfYWxnby5TSEEyNTYgPSBIYXNoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheS5pbml0KEguc2xpY2UoMCkpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFdvcmtpbmcgdmFyaWFibGVzXG5cdCAgICAgICAgICAgIHZhciBhID0gSFswXTtcblx0ICAgICAgICAgICAgdmFyIGIgPSBIWzFdO1xuXHQgICAgICAgICAgICB2YXIgYyA9IEhbMl07XG5cdCAgICAgICAgICAgIHZhciBkID0gSFszXTtcblx0ICAgICAgICAgICAgdmFyIGUgPSBIWzRdO1xuXHQgICAgICAgICAgICB2YXIgZiA9IEhbNV07XG5cdCAgICAgICAgICAgIHZhciBnID0gSFs2XTtcblx0ICAgICAgICAgICAgdmFyIGggPSBIWzddO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGF0aW9uXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGkgPCAxNikge1xuXHQgICAgICAgICAgICAgICAgICAgIFdbaV0gPSBNW29mZnNldCArIGldIHwgMDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMHggPSBXW2kgLSAxNV07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMCAgPSAoKGdhbW1hMHggPDwgMjUpIHwgKGdhbW1hMHggPj4+IDcpKSAgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChnYW1tYTB4IDw8IDE0KSB8IChnYW1tYTB4ID4+PiAxOCkpIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZ2FtbWEweCA+Pj4gMyk7XG5cblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWExeCA9IFdbaSAtIDJdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTEgID0gKChnYW1tYTF4IDw8IDE1KSB8IChnYW1tYTF4ID4+PiAxNykpIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoZ2FtbWExeCA8PCAxMykgfCAoZ2FtbWExeCA+Pj4gMTkpKSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGdhbW1hMXggPj4+IDEwKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIFdbaV0gPSBnYW1tYTAgKyBXW2kgLSA3XSArIGdhbW1hMSArIFdbaSAtIDE2XTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgdmFyIGNoICA9IChlICYgZikgXiAofmUgJiBnKTtcblx0ICAgICAgICAgICAgICAgIHZhciBtYWogPSAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG5cblx0ICAgICAgICAgICAgICAgIHZhciBzaWdtYTAgPSAoKGEgPDwgMzApIHwgKGEgPj4+IDIpKSBeICgoYSA8PCAxOSkgfCAoYSA+Pj4gMTMpKSBeICgoYSA8PCAxMCkgfCAoYSA+Pj4gMjIpKTtcblx0ICAgICAgICAgICAgICAgIHZhciBzaWdtYTEgPSAoKGUgPDwgMjYpIHwgKGUgPj4+IDYpKSBeICgoZSA8PCAyMSkgfCAoZSA+Pj4gMTEpKSBeICgoZSA8PCA3KSAgfCAoZSA+Pj4gMjUpKTtcblxuXHQgICAgICAgICAgICAgICAgdmFyIHQxID0gaCArIHNpZ21hMSArIGNoICsgS1tpXSArIFdbaV07XG5cdCAgICAgICAgICAgICAgICB2YXIgdDIgPSBzaWdtYTAgKyBtYWo7XG5cblx0ICAgICAgICAgICAgICAgIGggPSBnO1xuXHQgICAgICAgICAgICAgICAgZyA9IGY7XG5cdCAgICAgICAgICAgICAgICBmID0gZTtcblx0ICAgICAgICAgICAgICAgIGUgPSAoZCArIHQxKSB8IDA7XG5cdCAgICAgICAgICAgICAgICBkID0gYztcblx0ICAgICAgICAgICAgICAgIGMgPSBiO1xuXHQgICAgICAgICAgICAgICAgYiA9IGE7XG5cdCAgICAgICAgICAgICAgICBhID0gKHQxICsgdDIpIHwgMDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG5cdCAgICAgICAgICAgIEhbMF0gPSAoSFswXSArIGEpIHwgMDtcblx0ICAgICAgICAgICAgSFsxXSA9IChIWzFdICsgYikgfCAwO1xuXHQgICAgICAgICAgICBIWzJdID0gKEhbMl0gKyBjKSB8IDA7XG5cdCAgICAgICAgICAgIEhbM10gPSAoSFszXSArIGQpIHwgMDtcblx0ICAgICAgICAgICAgSFs0XSA9IChIWzRdICsgZSkgfCAwO1xuXHQgICAgICAgICAgICBIWzVdID0gKEhbNV0gKyBmKSB8IDA7XG5cdCAgICAgICAgICAgIEhbNl0gPSAoSFs2XSArIGcpIHwgMDtcblx0ICAgICAgICAgICAgSFs3XSA9IChIWzddICsgaCkgfCAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMik7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE1XSA9IG5CaXRzVG90YWw7XG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgPSBkYXRhV29yZHMubGVuZ3RoICogNDtcblxuXHQgICAgICAgICAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEyNTYoJ21lc3NhZ2UnKTtcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTI1Nih3b3JkQXJyYXkpO1xuXHQgICAgICovXG5cdCAgICBDLlNIQTI1NiA9IEhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTI1Nik7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjU0hBMjU2KG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgKi9cblx0ICAgIEMuSG1hY1NIQTI1NiA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihTSEEyNTYpO1xuXHR9KE1hdGgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5TSEEyNTY7XG5cbn0pKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/crypto-js/sha256.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/globals.css":
/*!*************************!*\
  !*** ./app/globals.css ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"0f7b05bc6c83\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9nbG9iYWxzLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIkQ6XFxUV0UgR0tFXFx0b3Vyd2l0aGVhc2UtZ2tlLWhhY2thdGhvblxcZnJvbnRlbmRcXG15LWFwcFxcYXBwXFxnbG9iYWxzLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjBmN2IwNWJjNmM4M1wiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/AuthWrapper.tsx":
/*!************************************!*\
  !*** ./components/AuthWrapper.tsx ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AuthWrapper)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_oidc_context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-oidc-context */ \"(app-pages-browser)/./node_modules/react-oidc-context/dist/esm/react-oidc-context.js\");\n/* harmony import */ var _src_utils_oidcConfigSigninConfig_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/utils/oidcConfigSigninConfig.js */ \"(app-pages-browser)/./src/utils/oidcConfigSigninConfig.js\");\n// \"use client\";\n// import { AuthProvider } from \"react-oidc-context\";\n// import { oidcConfigSignInConfig } from \"../src/utils/oidcConfigSignInConfig\";\n// export default function AuthWrapper({ children }) {\n//   return <AuthProvider {...oidcConfigSignInConfig}>{children}</AuthProvider>;\n// }\n//(2)\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\nfunction AuthWrapper(param) {\n    let { children } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_oidc_context__WEBPACK_IMPORTED_MODULE_1__.AuthProvider, {\n        ..._src_utils_oidcConfigSigninConfig_js__WEBPACK_IMPORTED_MODULE_2__.oidcConfigSignInConfig,\n        children: children\n    }, void 0, false, {\n        fileName: \"D:\\\\TWE GKE\\\\tourwithease-gke-hackathon\\\\frontend\\\\my-app\\\\components\\\\AuthWrapper.tsx\",\n        lineNumber: 15,\n        columnNumber: 10\n    }, this);\n}\n_c = AuthWrapper;\nvar _c;\n$RefreshReg$(_c, \"AuthWrapper\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvQXV0aFdyYXBwZXIudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxnQkFBZ0I7QUFDaEIscURBQXFEO0FBQ3JELGdGQUFnRjtBQUVoRixzREFBc0Q7QUFDdEQsZ0ZBQWdGO0FBQ2hGLElBQUk7QUFFSixLQUFLOztBQUU2QztBQUM4QjtBQUVqRSxTQUFTRSxZQUFZLEtBQStCO1FBQS9CLEVBQUVDLFFBQVEsRUFBcUIsR0FBL0I7SUFDbEMscUJBQU8sOERBQUNILDREQUFZQTtRQUFFLEdBQUdDLHdGQUFzQjtrQkFBR0U7Ozs7OztBQUNwRDtLQUZ3QkQiLCJzb3VyY2VzIjpbIkQ6XFxUV0UgR0tFXFx0b3Vyd2l0aGVhc2UtZ2tlLWhhY2thdGhvblxcZnJvbnRlbmRcXG15LWFwcFxcY29tcG9uZW50c1xcQXV0aFdyYXBwZXIudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFwidXNlIGNsaWVudFwiO1xyXG4vLyBpbXBvcnQgeyBBdXRoUHJvdmlkZXIgfSBmcm9tIFwicmVhY3Qtb2lkYy1jb250ZXh0XCI7XHJcbi8vIGltcG9ydCB7IG9pZGNDb25maWdTaWduSW5Db25maWcgfSBmcm9tIFwiLi4vc3JjL3V0aWxzL29pZGNDb25maWdTaWduSW5Db25maWdcIjtcclxuXHJcbi8vIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEF1dGhXcmFwcGVyKHsgY2hpbGRyZW4gfSkge1xyXG4vLyAgIHJldHVybiA8QXV0aFByb3ZpZGVyIHsuLi5vaWRjQ29uZmlnU2lnbkluQ29uZmlnfT57Y2hpbGRyZW59PC9BdXRoUHJvdmlkZXI+O1xyXG4vLyB9XHJcblxyXG4vLygyKVxyXG5cInVzZSBjbGllbnRcIjtcclxuaW1wb3J0IHsgQXV0aFByb3ZpZGVyIH0gZnJvbSBcInJlYWN0LW9pZGMtY29udGV4dFwiO1xyXG5pbXBvcnQgeyBvaWRjQ29uZmlnU2lnbkluQ29uZmlnIH0gZnJvbSBcIi4uL3NyYy91dGlscy9vaWRjQ29uZmlnU2lnbmluQ29uZmlnLmpzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBdXRoV3JhcHBlcih7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IGFueSB9KSB7XHJcbiAgcmV0dXJuIDxBdXRoUHJvdmlkZXIgey4uLm9pZGNDb25maWdTaWduSW5Db25maWd9PntjaGlsZHJlbn08L0F1dGhQcm92aWRlcj47XHJcbn1cclxuIl0sIm5hbWVzIjpbIkF1dGhQcm92aWRlciIsIm9pZGNDb25maWdTaWduSW5Db25maWciLCJBdXRoV3JhcHBlciIsImNoaWxkcmVuIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/AuthWrapper.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/jwt-decode/build/jwt-decode.esm.js":
/*!*********************************************************!*\
  !*** ./node_modules/jwt-decode/build/jwt-decode.esm.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidTokenError: () => (/* binding */ n),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction e(e){this.message=e}e.prototype=new Error,e.prototype.name=\"InvalidCharacterError\";var r=\"undefined\"!=typeof window&&window.atob&&window.atob.bind(window)||function(r){var t=String(r).replace(/=+$/,\"\");if(t.length%4==1)throw new e(\"'atob' failed: The string to be decoded is not correctly encoded.\");for(var n,o,a=0,i=0,c=\"\";o=t.charAt(i++);~o&&(n=a%4?64*n+o:o,a++%4)?c+=String.fromCharCode(255&n>>(-2*a&6)):0)o=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\".indexOf(o);return c};function t(e){var t=e.replace(/-/g,\"+\").replace(/_/g,\"/\");switch(t.length%4){case 0:break;case 2:t+=\"==\";break;case 3:t+=\"=\";break;default:throw\"Illegal base64url string!\"}try{return function(e){return decodeURIComponent(r(e).replace(/(.)/g,(function(e,r){var t=r.charCodeAt(0).toString(16).toUpperCase();return t.length<2&&(t=\"0\"+t),\"%\"+t})))}(t)}catch(e){return r(t)}}function n(e){this.message=e}function o(e,r){if(\"string\"!=typeof e)throw new n(\"Invalid token specified\");var o=!0===(r=r||{}).header?0:1;try{return JSON.parse(t(e.split(\".\")[o]))}catch(e){throw new n(\"Invalid token specified: \"+e.message)}}n.prototype=new Error,n.prototype.name=\"InvalidTokenError\";/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (o);\n//# sourceMappingURL=jwt-decode.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qd3QtZGVjb2RlL2J1aWxkL2p3dC1kZWNvZGUuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsY0FBYyxlQUFlLCtEQUErRCxxRkFBcUYsa0NBQWtDLGtHQUFrRyx5QkFBeUIsZ0JBQWdCLHNKQUFzSixVQUFVLGNBQWMsNENBQTRDLG1CQUFtQixhQUFhLGVBQWUsTUFBTSxjQUFjLE1BQU0seUNBQXlDLElBQUksbUJBQW1CLDZEQUE2RCxpREFBaUQsbUNBQW1DLElBQUksSUFBSSxTQUFTLGFBQWEsY0FBYyxlQUFlLGdCQUFnQiw2REFBNkQsbUJBQW1CLGFBQWEsSUFBSSxzQ0FBc0MsU0FBUyxvREFBb0QsMkRBQTJELGlFQUFlLENBQUMsRUFBZ0M7QUFDNXNDIiwic291cmNlcyI6WyJEOlxcVFdFIEdLRVxcdG91cndpdGhlYXNlLWdrZS1oYWNrYXRob25cXGZyb250ZW5kXFxteS1hcHBcXG5vZGVfbW9kdWxlc1xcand0LWRlY29kZVxcYnVpbGRcXGp3dC1kZWNvZGUuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGUoZSl7dGhpcy5tZXNzYWdlPWV9ZS5wcm90b3R5cGU9bmV3IEVycm9yLGUucHJvdG90eXBlLm5hbWU9XCJJbnZhbGlkQ2hhcmFjdGVyRXJyb3JcIjt2YXIgcj1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3cuYXRvYiYmd2luZG93LmF0b2IuYmluZCh3aW5kb3cpfHxmdW5jdGlvbihyKXt2YXIgdD1TdHJpbmcocikucmVwbGFjZSgvPSskLyxcIlwiKTtpZih0Lmxlbmd0aCU0PT0xKXRocm93IG5ldyBlKFwiJ2F0b2InIGZhaWxlZDogVGhlIHN0cmluZyB0byBiZSBkZWNvZGVkIGlzIG5vdCBjb3JyZWN0bHkgZW5jb2RlZC5cIik7Zm9yKHZhciBuLG8sYT0wLGk9MCxjPVwiXCI7bz10LmNoYXJBdChpKyspO35vJiYobj1hJTQ/NjQqbitvOm8sYSsrJTQpP2MrPVN0cmluZy5mcm9tQ2hhckNvZGUoMjU1Jm4+PigtMiphJjYpKTowKW89XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiLmluZGV4T2Yobyk7cmV0dXJuIGN9O2Z1bmN0aW9uIHQoZSl7dmFyIHQ9ZS5yZXBsYWNlKC8tL2csXCIrXCIpLnJlcGxhY2UoL18vZyxcIi9cIik7c3dpdGNoKHQubGVuZ3RoJTQpe2Nhc2UgMDpicmVhaztjYXNlIDI6dCs9XCI9PVwiO2JyZWFrO2Nhc2UgMzp0Kz1cIj1cIjticmVhaztkZWZhdWx0OnRocm93XCJJbGxlZ2FsIGJhc2U2NHVybCBzdHJpbmchXCJ9dHJ5e3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHIoZSkucmVwbGFjZSgvKC4pL2csKGZ1bmN0aW9uKGUscil7dmFyIHQ9ci5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO3JldHVybiB0Lmxlbmd0aDwyJiYodD1cIjBcIit0KSxcIiVcIit0fSkpKX0odCl9Y2F0Y2goZSl7cmV0dXJuIHIodCl9fWZ1bmN0aW9uIG4oZSl7dGhpcy5tZXNzYWdlPWV9ZnVuY3Rpb24gbyhlLHIpe2lmKFwic3RyaW5nXCIhPXR5cGVvZiBlKXRocm93IG5ldyBuKFwiSW52YWxpZCB0b2tlbiBzcGVjaWZpZWRcIik7dmFyIG89ITA9PT0ocj1yfHx7fSkuaGVhZGVyPzA6MTt0cnl7cmV0dXJuIEpTT04ucGFyc2UodChlLnNwbGl0KFwiLlwiKVtvXSkpfWNhdGNoKGUpe3Rocm93IG5ldyBuKFwiSW52YWxpZCB0b2tlbiBzcGVjaWZpZWQ6IFwiK2UubWVzc2FnZSl9fW4ucHJvdG90eXBlPW5ldyBFcnJvcixuLnByb3RvdHlwZS5uYW1lPVwiSW52YWxpZFRva2VuRXJyb3JcIjtleHBvcnQgZGVmYXVsdCBvO2V4cG9ydHtuIGFzIEludmFsaWRUb2tlbkVycm9yfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWp3dC1kZWNvZGUuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/jwt-decode/build/jwt-decode.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5CTWE%20GKE%5C%5Ctourwithease-gke-hackathon%5C%5Cfrontend%5C%5Cmy-app%5C%5Capp%5C%5Cglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5CTWE%20GKE%5C%5Ctourwithease-gke-hackathon%5C%5Cfrontend%5C%5Cmy-app%5C%5Ccomponents%5C%5CAuthWrapper.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false!":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5CTWE%20GKE%5C%5Ctourwithease-gke-hackathon%5C%5Cfrontend%5C%5Cmy-app%5C%5Capp%5C%5Cglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5CTWE%20GKE%5C%5Ctourwithease-gke-hackathon%5C%5Cfrontend%5C%5Cmy-app%5C%5Ccomponents%5C%5CAuthWrapper.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false! ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/globals.css */ \"(app-pages-browser)/./app/globals.css\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./components/AuthWrapper.tsx */ \"(app-pages-browser)/./components/AuthWrapper.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyRCUzQSU1QyU1Q1RXRSUyMEdLRSU1QyU1Q3RvdXJ3aXRoZWFzZS1na2UtaGFja2F0aG9uJTVDJTVDZnJvbnRlbmQlNUMlNUNteS1hcHAlNUMlNUNhcHAlNUMlNUNnbG9iYWxzLmNzcyUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjJEJTNBJTVDJTVDVFdFJTIwR0tFJTVDJTVDdG91cndpdGhlYXNlLWdrZS1oYWNrYXRob24lNUMlNUNmcm9udGVuZCU1QyU1Q215LWFwcCU1QyU1Q2NvbXBvbmVudHMlNUMlNUNBdXRoV3JhcHBlci50c3glMjIlMkMlMjJpZHMlMjIlM0ElNUIlMjJkZWZhdWx0JTIyJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsNEpBQWdIO0FBQ2hIO0FBQ0Esa0xBQXdKIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCJEOlxcXFxUV0UgR0tFXFxcXHRvdXJ3aXRoZWFzZS1na2UtaGFja2F0aG9uXFxcXGZyb250ZW5kXFxcXG15LWFwcFxcXFxhcHBcXFxcZ2xvYmFscy5jc3NcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiwgd2VicGFja0V4cG9ydHM6IFtcImRlZmF1bHRcIl0gKi8gXCJEOlxcXFxUV0UgR0tFXFxcXHRvdXJ3aXRoZWFzZS1na2UtaGFja2F0aG9uXFxcXGZyb250ZW5kXFxcXG15LWFwcFxcXFxjb21wb25lbnRzXFxcXEF1dGhXcmFwcGVyLnRzeFwiKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5CTWE%20GKE%5C%5Ctourwithease-gke-hackathon%5C%5Cfrontend%5C%5Cmy-app%5C%5Capp%5C%5Cglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5CTWE%20GKE%5C%5Ctourwithease-gke-hackathon%5C%5Cfrontend%5C%5Cmy-app%5C%5Ccomponents%5C%5CAuthWrapper.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return type.displayName || \"Context\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function UnknownOwner() {\n      return Error(\"react-stack-top-frame\");\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(type, key, props, owner, debugStack, debugTask) {\n      var refProp = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== refProp ? refProp : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      debugStack,\n      debugTask\n    ) {\n      var children = config.children;\n      if (void 0 !== children)\n        if (isStaticChildren)\n          if (isArrayImpl(children)) {\n            for (\n              isStaticChildren = 0;\n              isStaticChildren < children.length;\n              isStaticChildren++\n            )\n              validateChildKeys(children[isStaticChildren]);\n            Object.freeze && Object.freeze(children);\n          } else\n            console.error(\n              \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n            );\n        else validateChildKeys(children);\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(\n        type,\n        children,\n        maybeKey,\n        getOwner(),\n        debugStack,\n        debugTask\n      );\n    }\n    function validateChildKeys(node) {\n      \"object\" === typeof node &&\n        null !== node &&\n        node.$$typeof === REACT_ELEMENT_TYPE &&\n        node._store &&\n        (node._store.validated = 1);\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\n      REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      isArrayImpl = Array.isArray,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          };\n    React = {\n      react_stack_bottom_frame: function (callStackForError) {\n        return callStackForError();\n      }\n    };\n    var specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(\n      React,\n      UnknownOwner\n    )();\n    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n    var didWarnAboutKeySpread = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (type, config, maybeKey, isStaticChildren) {\n      var trackActualOwner =\n        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        isStaticChildren,\n        trackActualOwner\n          ? Error(\"react-stack-top-frame\")\n          : unknownOwnerDebugStack,\n        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCwrQ0FBK0MsNkJBQTZCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWdEO0FBQ2hFLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSxnQ0FBZ0Msa0NBQWtDLE9BQU87QUFDekU7QUFDQSxnR0FBZ0csU0FBUyxVQUFVLHNGQUFzRixhQUFhLFVBQVUsVUFBVTtBQUMxTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsc0dBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCO0FBQ3BCLElBQUksY0FBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUciLCJzb3VyY2VzIjpbIkQ6XFxUV0UgR0tFXFx0b3Vyd2l0aGVhc2UtZ2tlLWhhY2thdGhvblxcZnJvbnRlbmRcXG15LWFwcFxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxjb21waWxlZFxccmVhY3RcXGNqc1xccmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiZcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICAgICAgaWYgKG51bGwgPT0gdHlwZSkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgcmV0dXJuIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0VcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgICBjYXNlIFJFQUNUX0FDVElWSVRZX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiQWN0aXZpdHlcIjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHR5cGUudGFnICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgdHlwZS4kJHR5cGVvZilcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuICh0eXBlLl9jb250ZXh0LmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgdmFyIGlubmVyVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuZGlzcGxheU5hbWU7XG4gICAgICAgICAgICB0eXBlIHx8XG4gICAgICAgICAgICAgICgodHlwZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgKHR5cGUgPSBcIlwiICE9PSB0eXBlID8gXCJGb3J3YXJkUmVmKFwiICsgdHlwZSArIFwiKVwiIDogXCJGb3J3YXJkUmVmXCIpKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGlubmVyVHlwZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbCksXG4gICAgICAgICAgICAgIG51bGwgIT09IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgID8gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgOiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCBcIk1lbW9cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIGlubmVyVHlwZSA9IHR5cGUuX3BheWxvYWQ7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZShpbm5lclR5cGUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITA7XG4gICAgICB9XG4gICAgICBpZiAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGNvbnNvbGU7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX3RlbXBfY29uc3QgPSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuZXJyb3I7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPVxuICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBTeW1ib2wgJiZcbiAgICAgICAgICAgIFN5bWJvbC50b1N0cmluZ1RhZyAmJlxuICAgICAgICAgICAgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSkgfHxcbiAgICAgICAgICB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8XG4gICAgICAgICAgXCJPYmplY3RcIjtcbiAgICAgICAgSlNDb21waWxlcl90ZW1wX2NvbnN0LmNhbGwoXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LFxuICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFRhc2tOYW1lKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSByZXR1cm4gXCI8PlwiO1xuICAgICAgaWYgKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICBudWxsICE9PSB0eXBlICYmXG4gICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRVxuICAgICAgKVxuICAgICAgICByZXR1cm4gXCI8Li4uPlwiO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHJldHVybiBuYW1lID8gXCI8XCIgKyBuYW1lICsgXCI+XCIgOiBcIjwuLi4+XCI7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHJldHVybiBcIjwuLi4+XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE93bmVyKCkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5BO1xuICAgICAgcmV0dXJuIG51bGwgPT09IGRpc3BhdGNoZXIgPyBudWxsIDogZGlzcGF0Y2hlci5nZXRPd25lcigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBVbmtub3duT3duZXIoKSB7XG4gICAgICByZXR1cm4gRXJyb3IoXCJyZWFjdC1zdGFjay10b3AtZnJhbWVcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcImtleVwiKSkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsIFwia2V5XCIpLmdldDtcbiAgICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbmZpZy5rZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICAgICAgZnVuY3Rpb24gd2FybkFib3V0QWNjZXNzaW5nS2V5KCkge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biB8fFxuICAgICAgICAgICgoc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSAhMCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0LmRldi9saW5rL3NwZWNpYWwtcHJvcHMpXCIsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZVxuICAgICAgICAgICkpO1xuICAgICAgfVxuICAgICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gITA7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsIFwia2V5XCIsIHtcbiAgICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZygpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHRoaXMudHlwZSk7XG4gICAgICBkaWRXYXJuQWJvdXRFbGVtZW50UmVmW2NvbXBvbmVudE5hbWVdIHx8XG4gICAgICAgICgoZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSA9ICEwKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkFjY2Vzc2luZyBlbGVtZW50LnJlZiB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gcmVmIGlzIG5vdyBhIHJlZ3VsYXIgcHJvcC4gSXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEpTWCBFbGVtZW50IHR5cGUgaW4gYSBmdXR1cmUgcmVsZWFzZS5cIlxuICAgICAgICApKTtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSB0aGlzLnByb3BzLnJlZjtcbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbXBvbmVudE5hbWUgPyBjb21wb25lbnROYW1lIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcHJvcHMsIG93bmVyLCBkZWJ1Z1N0YWNrLCBkZWJ1Z1Rhc2spIHtcbiAgICAgIHZhciByZWZQcm9wID0gcHJvcHMucmVmO1xuICAgICAgdHlwZSA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgX293bmVyOiBvd25lclxuICAgICAgfTtcbiAgICAgIG51bGwgIT09ICh2b2lkIDAgIT09IHJlZlByb3AgPyByZWZQcm9wIDogbnVsbClcbiAgICAgICAgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJyZWZcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICBnZXQ6IGVsZW1lbnRSZWZHZXR0ZXJXaXRoRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJyZWZcIiwgeyBlbnVtZXJhYmxlOiAhMSwgdmFsdWU6IG51bGwgfSk7XG4gICAgICB0eXBlLl9zdG9yZSA9IHt9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUuX3N0b3JlLCBcInZhbGlkYXRlZFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiAwXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z0luZm9cIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdTdGFja1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBkZWJ1Z1N0YWNrXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z1Rhc2tcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogZGVidWdUYXNrXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUodHlwZS5wcm9wcyksIE9iamVjdC5mcmVlemUodHlwZSkpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGpzeERFVkltcGwoXG4gICAgICB0eXBlLFxuICAgICAgY29uZmlnLFxuICAgICAgbWF5YmVLZXksXG4gICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgZGVidWdTdGFjayxcbiAgICAgIGRlYnVnVGFza1xuICAgICkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gY29uZmlnLmNoaWxkcmVuO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gY2hpbGRyZW4pXG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKVxuICAgICAgICAgIGlmIChpc0FycmF5SW1wbChjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPSAwO1xuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuIDwgY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuKytcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baXNTdGF0aWNDaGlsZHJlbl0pO1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICBlbHNlIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuKTtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY29uZmlnKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICByZXR1cm4gXCJrZXlcIiAhPT0gaztcbiAgICAgICAgfSk7XG4gICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPVxuICAgICAgICAgIDAgPCBrZXlzLmxlbmd0aFxuICAgICAgICAgICAgPyBcIntrZXk6IHNvbWVLZXksIFwiICsga2V5cy5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCJcbiAgICAgICAgICAgIDogXCJ7a2V5OiBzb21lS2V5fVwiO1xuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSB8fFxuICAgICAgICAgICgoa2V5cyA9XG4gICAgICAgICAgICAwIDwga2V5cy5sZW5ndGggPyBcIntcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiIDogXCJ7fVwiKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ0EgcHJvcHMgb2JqZWN0IGNvbnRhaW5pbmcgYSBcImtleVwiIHByb3AgaXMgYmVpbmcgc3ByZWFkIGludG8gSlNYOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMgey4uLnByb3BzfSAvPlxcblJlYWN0IGtleXMgbXVzdCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gSlNYIHdpdGhvdXQgdXNpbmcgc3ByZWFkOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JyxcbiAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIGtleXMsXG4gICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5BYm91dEtleVNwcmVhZFtjaGlsZHJlbiArIGlzU3RhdGljQ2hpbGRyZW5dID0gITApKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgICAgIHZvaWQgMCAhPT0gbWF5YmVLZXkgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgbWF5YmVLZXkpKTtcbiAgICAgIGhhc1ZhbGlkS2V5KGNvbmZpZykgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSksIChjaGlsZHJlbiA9IFwiXCIgKyBjb25maWcua2V5KSk7XG4gICAgICBpZiAoXCJrZXlcIiBpbiBjb25maWcpIHtcbiAgICAgICAgbWF5YmVLZXkgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gY29uZmlnKVxuICAgICAgICAgIFwia2V5XCIgIT09IHByb3BOYW1lICYmIChtYXliZUtleVtwcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgICAgIH0gZWxzZSBtYXliZUtleSA9IGNvbmZpZztcbiAgICAgIGNoaWxkcmVuICYmXG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKFxuICAgICAgICAgIG1heWJlS2V5LFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGVcbiAgICAgICAgICAgID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgIDogdHlwZVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIFJlYWN0RWxlbWVudChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIG1heWJlS2V5LFxuICAgICAgICBnZXRPd25lcigpLFxuICAgICAgICBkZWJ1Z1N0YWNrLFxuICAgICAgICBkZWJ1Z1Rhc2tcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUpIHtcbiAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBub2RlICYmXG4gICAgICAgIG51bGwgIT09IG5vZGUgJiZcbiAgICAgICAgbm9kZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFICYmXG4gICAgICAgIG5vZGUuX3N0b3JlICYmXG4gICAgICAgIChub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSAxKTtcbiAgICB9XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKSxcbiAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSxcbiAgICAgIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgICAgIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksXG4gICAgICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLFxuICAgICAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSxcbiAgICAgIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29uc3VtZXJcIiksXG4gICAgICBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxcbiAgICAgIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksXG4gICAgICBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcbiAgICAgIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLFxuICAgICAgUkVBQ1RfQUNUSVZJVFlfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5hY3Rpdml0eVwiKSxcbiAgICAgIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzID1cbiAgICAgICAgUmVhY3QuX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFLFxuICAgICAgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5LFxuICAgICAgY3JlYXRlVGFzayA9IGNvbnNvbGUuY3JlYXRlVGFza1xuICAgICAgICA/IGNvbnNvbGUuY3JlYXRlVGFza1xuICAgICAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH07XG4gICAgUmVhY3QgPSB7XG4gICAgICByZWFjdF9zdGFja19ib3R0b21fZnJhbWU6IGZ1bmN0aW9uIChjYWxsU3RhY2tGb3JFcnJvcikge1xuICAgICAgICByZXR1cm4gY2FsbFN0YWNrRm9yRXJyb3IoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbiAgICB2YXIgZGlkV2FybkFib3V0RWxlbWVudFJlZiA9IHt9O1xuICAgIHZhciB1bmtub3duT3duZXJEZWJ1Z1N0YWNrID0gUmVhY3QucmVhY3Rfc3RhY2tfYm90dG9tX2ZyYW1lLmJpbmQoXG4gICAgICBSZWFjdCxcbiAgICAgIFVua25vd25Pd25lclxuICAgICkoKTtcbiAgICB2YXIgdW5rbm93bk93bmVyRGVidWdUYXNrID0gY3JlYXRlVGFzayhnZXRUYXNrTmFtZShVbmtub3duT3duZXIpKTtcbiAgICB2YXIgZGlkV2FybkFib3V0S2V5U3ByZWFkID0ge307XG4gICAgZXhwb3J0cy5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG4gICAgZXhwb3J0cy5qc3hERVYgPSBmdW5jdGlvbiAodHlwZSwgY29uZmlnLCBtYXliZUtleSwgaXNTdGF0aWNDaGlsZHJlbikge1xuICAgICAgdmFyIHRyYWNrQWN0dWFsT3duZXIgPVxuICAgICAgICAxZTQgPiBSZWFjdFNoYXJlZEludGVybmFscy5yZWNlbnRseUNyZWF0ZWRPd25lclN0YWNrcysrO1xuICAgICAgcmV0dXJuIGpzeERFVkltcGwoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgbWF5YmVLZXksXG4gICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgIHRyYWNrQWN0dWFsT3duZXJcbiAgICAgICAgICA/IEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpXG4gICAgICAgICAgOiB1bmtub3duT3duZXJEZWJ1Z1N0YWNrLFxuICAgICAgICB0cmFja0FjdHVhbE93bmVyID8gY3JlYXRlVGFzayhnZXRUYXNrTmFtZSh0eXBlKSkgOiB1bmtub3duT3duZXJEZWJ1Z1Rhc2tcbiAgICAgICk7XG4gICAgfTtcbiAgfSkoKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIkQ6XFxUV0UgR0tFXFx0b3Vyd2l0aGVhc2UtZ2tlLWhhY2thdGhvblxcZnJvbnRlbmRcXG15LWFwcFxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxjb21waWxlZFxccmVhY3RcXGpzeC1kZXYtcnVudGltZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/oidc-client-ts/dist/esm/oidc-client-ts.js":
/*!****************************************************************!*\
  !*** ./node_modules/oidc-client-ts/dist/esm/oidc-client-ts.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AccessTokenEvents: () => (/* binding */ AccessTokenEvents),\n/* harmony export */   CheckSessionIFrame: () => (/* binding */ CheckSessionIFrame),\n/* harmony export */   ErrorResponse: () => (/* binding */ ErrorResponse),\n/* harmony export */   ErrorTimeout: () => (/* binding */ ErrorTimeout),\n/* harmony export */   InMemoryWebStorage: () => (/* binding */ InMemoryWebStorage),\n/* harmony export */   Log: () => (/* binding */ Log),\n/* harmony export */   Logger: () => (/* binding */ Logger),\n/* harmony export */   MetadataService: () => (/* binding */ MetadataService),\n/* harmony export */   OidcClient: () => (/* binding */ OidcClient),\n/* harmony export */   OidcClientSettingsStore: () => (/* binding */ OidcClientSettingsStore),\n/* harmony export */   SessionMonitor: () => (/* binding */ SessionMonitor),\n/* harmony export */   SigninResponse: () => (/* binding */ SigninResponse),\n/* harmony export */   SigninState: () => (/* binding */ SigninState),\n/* harmony export */   SignoutResponse: () => (/* binding */ SignoutResponse),\n/* harmony export */   State: () => (/* binding */ State),\n/* harmony export */   User: () => (/* binding */ User),\n/* harmony export */   UserManager: () => (/* binding */ UserManager),\n/* harmony export */   UserManagerSettingsStore: () => (/* binding */ UserManagerSettingsStore),\n/* harmony export */   Version: () => (/* binding */ Version),\n/* harmony export */   WebStorageStateStore: () => (/* binding */ WebStorageStateStore)\n/* harmony export */ });\n/* harmony import */ var crypto_js_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto-js/core.js */ \"(app-pages-browser)/../../node_modules/crypto-js/core.js\");\n/* harmony import */ var crypto_js_sha256_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto-js/sha256.js */ \"(app-pages-browser)/../../node_modules/crypto-js/sha256.js\");\n/* harmony import */ var crypto_js_enc_base64_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! crypto-js/enc-base64.js */ \"(app-pages-browser)/../../node_modules/crypto-js/enc-base64.js\");\n/* harmony import */ var crypto_js_enc_utf8_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! crypto-js/enc-utf8.js */ \"(app-pages-browser)/../../node_modules/crypto-js/enc-utf8.js\");\n/* harmony import */ var jwt_decode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! jwt-decode */ \"(app-pages-browser)/./node_modules/jwt-decode/build/jwt-decode.esm.js\");\n// src/utils/CryptoUtils.ts\n\n\n\n\n\n// src/utils/Logger.ts\nvar nopLogger = {\n  debug: () => void 0,\n  info: () => void 0,\n  warn: () => void 0,\n  error: () => void 0\n};\nvar level;\nvar logger;\nvar Log = /* @__PURE__ */ ((Log2) => {\n  Log2[Log2[\"NONE\"] = 0] = \"NONE\";\n  Log2[Log2[\"ERROR\"] = 1] = \"ERROR\";\n  Log2[Log2[\"WARN\"] = 2] = \"WARN\";\n  Log2[Log2[\"INFO\"] = 3] = \"INFO\";\n  Log2[Log2[\"DEBUG\"] = 4] = \"DEBUG\";\n  return Log2;\n})(Log || {});\n((Log2) => {\n  function reset() {\n    level = 3 /* INFO */;\n    logger = nopLogger;\n  }\n  Log2.reset = reset;\n  function setLevel(value) {\n    if (!(0 /* NONE */ <= value && value <= 4 /* DEBUG */)) {\n      throw new Error(\"Invalid log level\");\n    }\n    level = value;\n  }\n  Log2.setLevel = setLevel;\n  function setLogger(value) {\n    logger = value;\n  }\n  Log2.setLogger = setLogger;\n})(Log || (Log = {}));\nvar Logger = class {\n  constructor(_name) {\n    this._name = _name;\n  }\n  /* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */\n  debug(...args) {\n    if (level >= 4 /* DEBUG */) {\n      logger.debug(Logger._format(this._name, this._method), ...args);\n    }\n  }\n  info(...args) {\n    if (level >= 3 /* INFO */) {\n      logger.info(Logger._format(this._name, this._method), ...args);\n    }\n  }\n  warn(...args) {\n    if (level >= 2 /* WARN */) {\n      logger.warn(Logger._format(this._name, this._method), ...args);\n    }\n  }\n  error(...args) {\n    if (level >= 1 /* ERROR */) {\n      logger.error(Logger._format(this._name, this._method), ...args);\n    }\n  }\n  /* eslint-enable @typescript-eslint/no-unsafe-enum-comparison */\n  throw(err) {\n    this.error(err);\n    throw err;\n  }\n  create(method) {\n    const methodLogger = Object.create(this);\n    methodLogger._method = method;\n    methodLogger.debug(\"begin\");\n    return methodLogger;\n  }\n  static createStatic(name, staticMethod) {\n    const staticLogger = new Logger(`${name}.${staticMethod}`);\n    staticLogger.debug(\"begin\");\n    return staticLogger;\n  }\n  static _format(name, method) {\n    const prefix = `[${name}]`;\n    return method ? `${prefix} ${method}:` : prefix;\n  }\n  /* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */\n  // helpers for static class methods\n  static debug(name, ...args) {\n    if (level >= 4 /* DEBUG */) {\n      logger.debug(Logger._format(name), ...args);\n    }\n  }\n  static info(name, ...args) {\n    if (level >= 3 /* INFO */) {\n      logger.info(Logger._format(name), ...args);\n    }\n  }\n  static warn(name, ...args) {\n    if (level >= 2 /* WARN */) {\n      logger.warn(Logger._format(name), ...args);\n    }\n  }\n  static error(name, ...args) {\n    if (level >= 1 /* ERROR */) {\n      logger.error(Logger._format(name), ...args);\n    }\n  }\n  /* eslint-enable @typescript-eslint/no-unsafe-enum-comparison */\n};\nLog.reset();\n\n// src/utils/CryptoUtils.ts\nvar UUID_V4_TEMPLATE = \"10000000-1000-4000-8000-100000000000\";\nvar CryptoUtils = class {\n  static _randomWord() {\n    return crypto_js_core_js__WEBPACK_IMPORTED_MODULE_0__.lib.WordArray.random(1).words[0];\n  }\n  /**\n   * Generates RFC4122 version 4 guid\n   */\n  static generateUUIDv4() {\n    const uuid = UUID_V4_TEMPLATE.replace(\n      /[018]/g,\n      (c) => (+c ^ CryptoUtils._randomWord() & 15 >> +c / 4).toString(16)\n    );\n    return uuid.replace(/-/g, \"\");\n  }\n  /**\n   * PKCE: Generate a code verifier\n   */\n  static generateCodeVerifier() {\n    return CryptoUtils.generateUUIDv4() + CryptoUtils.generateUUIDv4() + CryptoUtils.generateUUIDv4();\n  }\n  /**\n   * PKCE: Generate a code challenge\n   */\n  static generateCodeChallenge(code_verifier) {\n    try {\n      const hashed = crypto_js_sha256_js__WEBPACK_IMPORTED_MODULE_1__(code_verifier);\n      return crypto_js_enc_base64_js__WEBPACK_IMPORTED_MODULE_2__.stringify(hashed).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n    } catch (err) {\n      Logger.error(\"CryptoUtils.generateCodeChallenge\", err);\n      throw err;\n    }\n  }\n  /**\n   * Generates a base64-encoded string for a basic auth header\n   */\n  static generateBasicAuth(client_id, client_secret) {\n    const basicAuth = crypto_js_enc_utf8_js__WEBPACK_IMPORTED_MODULE_3__.parse([client_id, client_secret].join(\":\"));\n    return crypto_js_enc_base64_js__WEBPACK_IMPORTED_MODULE_2__.stringify(basicAuth);\n  }\n};\n\n// src/utils/Event.ts\nvar Event = class {\n  constructor(_name) {\n    this._name = _name;\n    this._logger = new Logger(`Event('${this._name}')`);\n    this._callbacks = [];\n  }\n  addHandler(cb) {\n    this._callbacks.push(cb);\n    return () => this.removeHandler(cb);\n  }\n  removeHandler(cb) {\n    const idx = this._callbacks.lastIndexOf(cb);\n    if (idx >= 0) {\n      this._callbacks.splice(idx, 1);\n    }\n  }\n  raise(...ev) {\n    this._logger.debug(\"raise:\", ...ev);\n    for (const cb of this._callbacks) {\n      void cb(...ev);\n    }\n  }\n};\n\n// src/utils/JwtUtils.ts\n\nvar JwtUtils = class {\n  // IMPORTANT: doesn't validate the token\n  static decode(token) {\n    try {\n      return (0,jwt_decode__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(token);\n    } catch (err) {\n      Logger.error(\"JwtUtils.decode\", err);\n      throw err;\n    }\n  }\n};\n\n// src/utils/PopupUtils.ts\nvar PopupUtils = class {\n  /**\n   * Populates a map of window features with a placement centered in front of\n   * the current window. If no explicit width is given, a default value is\n   * binned into [800, 720, 600, 480, 360] based on the current window's width.\n   */\n  static center({ ...features }) {\n    var _a, _b, _c;\n    if (features.width == null)\n      features.width = (_a = [800, 720, 600, 480].find((width) => width <= window.outerWidth / 1.618)) != null ? _a : 360;\n    (_b = features.left) != null ? _b : features.left = Math.max(0, Math.round(window.screenX + (window.outerWidth - features.width) / 2));\n    if (features.height != null)\n      (_c = features.top) != null ? _c : features.top = Math.max(0, Math.round(window.screenY + (window.outerHeight - features.height) / 2));\n    return features;\n  }\n  static serialize(features) {\n    return Object.entries(features).filter(([, value]) => value != null).map(([key, value]) => `${key}=${typeof value !== \"boolean\" ? value : value ? \"yes\" : \"no\"}`).join(\",\");\n  }\n};\n\n// src/utils/Timer.ts\nvar Timer = class extends Event {\n  constructor() {\n    super(...arguments);\n    this._logger = new Logger(`Timer('${this._name}')`);\n    this._timerHandle = null;\n    this._expiration = 0;\n    this._callback = () => {\n      const diff = this._expiration - Timer.getEpochTime();\n      this._logger.debug(\"timer completes in\", diff);\n      if (this._expiration <= Timer.getEpochTime()) {\n        this.cancel();\n        super.raise();\n      }\n    };\n  }\n  // get the time\n  static getEpochTime() {\n    return Math.floor(Date.now() / 1e3);\n  }\n  init(durationInSeconds) {\n    const logger2 = this._logger.create(\"init\");\n    durationInSeconds = Math.max(Math.floor(durationInSeconds), 1);\n    const expiration = Timer.getEpochTime() + durationInSeconds;\n    if (this.expiration === expiration && this._timerHandle) {\n      logger2.debug(\"skipping since already initialized for expiration at\", this.expiration);\n      return;\n    }\n    this.cancel();\n    logger2.debug(\"using duration\", durationInSeconds);\n    this._expiration = expiration;\n    const timerDurationInSeconds = Math.min(durationInSeconds, 5);\n    this._timerHandle = setInterval(this._callback, timerDurationInSeconds * 1e3);\n  }\n  get expiration() {\n    return this._expiration;\n  }\n  cancel() {\n    this._logger.create(\"cancel\");\n    if (this._timerHandle) {\n      clearInterval(this._timerHandle);\n      this._timerHandle = null;\n    }\n  }\n};\n\n// src/utils/UrlUtils.ts\nvar UrlUtils = class {\n  static readParams(url, responseMode = \"query\") {\n    if (!url)\n      throw new TypeError(\"Invalid URL\");\n    const parsedUrl = new URL(url, \"http://127.0.0.1\");\n    const params = parsedUrl[responseMode === \"fragment\" ? \"hash\" : \"search\"];\n    return new URLSearchParams(params.slice(1));\n  }\n};\nvar URL_STATE_DELIMITER = \";\";\n\n// src/errors/ErrorResponse.ts\nvar ErrorResponse = class extends Error {\n  constructor(args, form) {\n    var _a, _b, _c;\n    super(args.error_description || args.error || \"\");\n    this.form = form;\n    /** Marker to detect class: \"ErrorResponse\" */\n    this.name = \"ErrorResponse\";\n    if (!args.error) {\n      Logger.error(\"ErrorResponse\", \"No error passed\");\n      throw new Error(\"No error passed\");\n    }\n    this.error = args.error;\n    this.error_description = (_a = args.error_description) != null ? _a : null;\n    this.error_uri = (_b = args.error_uri) != null ? _b : null;\n    this.state = args.userState;\n    this.session_state = (_c = args.session_state) != null ? _c : null;\n    this.url_state = args.url_state;\n  }\n};\n\n// src/errors/ErrorTimeout.ts\nvar ErrorTimeout = class extends Error {\n  constructor(message) {\n    super(message);\n    /** Marker to detect class: \"ErrorTimeout\" */\n    this.name = \"ErrorTimeout\";\n  }\n};\n\n// src/AccessTokenEvents.ts\nvar AccessTokenEvents = class {\n  constructor(args) {\n    this._logger = new Logger(\"AccessTokenEvents\");\n    this._expiringTimer = new Timer(\"Access token expiring\");\n    this._expiredTimer = new Timer(\"Access token expired\");\n    this._expiringNotificationTimeInSeconds = args.expiringNotificationTimeInSeconds;\n  }\n  load(container) {\n    const logger2 = this._logger.create(\"load\");\n    if (container.access_token && container.expires_in !== void 0) {\n      const duration = container.expires_in;\n      logger2.debug(\"access token present, remaining duration:\", duration);\n      if (duration > 0) {\n        let expiring = duration - this._expiringNotificationTimeInSeconds;\n        if (expiring <= 0) {\n          expiring = 1;\n        }\n        logger2.debug(\"registering expiring timer, raising in\", expiring, \"seconds\");\n        this._expiringTimer.init(expiring);\n      } else {\n        logger2.debug(\"canceling existing expiring timer because we're past expiration.\");\n        this._expiringTimer.cancel();\n      }\n      const expired = duration + 1;\n      logger2.debug(\"registering expired timer, raising in\", expired, \"seconds\");\n      this._expiredTimer.init(expired);\n    } else {\n      this._expiringTimer.cancel();\n      this._expiredTimer.cancel();\n    }\n  }\n  unload() {\n    this._logger.debug(\"unload: canceling existing access token timers\");\n    this._expiringTimer.cancel();\n    this._expiredTimer.cancel();\n  }\n  /**\n   * Add callback: Raised prior to the access token expiring.\n   */\n  addAccessTokenExpiring(cb) {\n    return this._expiringTimer.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised prior to the access token expiring.\n   */\n  removeAccessTokenExpiring(cb) {\n    this._expiringTimer.removeHandler(cb);\n  }\n  /**\n   * Add callback: Raised after the access token has expired.\n   */\n  addAccessTokenExpired(cb) {\n    return this._expiredTimer.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised after the access token has expired.\n   */\n  removeAccessTokenExpired(cb) {\n    this._expiredTimer.removeHandler(cb);\n  }\n};\n\n// src/CheckSessionIFrame.ts\nvar CheckSessionIFrame = class {\n  constructor(_callback, _client_id, url, _intervalInSeconds, _stopOnError) {\n    this._callback = _callback;\n    this._client_id = _client_id;\n    this._intervalInSeconds = _intervalInSeconds;\n    this._stopOnError = _stopOnError;\n    this._logger = new Logger(\"CheckSessionIFrame\");\n    this._timer = null;\n    this._session_state = null;\n    this._message = (e) => {\n      if (e.origin === this._frame_origin && e.source === this._frame.contentWindow) {\n        if (e.data === \"error\") {\n          this._logger.error(\"error message from check session op iframe\");\n          if (this._stopOnError) {\n            this.stop();\n          }\n        } else if (e.data === \"changed\") {\n          this._logger.debug(\"changed message from check session op iframe\");\n          this.stop();\n          void this._callback();\n        } else {\n          this._logger.debug(e.data + \" message from check session op iframe\");\n        }\n      }\n    };\n    const parsedUrl = new URL(url);\n    this._frame_origin = parsedUrl.origin;\n    this._frame = window.document.createElement(\"iframe\");\n    this._frame.style.visibility = \"hidden\";\n    this._frame.style.position = \"fixed\";\n    this._frame.style.left = \"-1000px\";\n    this._frame.style.top = \"0\";\n    this._frame.width = \"0\";\n    this._frame.height = \"0\";\n    this._frame.src = parsedUrl.href;\n  }\n  load() {\n    return new Promise((resolve) => {\n      this._frame.onload = () => {\n        resolve();\n      };\n      window.document.body.appendChild(this._frame);\n      window.addEventListener(\"message\", this._message, false);\n    });\n  }\n  start(session_state) {\n    if (this._session_state === session_state) {\n      return;\n    }\n    this._logger.create(\"start\");\n    this.stop();\n    this._session_state = session_state;\n    const send = () => {\n      if (!this._frame.contentWindow || !this._session_state) {\n        return;\n      }\n      this._frame.contentWindow.postMessage(this._client_id + \" \" + this._session_state, this._frame_origin);\n    };\n    send();\n    this._timer = setInterval(send, this._intervalInSeconds * 1e3);\n  }\n  stop() {\n    this._logger.create(\"stop\");\n    this._session_state = null;\n    if (this._timer) {\n      clearInterval(this._timer);\n      this._timer = null;\n    }\n  }\n};\n\n// src/InMemoryWebStorage.ts\nvar InMemoryWebStorage = class {\n  constructor() {\n    this._logger = new Logger(\"InMemoryWebStorage\");\n    this._data = {};\n  }\n  clear() {\n    this._logger.create(\"clear\");\n    this._data = {};\n  }\n  getItem(key) {\n    this._logger.create(`getItem('${key}')`);\n    return this._data[key];\n  }\n  setItem(key, value) {\n    this._logger.create(`setItem('${key}')`);\n    this._data[key] = value;\n  }\n  removeItem(key) {\n    this._logger.create(`removeItem('${key}')`);\n    delete this._data[key];\n  }\n  get length() {\n    return Object.getOwnPropertyNames(this._data).length;\n  }\n  key(index) {\n    return Object.getOwnPropertyNames(this._data)[index];\n  }\n};\n\n// src/JsonService.ts\nvar JsonService = class {\n  constructor(additionalContentTypes = [], _jwtHandler = null, _extraHeaders = {}) {\n    this._jwtHandler = _jwtHandler;\n    this._extraHeaders = _extraHeaders;\n    this._logger = new Logger(\"JsonService\");\n    this._contentTypes = [];\n    this._contentTypes.push(...additionalContentTypes, \"application/json\");\n    if (_jwtHandler) {\n      this._contentTypes.push(\"application/jwt\");\n    }\n  }\n  async fetchWithTimeout(input, init = {}) {\n    const { timeoutInSeconds, ...initFetch } = init;\n    if (!timeoutInSeconds) {\n      return await fetch(input, initFetch);\n    }\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeoutInSeconds * 1e3);\n    try {\n      const response = await fetch(input, {\n        ...init,\n        signal: controller.signal\n      });\n      return response;\n    } catch (err) {\n      if (err instanceof DOMException && err.name === \"AbortError\") {\n        throw new ErrorTimeout(\"Network timed out\");\n      }\n      throw err;\n    } finally {\n      clearTimeout(timeoutId);\n    }\n  }\n  async getJson(url, {\n    token,\n    credentials\n  } = {}) {\n    const logger2 = this._logger.create(\"getJson\");\n    const headers = {\n      \"Accept\": this._contentTypes.join(\", \")\n    };\n    if (token) {\n      logger2.debug(\"token passed, setting Authorization header\");\n      headers[\"Authorization\"] = \"Bearer \" + token;\n    }\n    this.appendExtraHeaders(headers);\n    let response;\n    try {\n      logger2.debug(\"url:\", url);\n      response = await this.fetchWithTimeout(url, { method: \"GET\", headers, credentials });\n    } catch (err) {\n      logger2.error(\"Network Error\");\n      throw err;\n    }\n    logger2.debug(\"HTTP response received, status\", response.status);\n    const contentType = response.headers.get(\"Content-Type\");\n    if (contentType && !this._contentTypes.find((item) => contentType.startsWith(item))) {\n      logger2.throw(new Error(`Invalid response Content-Type: ${contentType != null ? contentType : \"undefined\"}, from URL: ${url}`));\n    }\n    if (response.ok && this._jwtHandler && (contentType == null ? void 0 : contentType.startsWith(\"application/jwt\"))) {\n      return await this._jwtHandler(await response.text());\n    }\n    let json;\n    try {\n      json = await response.json();\n    } catch (err) {\n      logger2.error(\"Error parsing JSON response\", err);\n      if (response.ok)\n        throw err;\n      throw new Error(`${response.statusText} (${response.status})`);\n    }\n    if (!response.ok) {\n      logger2.error(\"Error from server:\", json);\n      if (json.error) {\n        throw new ErrorResponse(json);\n      }\n      throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);\n    }\n    return json;\n  }\n  async postForm(url, {\n    body,\n    basicAuth,\n    timeoutInSeconds,\n    initCredentials\n  }) {\n    const logger2 = this._logger.create(\"postForm\");\n    const headers = {\n      \"Accept\": this._contentTypes.join(\", \"),\n      \"Content-Type\": \"application/x-www-form-urlencoded\"\n    };\n    if (basicAuth !== void 0) {\n      headers[\"Authorization\"] = \"Basic \" + basicAuth;\n    }\n    this.appendExtraHeaders(headers);\n    let response;\n    try {\n      logger2.debug(\"url:\", url);\n      response = await this.fetchWithTimeout(url, { method: \"POST\", headers, body, timeoutInSeconds, credentials: initCredentials });\n    } catch (err) {\n      logger2.error(\"Network error\");\n      throw err;\n    }\n    logger2.debug(\"HTTP response received, status\", response.status);\n    const contentType = response.headers.get(\"Content-Type\");\n    if (contentType && !this._contentTypes.find((item) => contentType.startsWith(item))) {\n      throw new Error(`Invalid response Content-Type: ${contentType != null ? contentType : \"undefined\"}, from URL: ${url}`);\n    }\n    const responseText = await response.text();\n    let json = {};\n    if (responseText) {\n      try {\n        json = JSON.parse(responseText);\n      } catch (err) {\n        logger2.error(\"Error parsing JSON response\", err);\n        if (response.ok)\n          throw err;\n        throw new Error(`${response.statusText} (${response.status})`);\n      }\n    }\n    if (!response.ok) {\n      logger2.error(\"Error from server:\", json);\n      if (json.error) {\n        throw new ErrorResponse(json, body);\n      }\n      throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);\n    }\n    return json;\n  }\n  appendExtraHeaders(headers) {\n    const logger2 = this._logger.create(\"appendExtraHeaders\");\n    const customKeys = Object.keys(this._extraHeaders);\n    const protectedHeaders = [\n      \"authorization\",\n      \"accept\",\n      \"content-type\"\n    ];\n    if (customKeys.length === 0) {\n      return;\n    }\n    customKeys.forEach((headerName) => {\n      if (protectedHeaders.includes(headerName.toLocaleLowerCase())) {\n        logger2.warn(\"Protected header could not be overridden\", headerName, protectedHeaders);\n        return;\n      }\n      const content = typeof this._extraHeaders[headerName] === \"function\" ? this._extraHeaders[headerName]() : this._extraHeaders[headerName];\n      if (content && content !== \"\") {\n        headers[headerName] = content;\n      }\n    });\n  }\n};\n\n// src/MetadataService.ts\nvar MetadataService = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"MetadataService\");\n    this._signingKeys = null;\n    this._metadata = null;\n    this._metadataUrl = this._settings.metadataUrl;\n    this._jsonService = new JsonService(\n      [\"application/jwk-set+json\"],\n      null,\n      this._settings.extraHeaders\n    );\n    if (this._settings.signingKeys) {\n      this._logger.debug(\"using signingKeys from settings\");\n      this._signingKeys = this._settings.signingKeys;\n    }\n    if (this._settings.metadata) {\n      this._logger.debug(\"using metadata from settings\");\n      this._metadata = this._settings.metadata;\n    }\n    if (this._settings.fetchRequestCredentials) {\n      this._logger.debug(\"using fetchRequestCredentials from settings\");\n      this._fetchRequestCredentials = this._settings.fetchRequestCredentials;\n    }\n  }\n  resetSigningKeys() {\n    this._signingKeys = null;\n  }\n  async getMetadata() {\n    const logger2 = this._logger.create(\"getMetadata\");\n    if (this._metadata) {\n      logger2.debug(\"using cached values\");\n      return this._metadata;\n    }\n    if (!this._metadataUrl) {\n      logger2.throw(new Error(\"No authority or metadataUrl configured on settings\"));\n      throw null;\n    }\n    logger2.debug(\"getting metadata from\", this._metadataUrl);\n    const metadata = await this._jsonService.getJson(this._metadataUrl, { credentials: this._fetchRequestCredentials });\n    logger2.debug(\"merging remote JSON with seed metadata\");\n    this._metadata = Object.assign({}, this._settings.metadataSeed, metadata);\n    return this._metadata;\n  }\n  getIssuer() {\n    return this._getMetadataProperty(\"issuer\");\n  }\n  getAuthorizationEndpoint() {\n    return this._getMetadataProperty(\"authorization_endpoint\");\n  }\n  getUserInfoEndpoint() {\n    return this._getMetadataProperty(\"userinfo_endpoint\");\n  }\n  getTokenEndpoint(optional = true) {\n    return this._getMetadataProperty(\"token_endpoint\", optional);\n  }\n  getCheckSessionIframe() {\n    return this._getMetadataProperty(\"check_session_iframe\", true);\n  }\n  getEndSessionEndpoint() {\n    return this._getMetadataProperty(\"end_session_endpoint\", true);\n  }\n  getRevocationEndpoint(optional = true) {\n    return this._getMetadataProperty(\"revocation_endpoint\", optional);\n  }\n  getKeysEndpoint(optional = true) {\n    return this._getMetadataProperty(\"jwks_uri\", optional);\n  }\n  async _getMetadataProperty(name, optional = false) {\n    const logger2 = this._logger.create(`_getMetadataProperty('${name}')`);\n    const metadata = await this.getMetadata();\n    logger2.debug(\"resolved\");\n    if (metadata[name] === void 0) {\n      if (optional === true) {\n        logger2.warn(\"Metadata does not contain optional property\");\n        return void 0;\n      }\n      logger2.throw(new Error(\"Metadata does not contain property \" + name));\n    }\n    return metadata[name];\n  }\n  async getSigningKeys() {\n    const logger2 = this._logger.create(\"getSigningKeys\");\n    if (this._signingKeys) {\n      logger2.debug(\"returning signingKeys from cache\");\n      return this._signingKeys;\n    }\n    const jwks_uri = await this.getKeysEndpoint(false);\n    logger2.debug(\"got jwks_uri\", jwks_uri);\n    const keySet = await this._jsonService.getJson(jwks_uri);\n    logger2.debug(\"got key set\", keySet);\n    if (!Array.isArray(keySet.keys)) {\n      logger2.throw(new Error(\"Missing keys on keyset\"));\n      throw null;\n    }\n    this._signingKeys = keySet.keys;\n    return this._signingKeys;\n  }\n};\n\n// src/WebStorageStateStore.ts\nvar WebStorageStateStore = class {\n  constructor({\n    prefix = \"oidc.\",\n    store = localStorage\n  } = {}) {\n    this._logger = new Logger(\"WebStorageStateStore\");\n    this._store = store;\n    this._prefix = prefix;\n  }\n  async set(key, value) {\n    this._logger.create(`set('${key}')`);\n    key = this._prefix + key;\n    await this._store.setItem(key, value);\n  }\n  async get(key) {\n    this._logger.create(`get('${key}')`);\n    key = this._prefix + key;\n    const item = await this._store.getItem(key);\n    return item;\n  }\n  async remove(key) {\n    this._logger.create(`remove('${key}')`);\n    key = this._prefix + key;\n    const item = await this._store.getItem(key);\n    await this._store.removeItem(key);\n    return item;\n  }\n  async getAllKeys() {\n    this._logger.create(\"getAllKeys\");\n    const len = await this._store.length;\n    const keys = [];\n    for (let index = 0; index < len; index++) {\n      const key = await this._store.key(index);\n      if (key && key.indexOf(this._prefix) === 0) {\n        keys.push(key.substr(this._prefix.length));\n      }\n    }\n    return keys;\n  }\n};\n\n// src/OidcClientSettings.ts\nvar DefaultResponseType = \"code\";\nvar DefaultScope = \"openid\";\nvar DefaultClientAuthentication = \"client_secret_post\";\nvar DefaultResponseMode = \"query\";\nvar DefaultStaleStateAgeInSeconds = 60 * 15;\nvar DefaultClockSkewInSeconds = 60 * 5;\nvar OidcClientSettingsStore = class {\n  constructor({\n    // metadata related\n    authority,\n    metadataUrl,\n    metadata,\n    signingKeys,\n    metadataSeed,\n    // client related\n    client_id,\n    client_secret,\n    response_type = DefaultResponseType,\n    scope = DefaultScope,\n    redirect_uri,\n    post_logout_redirect_uri,\n    client_authentication = DefaultClientAuthentication,\n    // optional protocol\n    prompt,\n    display,\n    max_age,\n    ui_locales,\n    acr_values,\n    resource,\n    response_mode = DefaultResponseMode,\n    // behavior flags\n    filterProtocolClaims = true,\n    loadUserInfo = false,\n    staleStateAgeInSeconds = DefaultStaleStateAgeInSeconds,\n    clockSkewInSeconds = DefaultClockSkewInSeconds,\n    userInfoJwtIssuer = \"OP\",\n    mergeClaims = false,\n    disablePKCE = false,\n    // other behavior\n    stateStore,\n    refreshTokenCredentials,\n    revokeTokenAdditionalContentTypes,\n    fetchRequestCredentials,\n    refreshTokenAllowedScope,\n    // extra\n    extraQueryParams = {},\n    extraTokenParams = {},\n    extraHeaders = {}\n  }) {\n    this.authority = authority;\n    if (metadataUrl) {\n      this.metadataUrl = metadataUrl;\n    } else {\n      this.metadataUrl = authority;\n      if (authority) {\n        if (!this.metadataUrl.endsWith(\"/\")) {\n          this.metadataUrl += \"/\";\n        }\n        this.metadataUrl += \".well-known/openid-configuration\";\n      }\n    }\n    this.metadata = metadata;\n    this.metadataSeed = metadataSeed;\n    this.signingKeys = signingKeys;\n    this.client_id = client_id;\n    this.client_secret = client_secret;\n    this.response_type = response_type;\n    this.scope = scope;\n    this.redirect_uri = redirect_uri;\n    this.post_logout_redirect_uri = post_logout_redirect_uri;\n    this.client_authentication = client_authentication;\n    this.prompt = prompt;\n    this.display = display;\n    this.max_age = max_age;\n    this.ui_locales = ui_locales;\n    this.acr_values = acr_values;\n    this.resource = resource;\n    this.response_mode = response_mode;\n    this.filterProtocolClaims = filterProtocolClaims != null ? filterProtocolClaims : true;\n    this.loadUserInfo = !!loadUserInfo;\n    this.staleStateAgeInSeconds = staleStateAgeInSeconds;\n    this.clockSkewInSeconds = clockSkewInSeconds;\n    this.userInfoJwtIssuer = userInfoJwtIssuer;\n    this.mergeClaims = !!mergeClaims;\n    this.disablePKCE = !!disablePKCE;\n    this.revokeTokenAdditionalContentTypes = revokeTokenAdditionalContentTypes;\n    if (fetchRequestCredentials && refreshTokenCredentials) {\n      console.warn(\"Both fetchRequestCredentials and refreshTokenCredentials is set. Only fetchRequestCredentials will be used.\");\n    }\n    this.fetchRequestCredentials = fetchRequestCredentials ? fetchRequestCredentials : refreshTokenCredentials ? refreshTokenCredentials : \"same-origin\";\n    if (stateStore) {\n      this.stateStore = stateStore;\n    } else {\n      const store = typeof window !== \"undefined\" ? window.localStorage : new InMemoryWebStorage();\n      this.stateStore = new WebStorageStateStore({ store });\n    }\n    this.refreshTokenAllowedScope = refreshTokenAllowedScope;\n    this.extraQueryParams = extraQueryParams;\n    this.extraTokenParams = extraTokenParams;\n    this.extraHeaders = extraHeaders;\n  }\n};\n\n// src/UserInfoService.ts\nvar UserInfoService = class {\n  constructor(_settings, _metadataService) {\n    this._settings = _settings;\n    this._metadataService = _metadataService;\n    this._logger = new Logger(\"UserInfoService\");\n    this._getClaimsFromJwt = async (responseText) => {\n      const logger2 = this._logger.create(\"_getClaimsFromJwt\");\n      try {\n        const payload = JwtUtils.decode(responseText);\n        logger2.debug(\"JWT decoding successful\");\n        return payload;\n      } catch (err) {\n        logger2.error(\"Error parsing JWT response\");\n        throw err;\n      }\n    };\n    this._jsonService = new JsonService(\n      void 0,\n      this._getClaimsFromJwt,\n      this._settings.extraHeaders\n    );\n  }\n  async getClaims(token) {\n    const logger2 = this._logger.create(\"getClaims\");\n    if (!token) {\n      this._logger.throw(new Error(\"No token passed\"));\n    }\n    const url = await this._metadataService.getUserInfoEndpoint();\n    logger2.debug(\"got userinfo url\", url);\n    const claims = await this._jsonService.getJson(url, {\n      token,\n      credentials: this._settings.fetchRequestCredentials\n    });\n    logger2.debug(\"got claims\", claims);\n    return claims;\n  }\n};\n\n// src/TokenClient.ts\nvar TokenClient = class {\n  constructor(_settings, _metadataService) {\n    this._settings = _settings;\n    this._metadataService = _metadataService;\n    this._logger = new Logger(\"TokenClient\");\n    this._jsonService = new JsonService(\n      this._settings.revokeTokenAdditionalContentTypes,\n      null,\n      this._settings.extraHeaders\n    );\n  }\n  /**\n   * Exchange code.\n   *\n   * @see https://www.rfc-editor.org/rfc/rfc6749#section-4.1.3\n   */\n  async exchangeCode({\n    grant_type = \"authorization_code\",\n    redirect_uri = this._settings.redirect_uri,\n    client_id = this._settings.client_id,\n    client_secret = this._settings.client_secret,\n    ...args\n  }) {\n    const logger2 = this._logger.create(\"exchangeCode\");\n    if (!client_id) {\n      logger2.throw(new Error(\"A client_id is required\"));\n    }\n    if (!redirect_uri) {\n      logger2.throw(new Error(\"A redirect_uri is required\"));\n    }\n    if (!args.code) {\n      logger2.throw(new Error(\"A code is required\"));\n    }\n    const params = new URLSearchParams({ grant_type, redirect_uri });\n    for (const [key, value] of Object.entries(args)) {\n      if (value != null) {\n        params.set(key, value);\n      }\n    }\n    let basicAuth;\n    switch (this._settings.client_authentication) {\n      case \"client_secret_basic\":\n        if (!client_secret) {\n          logger2.throw(new Error(\"A client_secret is required\"));\n          throw null;\n        }\n        basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n        break;\n      case \"client_secret_post\":\n        params.append(\"client_id\", client_id);\n        if (client_secret) {\n          params.append(\"client_secret\", client_secret);\n        }\n        break;\n    }\n    const url = await this._metadataService.getTokenEndpoint(false);\n    logger2.debug(\"got token endpoint\");\n    const response = await this._jsonService.postForm(url, { body: params, basicAuth, initCredentials: this._settings.fetchRequestCredentials });\n    logger2.debug(\"got response\");\n    return response;\n  }\n  /**\n   * Exchange credentials.\n   *\n   * @see https://www.rfc-editor.org/rfc/rfc6749#section-4.3.2\n   */\n  async exchangeCredentials({\n    grant_type = \"password\",\n    client_id = this._settings.client_id,\n    client_secret = this._settings.client_secret,\n    scope = this._settings.scope,\n    ...args\n  }) {\n    const logger2 = this._logger.create(\"exchangeCredentials\");\n    if (!client_id) {\n      logger2.throw(new Error(\"A client_id is required\"));\n    }\n    const params = new URLSearchParams({ grant_type, scope });\n    for (const [key, value] of Object.entries(args)) {\n      if (value != null) {\n        params.set(key, value);\n      }\n    }\n    let basicAuth;\n    switch (this._settings.client_authentication) {\n      case \"client_secret_basic\":\n        if (!client_secret) {\n          logger2.throw(new Error(\"A client_secret is required\"));\n          throw null;\n        }\n        basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n        break;\n      case \"client_secret_post\":\n        params.append(\"client_id\", client_id);\n        if (client_secret) {\n          params.append(\"client_secret\", client_secret);\n        }\n        break;\n    }\n    const url = await this._metadataService.getTokenEndpoint(false);\n    logger2.debug(\"got token endpoint\");\n    const response = await this._jsonService.postForm(url, { body: params, basicAuth, initCredentials: this._settings.fetchRequestCredentials });\n    logger2.debug(\"got response\");\n    return response;\n  }\n  /**\n   * Exchange a refresh token.\n   *\n   * @see https://www.rfc-editor.org/rfc/rfc6749#section-6\n   */\n  async exchangeRefreshToken({\n    grant_type = \"refresh_token\",\n    client_id = this._settings.client_id,\n    client_secret = this._settings.client_secret,\n    timeoutInSeconds,\n    ...args\n  }) {\n    const logger2 = this._logger.create(\"exchangeRefreshToken\");\n    if (!client_id) {\n      logger2.throw(new Error(\"A client_id is required\"));\n    }\n    if (!args.refresh_token) {\n      logger2.throw(new Error(\"A refresh_token is required\"));\n    }\n    const params = new URLSearchParams({ grant_type });\n    for (const [key, value] of Object.entries(args)) {\n      if (Array.isArray(value)) {\n        value.forEach((param) => params.append(key, param));\n      } else if (value != null) {\n        params.set(key, value);\n      }\n    }\n    let basicAuth;\n    switch (this._settings.client_authentication) {\n      case \"client_secret_basic\":\n        if (!client_secret) {\n          logger2.throw(new Error(\"A client_secret is required\"));\n          throw null;\n        }\n        basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n        break;\n      case \"client_secret_post\":\n        params.append(\"client_id\", client_id);\n        if (client_secret) {\n          params.append(\"client_secret\", client_secret);\n        }\n        break;\n    }\n    const url = await this._metadataService.getTokenEndpoint(false);\n    logger2.debug(\"got token endpoint\");\n    const response = await this._jsonService.postForm(url, { body: params, basicAuth, timeoutInSeconds, initCredentials: this._settings.fetchRequestCredentials });\n    logger2.debug(\"got response\");\n    return response;\n  }\n  /**\n   * Revoke an access or refresh token.\n   *\n   * @see https://datatracker.ietf.org/doc/html/rfc7009#section-2.1\n   */\n  async revoke(args) {\n    var _a;\n    const logger2 = this._logger.create(\"revoke\");\n    if (!args.token) {\n      logger2.throw(new Error(\"A token is required\"));\n    }\n    const url = await this._metadataService.getRevocationEndpoint(false);\n    logger2.debug(`got revocation endpoint, revoking ${(_a = args.token_type_hint) != null ? _a : \"default token type\"}`);\n    const params = new URLSearchParams();\n    for (const [key, value] of Object.entries(args)) {\n      if (value != null) {\n        params.set(key, value);\n      }\n    }\n    params.set(\"client_id\", this._settings.client_id);\n    if (this._settings.client_secret) {\n      params.set(\"client_secret\", this._settings.client_secret);\n    }\n    await this._jsonService.postForm(url, { body: params });\n    logger2.debug(\"got response\");\n  }\n};\n\n// src/ResponseValidator.ts\nvar ResponseValidator = class {\n  constructor(_settings, _metadataService, _claimsService) {\n    this._settings = _settings;\n    this._metadataService = _metadataService;\n    this._claimsService = _claimsService;\n    this._logger = new Logger(\"ResponseValidator\");\n    this._userInfoService = new UserInfoService(this._settings, this._metadataService);\n    this._tokenClient = new TokenClient(this._settings, this._metadataService);\n  }\n  async validateSigninResponse(response, state) {\n    const logger2 = this._logger.create(\"validateSigninResponse\");\n    this._processSigninState(response, state);\n    logger2.debug(\"state processed\");\n    await this._processCode(response, state);\n    logger2.debug(\"code processed\");\n    if (response.isOpenId) {\n      this._validateIdTokenAttributes(response);\n    }\n    logger2.debug(\"tokens validated\");\n    await this._processClaims(response, state == null ? void 0 : state.skipUserInfo, response.isOpenId);\n    logger2.debug(\"claims processed\");\n  }\n  async validateCredentialsResponse(response, skipUserInfo) {\n    const logger2 = this._logger.create(\"validateCredentialsResponse\");\n    if (response.isOpenId && !!response.id_token) {\n      this._validateIdTokenAttributes(response);\n    }\n    logger2.debug(\"tokens validated\");\n    await this._processClaims(response, skipUserInfo, response.isOpenId);\n    logger2.debug(\"claims processed\");\n  }\n  async validateRefreshResponse(response, state) {\n    var _a, _b;\n    const logger2 = this._logger.create(\"validateRefreshResponse\");\n    response.userState = state.data;\n    (_a = response.session_state) != null ? _a : response.session_state = state.session_state;\n    (_b = response.scope) != null ? _b : response.scope = state.scope;\n    if (response.isOpenId && !!response.id_token) {\n      this._validateIdTokenAttributes(response, state.id_token);\n      logger2.debug(\"ID Token validated\");\n    }\n    if (!response.id_token) {\n      response.id_token = state.id_token;\n      response.profile = state.profile;\n    }\n    const hasIdToken = response.isOpenId && !!response.id_token;\n    await this._processClaims(response, false, hasIdToken);\n    logger2.debug(\"claims processed\");\n  }\n  validateSignoutResponse(response, state) {\n    const logger2 = this._logger.create(\"validateSignoutResponse\");\n    if (state.id !== response.state) {\n      logger2.throw(new Error(\"State does not match\"));\n    }\n    logger2.debug(\"state validated\");\n    response.userState = state.data;\n    if (response.error) {\n      logger2.warn(\"Response was error\", response.error);\n      throw new ErrorResponse(response);\n    }\n  }\n  _processSigninState(response, state) {\n    var _a;\n    const logger2 = this._logger.create(\"_processSigninState\");\n    if (state.id !== response.state) {\n      logger2.throw(new Error(\"State does not match\"));\n    }\n    if (!state.client_id) {\n      logger2.throw(new Error(\"No client_id on state\"));\n    }\n    if (!state.authority) {\n      logger2.throw(new Error(\"No authority on state\"));\n    }\n    if (this._settings.authority !== state.authority) {\n      logger2.throw(new Error(\"authority mismatch on settings vs. signin state\"));\n    }\n    if (this._settings.client_id && this._settings.client_id !== state.client_id) {\n      logger2.throw(new Error(\"client_id mismatch on settings vs. signin state\"));\n    }\n    logger2.debug(\"state validated\");\n    response.userState = state.data;\n    response.url_state = state.url_state;\n    (_a = response.scope) != null ? _a : response.scope = state.scope;\n    if (response.error) {\n      logger2.warn(\"Response was error\", response.error);\n      throw new ErrorResponse(response);\n    }\n    if (state.code_verifier && !response.code) {\n      logger2.throw(new Error(\"Expected code in response\"));\n    }\n  }\n  async _processClaims(response, skipUserInfo = false, validateSub = true) {\n    const logger2 = this._logger.create(\"_processClaims\");\n    response.profile = this._claimsService.filterProtocolClaims(response.profile);\n    if (skipUserInfo || !this._settings.loadUserInfo || !response.access_token) {\n      logger2.debug(\"not loading user info\");\n      return;\n    }\n    logger2.debug(\"loading user info\");\n    const claims = await this._userInfoService.getClaims(response.access_token);\n    logger2.debug(\"user info claims received from user info endpoint\");\n    if (validateSub && claims.sub !== response.profile.sub) {\n      logger2.throw(new Error(\"subject from UserInfo response does not match subject in ID Token\"));\n    }\n    response.profile = this._claimsService.mergeClaims(response.profile, this._claimsService.filterProtocolClaims(claims));\n    logger2.debug(\"user info claims received, updated profile:\", response.profile);\n  }\n  async _processCode(response, state) {\n    const logger2 = this._logger.create(\"_processCode\");\n    if (response.code) {\n      logger2.debug(\"Validating code\");\n      const tokenResponse = await this._tokenClient.exchangeCode({\n        client_id: state.client_id,\n        client_secret: state.client_secret,\n        code: response.code,\n        redirect_uri: state.redirect_uri,\n        code_verifier: state.code_verifier,\n        ...state.extraTokenParams\n      });\n      Object.assign(response, tokenResponse);\n    } else {\n      logger2.debug(\"No code to process\");\n    }\n  }\n  _validateIdTokenAttributes(response, existingToken) {\n    var _a;\n    const logger2 = this._logger.create(\"_validateIdTokenAttributes\");\n    logger2.debug(\"decoding ID Token JWT\");\n    const incoming = JwtUtils.decode((_a = response.id_token) != null ? _a : \"\");\n    if (!incoming.sub) {\n      logger2.throw(new Error(\"ID Token is missing a subject claim\"));\n    }\n    if (existingToken) {\n      const existing = JwtUtils.decode(existingToken);\n      if (incoming.sub !== existing.sub) {\n        logger2.throw(new Error(\"sub in id_token does not match current sub\"));\n      }\n      if (incoming.auth_time && incoming.auth_time !== existing.auth_time) {\n        logger2.throw(new Error(\"auth_time in id_token does not match original auth_time\"));\n      }\n      if (incoming.azp && incoming.azp !== existing.azp) {\n        logger2.throw(new Error(\"azp in id_token does not match original azp\"));\n      }\n      if (!incoming.azp && existing.azp) {\n        logger2.throw(new Error(\"azp not in id_token, but present in original id_token\"));\n      }\n    }\n    response.profile = incoming;\n  }\n};\n\n// src/State.ts\nvar State = class {\n  constructor(args) {\n    this.id = args.id || CryptoUtils.generateUUIDv4();\n    this.data = args.data;\n    if (args.created && args.created > 0) {\n      this.created = args.created;\n    } else {\n      this.created = Timer.getEpochTime();\n    }\n    this.request_type = args.request_type;\n    this.url_state = args.url_state;\n  }\n  toStorageString() {\n    new Logger(\"State\").create(\"toStorageString\");\n    return JSON.stringify({\n      id: this.id,\n      data: this.data,\n      created: this.created,\n      request_type: this.request_type,\n      url_state: this.url_state\n    });\n  }\n  static fromStorageString(storageString) {\n    Logger.createStatic(\"State\", \"fromStorageString\");\n    return new State(JSON.parse(storageString));\n  }\n  static async clearStaleState(storage, age) {\n    const logger2 = Logger.createStatic(\"State\", \"clearStaleState\");\n    const cutoff = Timer.getEpochTime() - age;\n    const keys = await storage.getAllKeys();\n    logger2.debug(\"got keys\", keys);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const item = await storage.get(key);\n      let remove = false;\n      if (item) {\n        try {\n          const state = State.fromStorageString(item);\n          logger2.debug(\"got item from key:\", key, state.created);\n          if (state.created <= cutoff) {\n            remove = true;\n          }\n        } catch (err) {\n          logger2.error(\"Error parsing state for key:\", key, err);\n          remove = true;\n        }\n      } else {\n        logger2.debug(\"no item in storage for key:\", key);\n        remove = true;\n      }\n      if (remove) {\n        logger2.debug(\"removed item for key:\", key);\n        void storage.remove(key);\n      }\n    }\n  }\n};\n\n// src/SigninState.ts\nvar SigninState = class extends State {\n  constructor(args) {\n    super(args);\n    if (args.code_verifier === true) {\n      this.code_verifier = CryptoUtils.generateCodeVerifier();\n    } else if (args.code_verifier) {\n      this.code_verifier = args.code_verifier;\n    }\n    if (this.code_verifier) {\n      this.code_challenge = CryptoUtils.generateCodeChallenge(this.code_verifier);\n    }\n    this.authority = args.authority;\n    this.client_id = args.client_id;\n    this.redirect_uri = args.redirect_uri;\n    this.scope = args.scope;\n    this.client_secret = args.client_secret;\n    this.extraTokenParams = args.extraTokenParams;\n    this.response_mode = args.response_mode;\n    this.skipUserInfo = args.skipUserInfo;\n  }\n  toStorageString() {\n    new Logger(\"SigninState\").create(\"toStorageString\");\n    return JSON.stringify({\n      id: this.id,\n      data: this.data,\n      created: this.created,\n      request_type: this.request_type,\n      url_state: this.url_state,\n      code_verifier: this.code_verifier,\n      authority: this.authority,\n      client_id: this.client_id,\n      redirect_uri: this.redirect_uri,\n      scope: this.scope,\n      client_secret: this.client_secret,\n      extraTokenParams: this.extraTokenParams,\n      response_mode: this.response_mode,\n      skipUserInfo: this.skipUserInfo\n    });\n  }\n  static fromStorageString(storageString) {\n    Logger.createStatic(\"SigninState\", \"fromStorageString\");\n    const data = JSON.parse(storageString);\n    return new SigninState(data);\n  }\n};\n\n// src/SigninRequest.ts\nvar SigninRequest = class {\n  constructor({\n    // mandatory\n    url,\n    authority,\n    client_id,\n    redirect_uri,\n    response_type,\n    scope,\n    // optional\n    state_data,\n    response_mode,\n    request_type,\n    client_secret,\n    nonce,\n    url_state,\n    resource,\n    skipUserInfo,\n    extraQueryParams,\n    extraTokenParams,\n    disablePKCE,\n    ...optionalParams\n  }) {\n    this._logger = new Logger(\"SigninRequest\");\n    if (!url) {\n      this._logger.error(\"ctor: No url passed\");\n      throw new Error(\"url\");\n    }\n    if (!client_id) {\n      this._logger.error(\"ctor: No client_id passed\");\n      throw new Error(\"client_id\");\n    }\n    if (!redirect_uri) {\n      this._logger.error(\"ctor: No redirect_uri passed\");\n      throw new Error(\"redirect_uri\");\n    }\n    if (!response_type) {\n      this._logger.error(\"ctor: No response_type passed\");\n      throw new Error(\"response_type\");\n    }\n    if (!scope) {\n      this._logger.error(\"ctor: No scope passed\");\n      throw new Error(\"scope\");\n    }\n    if (!authority) {\n      this._logger.error(\"ctor: No authority passed\");\n      throw new Error(\"authority\");\n    }\n    this.state = new SigninState({\n      data: state_data,\n      request_type,\n      url_state,\n      code_verifier: !disablePKCE,\n      client_id,\n      authority,\n      redirect_uri,\n      response_mode,\n      client_secret,\n      scope,\n      extraTokenParams,\n      skipUserInfo\n    });\n    const parsedUrl = new URL(url);\n    parsedUrl.searchParams.append(\"client_id\", client_id);\n    parsedUrl.searchParams.append(\"redirect_uri\", redirect_uri);\n    parsedUrl.searchParams.append(\"response_type\", response_type);\n    parsedUrl.searchParams.append(\"scope\", scope);\n    if (nonce) {\n      parsedUrl.searchParams.append(\"nonce\", nonce);\n    }\n    let state = this.state.id;\n    if (url_state) {\n      state = `${state}${URL_STATE_DELIMITER}${url_state}`;\n    }\n    parsedUrl.searchParams.append(\"state\", state);\n    if (this.state.code_challenge) {\n      parsedUrl.searchParams.append(\"code_challenge\", this.state.code_challenge);\n      parsedUrl.searchParams.append(\"code_challenge_method\", \"S256\");\n    }\n    if (resource) {\n      const resources = Array.isArray(resource) ? resource : [resource];\n      resources.forEach((r) => parsedUrl.searchParams.append(\"resource\", r));\n    }\n    for (const [key, value] of Object.entries({ response_mode, ...optionalParams, ...extraQueryParams })) {\n      if (value != null) {\n        parsedUrl.searchParams.append(key, value.toString());\n      }\n    }\n    this.url = parsedUrl.href;\n  }\n};\n\n// src/SigninResponse.ts\nvar OidcScope = \"openid\";\nvar SigninResponse = class {\n  constructor(params) {\n    /** @see {@link User.access_token} */\n    this.access_token = \"\";\n    /** @see {@link User.token_type} */\n    this.token_type = \"\";\n    /** @see {@link User.profile} */\n    this.profile = {};\n    this.state = params.get(\"state\");\n    this.session_state = params.get(\"session_state\");\n    if (this.state) {\n      const splitState = decodeURIComponent(this.state).split(URL_STATE_DELIMITER);\n      this.state = splitState[0];\n      if (splitState.length > 1) {\n        this.url_state = splitState.slice(1).join(URL_STATE_DELIMITER);\n      }\n    }\n    this.error = params.get(\"error\");\n    this.error_description = params.get(\"error_description\");\n    this.error_uri = params.get(\"error_uri\");\n    this.code = params.get(\"code\");\n  }\n  get expires_in() {\n    if (this.expires_at === void 0) {\n      return void 0;\n    }\n    return this.expires_at - Timer.getEpochTime();\n  }\n  set expires_in(value) {\n    if (typeof value === \"string\")\n      value = Number(value);\n    if (value !== void 0 && value >= 0) {\n      this.expires_at = Math.floor(value) + Timer.getEpochTime();\n    }\n  }\n  get isOpenId() {\n    var _a;\n    return ((_a = this.scope) == null ? void 0 : _a.split(\" \").includes(OidcScope)) || !!this.id_token;\n  }\n};\n\n// src/SignoutRequest.ts\nvar SignoutRequest = class {\n  constructor({\n    url,\n    state_data,\n    id_token_hint,\n    post_logout_redirect_uri,\n    extraQueryParams,\n    request_type,\n    client_id\n  }) {\n    this._logger = new Logger(\"SignoutRequest\");\n    if (!url) {\n      this._logger.error(\"ctor: No url passed\");\n      throw new Error(\"url\");\n    }\n    const parsedUrl = new URL(url);\n    if (id_token_hint) {\n      parsedUrl.searchParams.append(\"id_token_hint\", id_token_hint);\n    }\n    if (client_id) {\n      parsedUrl.searchParams.append(\"client_id\", client_id);\n    }\n    if (post_logout_redirect_uri) {\n      parsedUrl.searchParams.append(\"post_logout_redirect_uri\", post_logout_redirect_uri);\n      if (state_data) {\n        this.state = new State({ data: state_data, request_type });\n        parsedUrl.searchParams.append(\"state\", this.state.id);\n      }\n    }\n    for (const [key, value] of Object.entries({ ...extraQueryParams })) {\n      if (value != null) {\n        parsedUrl.searchParams.append(key, value.toString());\n      }\n    }\n    this.url = parsedUrl.href;\n  }\n};\n\n// src/SignoutResponse.ts\nvar SignoutResponse = class {\n  constructor(params) {\n    this.state = params.get(\"state\");\n    this.error = params.get(\"error\");\n    this.error_description = params.get(\"error_description\");\n    this.error_uri = params.get(\"error_uri\");\n  }\n};\n\n// src/ClaimsService.ts\nvar DefaultProtocolClaims = [\n  \"nbf\",\n  \"jti\",\n  \"auth_time\",\n  \"nonce\",\n  \"acr\",\n  \"amr\",\n  \"azp\",\n  \"at_hash\"\n  // https://openid.net/specs/openid-connect-core-1_0.html#CodeIDToken\n];\nvar InternalRequiredProtocolClaims = [\"sub\", \"iss\", \"aud\", \"exp\", \"iat\"];\nvar ClaimsService = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"ClaimsService\");\n  }\n  filterProtocolClaims(claims) {\n    const result = { ...claims };\n    if (this._settings.filterProtocolClaims) {\n      let protocolClaims;\n      if (Array.isArray(this._settings.filterProtocolClaims)) {\n        protocolClaims = this._settings.filterProtocolClaims;\n      } else {\n        protocolClaims = DefaultProtocolClaims;\n      }\n      for (const claim of protocolClaims) {\n        if (!InternalRequiredProtocolClaims.includes(claim)) {\n          delete result[claim];\n        }\n      }\n    }\n    return result;\n  }\n  mergeClaims(claims1, claims2) {\n    const result = { ...claims1 };\n    for (const [claim, values] of Object.entries(claims2)) {\n      for (const value of Array.isArray(values) ? values : [values]) {\n        const previousValue = result[claim];\n        if (previousValue === void 0) {\n          result[claim] = value;\n        } else if (Array.isArray(previousValue)) {\n          if (!previousValue.includes(value)) {\n            previousValue.push(value);\n          }\n        } else if (result[claim] !== value) {\n          if (typeof value === \"object\" && this._settings.mergeClaims) {\n            result[claim] = this.mergeClaims(previousValue, value);\n          } else {\n            result[claim] = [previousValue, value];\n          }\n        }\n      }\n    }\n    return result;\n  }\n};\n\n// src/OidcClient.ts\nvar OidcClient = class {\n  constructor(settings, metadataService) {\n    this._logger = new Logger(\"OidcClient\");\n    this.settings = settings instanceof OidcClientSettingsStore ? settings : new OidcClientSettingsStore(settings);\n    this.metadataService = metadataService != null ? metadataService : new MetadataService(this.settings);\n    this._claimsService = new ClaimsService(this.settings);\n    this._validator = new ResponseValidator(this.settings, this.metadataService, this._claimsService);\n    this._tokenClient = new TokenClient(this.settings, this.metadataService);\n  }\n  async createSigninRequest({\n    state,\n    request,\n    request_uri,\n    request_type,\n    id_token_hint,\n    login_hint,\n    skipUserInfo,\n    nonce,\n    url_state,\n    response_type = this.settings.response_type,\n    scope = this.settings.scope,\n    redirect_uri = this.settings.redirect_uri,\n    prompt = this.settings.prompt,\n    display = this.settings.display,\n    max_age = this.settings.max_age,\n    ui_locales = this.settings.ui_locales,\n    acr_values = this.settings.acr_values,\n    resource = this.settings.resource,\n    response_mode = this.settings.response_mode,\n    extraQueryParams = this.settings.extraQueryParams,\n    extraTokenParams = this.settings.extraTokenParams\n  }) {\n    const logger2 = this._logger.create(\"createSigninRequest\");\n    if (response_type !== \"code\") {\n      throw new Error(\"Only the Authorization Code flow (with PKCE) is supported\");\n    }\n    const url = await this.metadataService.getAuthorizationEndpoint();\n    logger2.debug(\"Received authorization endpoint\", url);\n    const signinRequest = new SigninRequest({\n      url,\n      authority: this.settings.authority,\n      client_id: this.settings.client_id,\n      redirect_uri,\n      response_type,\n      scope,\n      state_data: state,\n      url_state,\n      prompt,\n      display,\n      max_age,\n      ui_locales,\n      id_token_hint,\n      login_hint,\n      acr_values,\n      resource,\n      request,\n      request_uri,\n      extraQueryParams,\n      extraTokenParams,\n      request_type,\n      response_mode,\n      client_secret: this.settings.client_secret,\n      skipUserInfo,\n      nonce,\n      disablePKCE: this.settings.disablePKCE\n    });\n    await this.clearStaleState();\n    const signinState = signinRequest.state;\n    await this.settings.stateStore.set(signinState.id, signinState.toStorageString());\n    return signinRequest;\n  }\n  async readSigninResponseState(url, removeState = false) {\n    const logger2 = this._logger.create(\"readSigninResponseState\");\n    const response = new SigninResponse(UrlUtils.readParams(url, this.settings.response_mode));\n    if (!response.state) {\n      logger2.throw(new Error(\"No state in response\"));\n      throw null;\n    }\n    const storedStateString = await this.settings.stateStore[removeState ? \"remove\" : \"get\"](response.state);\n    if (!storedStateString) {\n      logger2.throw(new Error(\"No matching state found in storage\"));\n      throw null;\n    }\n    const state = SigninState.fromStorageString(storedStateString);\n    return { state, response };\n  }\n  async processSigninResponse(url) {\n    const logger2 = this._logger.create(\"processSigninResponse\");\n    const { state, response } = await this.readSigninResponseState(url, true);\n    logger2.debug(\"received state from storage; validating response\");\n    await this._validator.validateSigninResponse(response, state);\n    return response;\n  }\n  async processResourceOwnerPasswordCredentials({\n    username,\n    password,\n    skipUserInfo = false,\n    extraTokenParams = {}\n  }) {\n    const tokenResponse = await this._tokenClient.exchangeCredentials({ username, password, ...extraTokenParams });\n    const signinResponse = new SigninResponse(new URLSearchParams());\n    Object.assign(signinResponse, tokenResponse);\n    await this._validator.validateCredentialsResponse(signinResponse, skipUserInfo);\n    return signinResponse;\n  }\n  async useRefreshToken({\n    state,\n    timeoutInSeconds\n  }) {\n    var _a;\n    const logger2 = this._logger.create(\"useRefreshToken\");\n    let scope;\n    if (this.settings.refreshTokenAllowedScope === void 0) {\n      scope = state.scope;\n    } else {\n      const allowableScopes = this.settings.refreshTokenAllowedScope.split(\" \");\n      const providedScopes = ((_a = state.scope) == null ? void 0 : _a.split(\" \")) || [];\n      scope = providedScopes.filter((s) => allowableScopes.includes(s)).join(\" \");\n    }\n    const result = await this._tokenClient.exchangeRefreshToken({\n      refresh_token: state.refresh_token,\n      resource: state.resource,\n      // provide the (possible filtered) scope list\n      scope,\n      timeoutInSeconds\n    });\n    const response = new SigninResponse(new URLSearchParams());\n    Object.assign(response, result);\n    logger2.debug(\"validating response\", response);\n    await this._validator.validateRefreshResponse(response, {\n      ...state,\n      // overide the scope in the state handed over to the validator\n      // so it can set the granted scope to the requested scope in case none is included in the response\n      scope\n    });\n    return response;\n  }\n  async createSignoutRequest({\n    state,\n    id_token_hint,\n    client_id,\n    request_type,\n    post_logout_redirect_uri = this.settings.post_logout_redirect_uri,\n    extraQueryParams = this.settings.extraQueryParams\n  } = {}) {\n    const logger2 = this._logger.create(\"createSignoutRequest\");\n    const url = await this.metadataService.getEndSessionEndpoint();\n    if (!url) {\n      logger2.throw(new Error(\"No end session endpoint\"));\n      throw null;\n    }\n    logger2.debug(\"Received end session endpoint\", url);\n    if (!client_id && post_logout_redirect_uri && !id_token_hint) {\n      client_id = this.settings.client_id;\n    }\n    const request = new SignoutRequest({\n      url,\n      id_token_hint,\n      client_id,\n      post_logout_redirect_uri,\n      state_data: state,\n      extraQueryParams,\n      request_type\n    });\n    await this.clearStaleState();\n    const signoutState = request.state;\n    if (signoutState) {\n      logger2.debug(\"Signout request has state to persist\");\n      await this.settings.stateStore.set(signoutState.id, signoutState.toStorageString());\n    }\n    return request;\n  }\n  async readSignoutResponseState(url, removeState = false) {\n    const logger2 = this._logger.create(\"readSignoutResponseState\");\n    const response = new SignoutResponse(UrlUtils.readParams(url, this.settings.response_mode));\n    if (!response.state) {\n      logger2.debug(\"No state in response\");\n      if (response.error) {\n        logger2.warn(\"Response was error:\", response.error);\n        throw new ErrorResponse(response);\n      }\n      return { state: void 0, response };\n    }\n    const storedStateString = await this.settings.stateStore[removeState ? \"remove\" : \"get\"](response.state);\n    if (!storedStateString) {\n      logger2.throw(new Error(\"No matching state found in storage\"));\n      throw null;\n    }\n    const state = State.fromStorageString(storedStateString);\n    return { state, response };\n  }\n  async processSignoutResponse(url) {\n    const logger2 = this._logger.create(\"processSignoutResponse\");\n    const { state, response } = await this.readSignoutResponseState(url, true);\n    if (state) {\n      logger2.debug(\"Received state from storage; validating response\");\n      this._validator.validateSignoutResponse(response, state);\n    } else {\n      logger2.debug(\"No state from storage; skipping response validation\");\n    }\n    return response;\n  }\n  clearStaleState() {\n    this._logger.create(\"clearStaleState\");\n    return State.clearStaleState(this.settings.stateStore, this.settings.staleStateAgeInSeconds);\n  }\n  async revokeToken(token, type) {\n    this._logger.create(\"revokeToken\");\n    return await this._tokenClient.revoke({\n      token,\n      token_type_hint: type\n    });\n  }\n};\n\n// src/SessionMonitor.ts\nvar SessionMonitor = class {\n  constructor(_userManager) {\n    this._userManager = _userManager;\n    this._logger = new Logger(\"SessionMonitor\");\n    this._start = async (user) => {\n      const session_state = user.session_state;\n      if (!session_state) {\n        return;\n      }\n      const logger2 = this._logger.create(\"_start\");\n      if (user.profile) {\n        this._sub = user.profile.sub;\n        this._sid = user.profile.sid;\n        logger2.debug(\"session_state\", session_state, \", sub\", this._sub);\n      } else {\n        this._sub = void 0;\n        this._sid = void 0;\n        logger2.debug(\"session_state\", session_state, \", anonymous user\");\n      }\n      if (this._checkSessionIFrame) {\n        this._checkSessionIFrame.start(session_state);\n        return;\n      }\n      try {\n        const url = await this._userManager.metadataService.getCheckSessionIframe();\n        if (url) {\n          logger2.debug(\"initializing check session iframe\");\n          const client_id = this._userManager.settings.client_id;\n          const intervalInSeconds = this._userManager.settings.checkSessionIntervalInSeconds;\n          const stopOnError = this._userManager.settings.stopCheckSessionOnError;\n          const checkSessionIFrame = new CheckSessionIFrame(this._callback, client_id, url, intervalInSeconds, stopOnError);\n          await checkSessionIFrame.load();\n          this._checkSessionIFrame = checkSessionIFrame;\n          checkSessionIFrame.start(session_state);\n        } else {\n          logger2.warn(\"no check session iframe found in the metadata\");\n        }\n      } catch (err) {\n        logger2.error(\"Error from getCheckSessionIframe:\", err instanceof Error ? err.message : err);\n      }\n    };\n    this._stop = () => {\n      const logger2 = this._logger.create(\"_stop\");\n      this._sub = void 0;\n      this._sid = void 0;\n      if (this._checkSessionIFrame) {\n        this._checkSessionIFrame.stop();\n      }\n      if (this._userManager.settings.monitorAnonymousSession) {\n        const timerHandle = setInterval(async () => {\n          clearInterval(timerHandle);\n          try {\n            const session = await this._userManager.querySessionStatus();\n            if (session) {\n              const tmpUser = {\n                session_state: session.session_state,\n                profile: session.sub && session.sid ? {\n                  sub: session.sub,\n                  sid: session.sid\n                } : null\n              };\n              void this._start(tmpUser);\n            }\n          } catch (err) {\n            logger2.error(\"error from querySessionStatus\", err instanceof Error ? err.message : err);\n          }\n        }, 1e3);\n      }\n    };\n    this._callback = async () => {\n      const logger2 = this._logger.create(\"_callback\");\n      try {\n        const session = await this._userManager.querySessionStatus();\n        let raiseEvent = true;\n        if (session && this._checkSessionIFrame) {\n          if (session.sub === this._sub) {\n            raiseEvent = false;\n            this._checkSessionIFrame.start(session.session_state);\n            if (session.sid === this._sid) {\n              logger2.debug(\"same sub still logged in at OP, restarting check session iframe; session_state\", session.session_state);\n            } else {\n              logger2.debug(\"same sub still logged in at OP, session state has changed, restarting check session iframe; session_state\", session.session_state);\n              this._userManager.events._raiseUserSessionChanged();\n            }\n          } else {\n            logger2.debug(\"different subject signed into OP\", session.sub);\n          }\n        } else {\n          logger2.debug(\"subject no longer signed into OP\");\n        }\n        if (raiseEvent) {\n          if (this._sub) {\n            this._userManager.events._raiseUserSignedOut();\n          } else {\n            this._userManager.events._raiseUserSignedIn();\n          }\n        } else {\n          logger2.debug(\"no change in session detected, no event to raise\");\n        }\n      } catch (err) {\n        if (this._sub) {\n          logger2.debug(\"Error calling queryCurrentSigninSession; raising signed out event\", err);\n          this._userManager.events._raiseUserSignedOut();\n        }\n      }\n    };\n    if (!_userManager) {\n      this._logger.throw(new Error(\"No user manager passed\"));\n    }\n    this._userManager.events.addUserLoaded(this._start);\n    this._userManager.events.addUserUnloaded(this._stop);\n    this._init().catch((err) => {\n      this._logger.error(err);\n    });\n  }\n  async _init() {\n    this._logger.create(\"_init\");\n    const user = await this._userManager.getUser();\n    if (user) {\n      void this._start(user);\n    } else if (this._userManager.settings.monitorAnonymousSession) {\n      const session = await this._userManager.querySessionStatus();\n      if (session) {\n        const tmpUser = {\n          session_state: session.session_state,\n          profile: session.sub && session.sid ? {\n            sub: session.sub,\n            sid: session.sid\n          } : null\n        };\n        void this._start(tmpUser);\n      }\n    }\n  }\n};\n\n// src/User.ts\nvar User = class {\n  constructor(args) {\n    var _a;\n    this.id_token = args.id_token;\n    this.session_state = (_a = args.session_state) != null ? _a : null;\n    this.access_token = args.access_token;\n    this.refresh_token = args.refresh_token;\n    this.token_type = args.token_type;\n    this.scope = args.scope;\n    this.profile = args.profile;\n    this.expires_at = args.expires_at;\n    this.state = args.userState;\n    this.url_state = args.url_state;\n  }\n  /** Computed number of seconds the access token has remaining. */\n  get expires_in() {\n    if (this.expires_at === void 0) {\n      return void 0;\n    }\n    return this.expires_at - Timer.getEpochTime();\n  }\n  set expires_in(value) {\n    if (value !== void 0) {\n      this.expires_at = Math.floor(value) + Timer.getEpochTime();\n    }\n  }\n  /** Computed value indicating if the access token is expired. */\n  get expired() {\n    const expires_in = this.expires_in;\n    if (expires_in === void 0) {\n      return void 0;\n    }\n    return expires_in <= 0;\n  }\n  /** Array representing the parsed values from the `scope`. */\n  get scopes() {\n    var _a, _b;\n    return (_b = (_a = this.scope) == null ? void 0 : _a.split(\" \")) != null ? _b : [];\n  }\n  toStorageString() {\n    new Logger(\"User\").create(\"toStorageString\");\n    return JSON.stringify({\n      id_token: this.id_token,\n      session_state: this.session_state,\n      access_token: this.access_token,\n      refresh_token: this.refresh_token,\n      token_type: this.token_type,\n      scope: this.scope,\n      profile: this.profile,\n      expires_at: this.expires_at\n    });\n  }\n  static fromStorageString(storageString) {\n    Logger.createStatic(\"User\", \"fromStorageString\");\n    return new User(JSON.parse(storageString));\n  }\n};\n\n// src/navigators/AbstractChildWindow.ts\nvar messageSource = \"oidc-client\";\nvar AbstractChildWindow = class {\n  constructor() {\n    this._abort = new Event(\"Window navigation aborted\");\n    this._disposeHandlers = /* @__PURE__ */ new Set();\n    this._window = null;\n  }\n  async navigate(params) {\n    const logger2 = this._logger.create(\"navigate\");\n    if (!this._window) {\n      throw new Error(\"Attempted to navigate on a disposed window\");\n    }\n    logger2.debug(\"setting URL in window\");\n    this._window.location.replace(params.url);\n    const { url, keepOpen } = await new Promise((resolve, reject) => {\n      const listener = (e) => {\n        var _a;\n        const data = e.data;\n        const origin = (_a = params.scriptOrigin) != null ? _a : window.location.origin;\n        if (e.origin !== origin || (data == null ? void 0 : data.source) !== messageSource) {\n          return;\n        }\n        try {\n          const state = UrlUtils.readParams(data.url, params.response_mode).get(\"state\");\n          if (!state) {\n            logger2.warn(\"no state found in response url\");\n          }\n          if (e.source !== this._window && state !== params.state) {\n            return;\n          }\n        } catch (err) {\n          this._dispose();\n          reject(new Error(\"Invalid response from window\"));\n        }\n        resolve(data);\n      };\n      window.addEventListener(\"message\", listener, false);\n      this._disposeHandlers.add(() => window.removeEventListener(\"message\", listener, false));\n      this._disposeHandlers.add(this._abort.addHandler((reason) => {\n        this._dispose();\n        reject(reason);\n      }));\n    });\n    logger2.debug(\"got response from window\");\n    this._dispose();\n    if (!keepOpen) {\n      this.close();\n    }\n    return { url };\n  }\n  _dispose() {\n    this._logger.create(\"_dispose\");\n    for (const dispose of this._disposeHandlers) {\n      dispose();\n    }\n    this._disposeHandlers.clear();\n  }\n  static _notifyParent(parent, url, keepOpen = false, targetOrigin = window.location.origin) {\n    parent.postMessage({\n      source: messageSource,\n      url,\n      keepOpen\n    }, targetOrigin);\n  }\n};\n\n// src/UserManagerSettings.ts\nvar DefaultPopupWindowFeatures = {\n  location: false,\n  toolbar: false,\n  height: 640,\n  closePopupWindowAfterInSeconds: -1\n};\nvar DefaultPopupTarget = \"_blank\";\nvar DefaultAccessTokenExpiringNotificationTimeInSeconds = 60;\nvar DefaultCheckSessionIntervalInSeconds = 2;\nvar DefaultSilentRequestTimeoutInSeconds = 10;\nvar UserManagerSettingsStore = class extends OidcClientSettingsStore {\n  constructor(args) {\n    const {\n      popup_redirect_uri = args.redirect_uri,\n      popup_post_logout_redirect_uri = args.post_logout_redirect_uri,\n      popupWindowFeatures = DefaultPopupWindowFeatures,\n      popupWindowTarget = DefaultPopupTarget,\n      redirectMethod = \"assign\",\n      redirectTarget = \"self\",\n      iframeNotifyParentOrigin = args.iframeNotifyParentOrigin,\n      iframeScriptOrigin = args.iframeScriptOrigin,\n      silent_redirect_uri = args.redirect_uri,\n      silentRequestTimeoutInSeconds = DefaultSilentRequestTimeoutInSeconds,\n      automaticSilentRenew = true,\n      validateSubOnSilentRenew = true,\n      includeIdTokenInSilentRenew = false,\n      monitorSession = false,\n      monitorAnonymousSession = false,\n      checkSessionIntervalInSeconds = DefaultCheckSessionIntervalInSeconds,\n      query_status_response_type = \"code\",\n      stopCheckSessionOnError = true,\n      revokeTokenTypes = [\"access_token\", \"refresh_token\"],\n      revokeTokensOnSignout = false,\n      includeIdTokenInSilentSignout = false,\n      accessTokenExpiringNotificationTimeInSeconds = DefaultAccessTokenExpiringNotificationTimeInSeconds,\n      userStore\n    } = args;\n    super(args);\n    this.popup_redirect_uri = popup_redirect_uri;\n    this.popup_post_logout_redirect_uri = popup_post_logout_redirect_uri;\n    this.popupWindowFeatures = popupWindowFeatures;\n    this.popupWindowTarget = popupWindowTarget;\n    this.redirectMethod = redirectMethod;\n    this.redirectTarget = redirectTarget;\n    this.iframeNotifyParentOrigin = iframeNotifyParentOrigin;\n    this.iframeScriptOrigin = iframeScriptOrigin;\n    this.silent_redirect_uri = silent_redirect_uri;\n    this.silentRequestTimeoutInSeconds = silentRequestTimeoutInSeconds;\n    this.automaticSilentRenew = automaticSilentRenew;\n    this.validateSubOnSilentRenew = validateSubOnSilentRenew;\n    this.includeIdTokenInSilentRenew = includeIdTokenInSilentRenew;\n    this.monitorSession = monitorSession;\n    this.monitorAnonymousSession = monitorAnonymousSession;\n    this.checkSessionIntervalInSeconds = checkSessionIntervalInSeconds;\n    this.stopCheckSessionOnError = stopCheckSessionOnError;\n    this.query_status_response_type = query_status_response_type;\n    this.revokeTokenTypes = revokeTokenTypes;\n    this.revokeTokensOnSignout = revokeTokensOnSignout;\n    this.includeIdTokenInSilentSignout = includeIdTokenInSilentSignout;\n    this.accessTokenExpiringNotificationTimeInSeconds = accessTokenExpiringNotificationTimeInSeconds;\n    if (userStore) {\n      this.userStore = userStore;\n    } else {\n      const store = typeof window !== \"undefined\" ? window.sessionStorage : new InMemoryWebStorage();\n      this.userStore = new WebStorageStateStore({ store });\n    }\n  }\n};\n\n// src/navigators/IFrameWindow.ts\nvar IFrameWindow = class extends AbstractChildWindow {\n  constructor({\n    silentRequestTimeoutInSeconds = DefaultSilentRequestTimeoutInSeconds\n  }) {\n    super();\n    this._logger = new Logger(\"IFrameWindow\");\n    this._timeoutInSeconds = silentRequestTimeoutInSeconds;\n    this._frame = IFrameWindow.createHiddenIframe();\n    this._window = this._frame.contentWindow;\n  }\n  static createHiddenIframe() {\n    const iframe = window.document.createElement(\"iframe\");\n    iframe.style.visibility = \"hidden\";\n    iframe.style.position = \"fixed\";\n    iframe.style.left = \"-1000px\";\n    iframe.style.top = \"0\";\n    iframe.width = \"0\";\n    iframe.height = \"0\";\n    window.document.body.appendChild(iframe);\n    return iframe;\n  }\n  async navigate(params) {\n    this._logger.debug(\"navigate: Using timeout of:\", this._timeoutInSeconds);\n    const timer = setTimeout(() => this._abort.raise(new ErrorTimeout(\"IFrame timed out without a response\")), this._timeoutInSeconds * 1e3);\n    this._disposeHandlers.add(() => clearTimeout(timer));\n    return await super.navigate(params);\n  }\n  close() {\n    var _a;\n    if (this._frame) {\n      if (this._frame.parentNode) {\n        this._frame.addEventListener(\"load\", (ev) => {\n          var _a2;\n          const frame = ev.target;\n          (_a2 = frame.parentNode) == null ? void 0 : _a2.removeChild(frame);\n          this._abort.raise(new Error(\"IFrame removed from DOM\"));\n        }, true);\n        (_a = this._frame.contentWindow) == null ? void 0 : _a.location.replace(\"about:blank\");\n      }\n      this._frame = null;\n    }\n    this._window = null;\n  }\n  static notifyParent(url, targetOrigin) {\n    return super._notifyParent(window.parent, url, false, targetOrigin);\n  }\n};\n\n// src/navigators/IFrameNavigator.ts\nvar IFrameNavigator = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"IFrameNavigator\");\n  }\n  async prepare({\n    silentRequestTimeoutInSeconds = this._settings.silentRequestTimeoutInSeconds\n  }) {\n    return new IFrameWindow({ silentRequestTimeoutInSeconds });\n  }\n  async callback(url) {\n    this._logger.create(\"callback\");\n    IFrameWindow.notifyParent(url, this._settings.iframeNotifyParentOrigin);\n  }\n};\n\n// src/navigators/PopupWindow.ts\nvar checkForPopupClosedInterval = 500;\nvar second = 1e3;\nvar PopupWindow = class extends AbstractChildWindow {\n  constructor({\n    popupWindowTarget = DefaultPopupTarget,\n    popupWindowFeatures = {}\n  }) {\n    super();\n    this._logger = new Logger(\"PopupWindow\");\n    const centeredPopup = PopupUtils.center({ ...DefaultPopupWindowFeatures, ...popupWindowFeatures });\n    this._window = window.open(void 0, popupWindowTarget, PopupUtils.serialize(centeredPopup));\n    if (popupWindowFeatures.closePopupWindowAfterInSeconds && popupWindowFeatures.closePopupWindowAfterInSeconds > 0) {\n      setTimeout(() => {\n        if (!this._window || typeof this._window.closed !== \"boolean\" || this._window.closed) {\n          this._abort.raise(new Error(\"Popup blocked by user\"));\n          return;\n        }\n        this.close();\n      }, popupWindowFeatures.closePopupWindowAfterInSeconds * second);\n    }\n  }\n  async navigate(params) {\n    var _a;\n    (_a = this._window) == null ? void 0 : _a.focus();\n    const popupClosedInterval = setInterval(() => {\n      if (!this._window || this._window.closed) {\n        this._abort.raise(new Error(\"Popup closed by user\"));\n      }\n    }, checkForPopupClosedInterval);\n    this._disposeHandlers.add(() => clearInterval(popupClosedInterval));\n    return await super.navigate(params);\n  }\n  close() {\n    if (this._window) {\n      if (!this._window.closed) {\n        this._window.close();\n        this._abort.raise(new Error(\"Popup closed\"));\n      }\n    }\n    this._window = null;\n  }\n  static notifyOpener(url, keepOpen) {\n    if (!window.opener) {\n      throw new Error(\"No window.opener. Can't complete notification.\");\n    }\n    return super._notifyParent(window.opener, url, keepOpen);\n  }\n};\n\n// src/navigators/PopupNavigator.ts\nvar PopupNavigator = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"PopupNavigator\");\n  }\n  async prepare({\n    popupWindowFeatures = this._settings.popupWindowFeatures,\n    popupWindowTarget = this._settings.popupWindowTarget\n  }) {\n    return new PopupWindow({ popupWindowFeatures, popupWindowTarget });\n  }\n  async callback(url, { keepOpen = false }) {\n    this._logger.create(\"callback\");\n    PopupWindow.notifyOpener(url, keepOpen);\n  }\n};\n\n// src/navigators/RedirectNavigator.ts\nvar RedirectNavigator = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"RedirectNavigator\");\n  }\n  async prepare({\n    redirectMethod = this._settings.redirectMethod,\n    redirectTarget = this._settings.redirectTarget\n  }) {\n    var _a;\n    this._logger.create(\"prepare\");\n    let targetWindow = window.self;\n    if (redirectTarget === \"top\") {\n      targetWindow = (_a = window.top) != null ? _a : window.self;\n    }\n    const redirect = targetWindow.location[redirectMethod].bind(targetWindow.location);\n    let abort;\n    return {\n      navigate: async (params) => {\n        this._logger.create(\"navigate\");\n        const promise = new Promise((resolve, reject) => {\n          abort = reject;\n        });\n        redirect(params.url);\n        return await promise;\n      },\n      close: () => {\n        this._logger.create(\"close\");\n        abort == null ? void 0 : abort(new Error(\"Redirect aborted\"));\n        targetWindow.stop();\n      }\n    };\n  }\n  async callback() {\n    return;\n  }\n};\n\n// src/UserManagerEvents.ts\nvar UserManagerEvents = class extends AccessTokenEvents {\n  constructor(settings) {\n    super({ expiringNotificationTimeInSeconds: settings.accessTokenExpiringNotificationTimeInSeconds });\n    this._logger = new Logger(\"UserManagerEvents\");\n    this._userLoaded = new Event(\"User loaded\");\n    this._userUnloaded = new Event(\"User unloaded\");\n    this._silentRenewError = new Event(\"Silent renew error\");\n    this._userSignedIn = new Event(\"User signed in\");\n    this._userSignedOut = new Event(\"User signed out\");\n    this._userSessionChanged = new Event(\"User session changed\");\n  }\n  load(user, raiseEvent = true) {\n    super.load(user);\n    if (raiseEvent) {\n      this._userLoaded.raise(user);\n    }\n  }\n  unload() {\n    super.unload();\n    this._userUnloaded.raise();\n  }\n  /**\n   * Add callback: Raised when a user session has been established (or re-established).\n   */\n  addUserLoaded(cb) {\n    return this._userLoaded.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when a user session has been established (or re-established).\n   */\n  removeUserLoaded(cb) {\n    return this._userLoaded.removeHandler(cb);\n  }\n  /**\n   * Add callback: Raised when a user session has been terminated.\n   */\n  addUserUnloaded(cb) {\n    return this._userUnloaded.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when a user session has been terminated.\n   */\n  removeUserUnloaded(cb) {\n    return this._userUnloaded.removeHandler(cb);\n  }\n  /**\n   * Add callback: Raised when the automatic silent renew has failed.\n   */\n  addSilentRenewError(cb) {\n    return this._silentRenewError.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when the automatic silent renew has failed.\n   */\n  removeSilentRenewError(cb) {\n    return this._silentRenewError.removeHandler(cb);\n  }\n  /**\n   * @internal\n   */\n  _raiseSilentRenewError(e) {\n    this._silentRenewError.raise(e);\n  }\n  /**\n   * Add callback: Raised when the user is signed in (when `monitorSession` is set).\n   * @see {@link UserManagerSettings.monitorSession}\n   */\n  addUserSignedIn(cb) {\n    return this._userSignedIn.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when the user is signed in (when `monitorSession` is set).\n   */\n  removeUserSignedIn(cb) {\n    this._userSignedIn.removeHandler(cb);\n  }\n  /**\n   * @internal\n   */\n  _raiseUserSignedIn() {\n    this._userSignedIn.raise();\n  }\n  /**\n   * Add callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).\n   * @see {@link UserManagerSettings.monitorSession}\n   */\n  addUserSignedOut(cb) {\n    return this._userSignedOut.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).\n   */\n  removeUserSignedOut(cb) {\n    this._userSignedOut.removeHandler(cb);\n  }\n  /**\n   * @internal\n   */\n  _raiseUserSignedOut() {\n    this._userSignedOut.raise();\n  }\n  /**\n   * Add callback: Raised when the user session changed (when `monitorSession` is set).\n   * @see {@link UserManagerSettings.monitorSession}\n   */\n  addUserSessionChanged(cb) {\n    return this._userSessionChanged.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when the user session changed (when `monitorSession` is set).\n   */\n  removeUserSessionChanged(cb) {\n    this._userSessionChanged.removeHandler(cb);\n  }\n  /**\n   * @internal\n   */\n  _raiseUserSessionChanged() {\n    this._userSessionChanged.raise();\n  }\n};\n\n// src/SilentRenewService.ts\nvar SilentRenewService = class {\n  constructor(_userManager) {\n    this._userManager = _userManager;\n    this._logger = new Logger(\"SilentRenewService\");\n    this._isStarted = false;\n    this._retryTimer = new Timer(\"Retry Silent Renew\");\n    this._tokenExpiring = async () => {\n      const logger2 = this._logger.create(\"_tokenExpiring\");\n      try {\n        await this._userManager.signinSilent();\n        logger2.debug(\"silent token renewal successful\");\n      } catch (err) {\n        if (err instanceof ErrorTimeout) {\n          logger2.warn(\"ErrorTimeout from signinSilent:\", err, \"retry in 5s\");\n          this._retryTimer.init(5);\n          return;\n        }\n        logger2.error(\"Error from signinSilent:\", err);\n        this._userManager.events._raiseSilentRenewError(err);\n      }\n    };\n  }\n  async start() {\n    const logger2 = this._logger.create(\"start\");\n    if (!this._isStarted) {\n      this._isStarted = true;\n      this._userManager.events.addAccessTokenExpiring(this._tokenExpiring);\n      this._retryTimer.addHandler(this._tokenExpiring);\n      try {\n        await this._userManager.getUser();\n      } catch (err) {\n        logger2.error(\"getUser error\", err);\n      }\n    }\n  }\n  stop() {\n    if (this._isStarted) {\n      this._retryTimer.cancel();\n      this._retryTimer.removeHandler(this._tokenExpiring);\n      this._userManager.events.removeAccessTokenExpiring(this._tokenExpiring);\n      this._isStarted = false;\n    }\n  }\n};\n\n// src/RefreshState.ts\nvar RefreshState = class {\n  constructor(args, resource) {\n    this.refresh_token = args.refresh_token;\n    this.id_token = args.id_token;\n    this.session_state = args.session_state;\n    this.scope = args.scope;\n    this.profile = args.profile;\n    this.resource = resource;\n    this.data = args.state;\n  }\n};\n\n// src/UserManager.ts\nvar UserManager = class {\n  constructor(settings, redirectNavigator, popupNavigator, iframeNavigator) {\n    this._logger = new Logger(\"UserManager\");\n    this.settings = new UserManagerSettingsStore(settings);\n    this._client = new OidcClient(settings);\n    this._redirectNavigator = redirectNavigator != null ? redirectNavigator : new RedirectNavigator(this.settings);\n    this._popupNavigator = popupNavigator != null ? popupNavigator : new PopupNavigator(this.settings);\n    this._iframeNavigator = iframeNavigator != null ? iframeNavigator : new IFrameNavigator(this.settings);\n    this._events = new UserManagerEvents(this.settings);\n    this._silentRenewService = new SilentRenewService(this);\n    if (this.settings.automaticSilentRenew) {\n      this.startSilentRenew();\n    }\n    this._sessionMonitor = null;\n    if (this.settings.monitorSession) {\n      this._sessionMonitor = new SessionMonitor(this);\n    }\n  }\n  /** Returns an object used to register for events raised by the `UserManager`. */\n  get events() {\n    return this._events;\n  }\n  /** Returns an object used to access the metadata configuration of the OIDC provider. */\n  get metadataService() {\n    return this._client.metadataService;\n  }\n  /**\n   * Returns promise to load the `User` object for the currently authenticated user.\n   */\n  async getUser() {\n    const logger2 = this._logger.create(\"getUser\");\n    const user = await this._loadUser();\n    if (user) {\n      logger2.info(\"user loaded\");\n      this._events.load(user, false);\n      return user;\n    }\n    logger2.info(\"user not found in storage\");\n    return null;\n  }\n  /**\n   * Returns promise to remove from any storage the currently authenticated user.\n   */\n  async removeUser() {\n    const logger2 = this._logger.create(\"removeUser\");\n    await this.storeUser(null);\n    logger2.info(\"user removed from storage\");\n    this._events.unload();\n  }\n  /**\n   * Returns promise to trigger a redirect of the current window to the authorization endpoint.\n   */\n  async signinRedirect(args = {}) {\n    this._logger.create(\"signinRedirect\");\n    const {\n      redirectMethod,\n      ...requestArgs\n    } = args;\n    const handle = await this._redirectNavigator.prepare({ redirectMethod });\n    await this._signinStart({\n      request_type: \"si:r\",\n      ...requestArgs\n    }, handle);\n  }\n  /**\n   * Returns promise to process response from the authorization endpoint. The result of the promise is the authenticated `User`.\n   */\n  async signinRedirectCallback(url = window.location.href) {\n    const logger2 = this._logger.create(\"signinRedirectCallback\");\n    const user = await this._signinEnd(url);\n    if (user.profile && user.profile.sub) {\n      logger2.info(\"success, signed in subject\", user.profile.sub);\n    } else {\n      logger2.info(\"no subject\");\n    }\n    return user;\n  }\n  /**\n   * Returns promise to process the signin with user/password. The result of the promise is the authenticated `User`.\n   *\n   * Throws an ErrorResponse in case of wrong authentication.\n   */\n  async signinResourceOwnerCredentials({\n    username,\n    password,\n    skipUserInfo = false\n  }) {\n    const logger2 = this._logger.create(\"signinResourceOwnerCredential\");\n    const signinResponse = await this._client.processResourceOwnerPasswordCredentials({ username, password, skipUserInfo, extraTokenParams: this.settings.extraTokenParams });\n    logger2.debug(\"got signin response\");\n    const user = await this._buildUser(signinResponse);\n    if (user.profile && user.profile.sub) {\n      logger2.info(\"success, signed in subject\", user.profile.sub);\n    } else {\n      logger2.info(\"no subject\");\n    }\n    return user;\n  }\n  /**\n   * Returns promise to trigger a request (via a popup window) to the authorization endpoint. The result of the promise is the authenticated `User`.\n   */\n  async signinPopup(args = {}) {\n    const logger2 = this._logger.create(\"signinPopup\");\n    const {\n      popupWindowFeatures,\n      popupWindowTarget,\n      ...requestArgs\n    } = args;\n    const url = this.settings.popup_redirect_uri;\n    if (!url) {\n      logger2.throw(new Error(\"No popup_redirect_uri configured\"));\n    }\n    const handle = await this._popupNavigator.prepare({ popupWindowFeatures, popupWindowTarget });\n    const user = await this._signin({\n      request_type: \"si:p\",\n      redirect_uri: url,\n      display: \"popup\",\n      ...requestArgs\n    }, handle);\n    if (user) {\n      if (user.profile && user.profile.sub) {\n        logger2.info(\"success, signed in subject\", user.profile.sub);\n      } else {\n        logger2.info(\"no subject\");\n      }\n    }\n    return user;\n  }\n  /**\n   * Returns promise to notify the opening window of response from the authorization endpoint.\n   */\n  async signinPopupCallback(url = window.location.href, keepOpen = false) {\n    const logger2 = this._logger.create(\"signinPopupCallback\");\n    await this._popupNavigator.callback(url, { keepOpen });\n    logger2.info(\"success\");\n  }\n  /**\n   * Returns promise to trigger a silent request (via an iframe) to the authorization endpoint.\n   * The result of the promise is the authenticated `User`.\n   */\n  async signinSilent(args = {}) {\n    var _a;\n    const logger2 = this._logger.create(\"signinSilent\");\n    const {\n      silentRequestTimeoutInSeconds,\n      resource,\n      ...requestArgs\n    } = args;\n    let user = await this._loadUser();\n    if (user == null ? void 0 : user.refresh_token) {\n      logger2.debug(\"using refresh token\");\n      const state = new RefreshState(user, resource);\n      return await this._useRefreshToken(state);\n    }\n    const url = this.settings.silent_redirect_uri;\n    if (!url) {\n      logger2.throw(new Error(\"No silent_redirect_uri configured\"));\n    }\n    let verifySub;\n    if (user && this.settings.validateSubOnSilentRenew) {\n      logger2.debug(\"subject prior to silent renew:\", user.profile.sub);\n      verifySub = user.profile.sub;\n    }\n    const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n    user = await this._signin({\n      request_type: \"si:s\",\n      redirect_uri: url,\n      prompt: \"none\",\n      id_token_hint: this.settings.includeIdTokenInSilentRenew ? user == null ? void 0 : user.id_token : void 0,\n      ...requestArgs\n    }, handle, verifySub);\n    if (user) {\n      if ((_a = user.profile) == null ? void 0 : _a.sub) {\n        logger2.info(\"success, signed in subject\", user.profile.sub);\n      } else {\n        logger2.info(\"no subject\");\n      }\n    }\n    return user;\n  }\n  async _useRefreshToken(state) {\n    const response = await this._client.useRefreshToken({\n      state,\n      timeoutInSeconds: this.settings.silentRequestTimeoutInSeconds\n    });\n    const user = new User({ ...state, ...response });\n    await this.storeUser(user);\n    this._events.load(user);\n    return user;\n  }\n  /**\n   * Returns promise to notify the parent window of response from the authorization endpoint.\n   */\n  async signinSilentCallback(url = window.location.href) {\n    const logger2 = this._logger.create(\"signinSilentCallback\");\n    await this._iframeNavigator.callback(url);\n    logger2.info(\"success\");\n  }\n  async signinCallback(url = window.location.href) {\n    const { state } = await this._client.readSigninResponseState(url);\n    switch (state.request_type) {\n      case \"si:r\":\n        return await this.signinRedirectCallback(url);\n      case \"si:p\":\n        return await this.signinPopupCallback(url);\n      case \"si:s\":\n        return await this.signinSilentCallback(url);\n      default:\n        throw new Error(\"invalid response_type in state\");\n    }\n  }\n  async signoutCallback(url = window.location.href, keepOpen = false) {\n    const { state } = await this._client.readSignoutResponseState(url);\n    if (!state) {\n      return void 0;\n    }\n    switch (state.request_type) {\n      case \"so:r\":\n        return await this.signoutRedirectCallback(url);\n      case \"so:p\":\n        await this.signoutPopupCallback(url, keepOpen);\n        break;\n      case \"so:s\":\n        await this.signoutSilentCallback(url);\n        break;\n      default:\n        throw new Error(\"invalid response_type in state\");\n    }\n    return void 0;\n  }\n  /**\n   * Returns promise to query OP for user's current signin status. Returns object with session_state and subject identifier.\n   */\n  async querySessionStatus(args = {}) {\n    const logger2 = this._logger.create(\"querySessionStatus\");\n    const {\n      silentRequestTimeoutInSeconds,\n      ...requestArgs\n    } = args;\n    const url = this.settings.silent_redirect_uri;\n    if (!url) {\n      logger2.throw(new Error(\"No silent_redirect_uri configured\"));\n    }\n    const user = await this._loadUser();\n    const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n    const navResponse = await this._signinStart({\n      request_type: \"si:s\",\n      // this acts like a signin silent\n      redirect_uri: url,\n      prompt: \"none\",\n      id_token_hint: this.settings.includeIdTokenInSilentRenew ? user == null ? void 0 : user.id_token : void 0,\n      response_type: this.settings.query_status_response_type,\n      scope: \"openid\",\n      skipUserInfo: true,\n      ...requestArgs\n    }, handle);\n    try {\n      const signinResponse = await this._client.processSigninResponse(navResponse.url);\n      logger2.debug(\"got signin response\");\n      if (signinResponse.session_state && signinResponse.profile.sub) {\n        logger2.info(\"success for subject\", signinResponse.profile.sub);\n        return {\n          session_state: signinResponse.session_state,\n          sub: signinResponse.profile.sub,\n          sid: signinResponse.profile.sid\n        };\n      }\n      logger2.info(\"success, user not authenticated\");\n      return null;\n    } catch (err) {\n      if (this.settings.monitorAnonymousSession && err instanceof ErrorResponse) {\n        switch (err.error) {\n          case \"login_required\":\n          case \"consent_required\":\n          case \"interaction_required\":\n          case \"account_selection_required\":\n            logger2.info(\"success for anonymous user\");\n            return {\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              session_state: err.session_state\n            };\n        }\n      }\n      throw err;\n    }\n  }\n  async _signin(args, handle, verifySub) {\n    const navResponse = await this._signinStart(args, handle);\n    return await this._signinEnd(navResponse.url, verifySub);\n  }\n  async _signinStart(args, handle) {\n    const logger2 = this._logger.create(\"_signinStart\");\n    try {\n      const signinRequest = await this._client.createSigninRequest(args);\n      logger2.debug(\"got signin request\");\n      return await handle.navigate({\n        url: signinRequest.url,\n        state: signinRequest.state.id,\n        response_mode: signinRequest.state.response_mode,\n        scriptOrigin: this.settings.iframeScriptOrigin\n      });\n    } catch (err) {\n      logger2.debug(\"error after preparing navigator, closing navigator window\");\n      handle.close();\n      throw err;\n    }\n  }\n  async _signinEnd(url, verifySub) {\n    const logger2 = this._logger.create(\"_signinEnd\");\n    const signinResponse = await this._client.processSigninResponse(url);\n    logger2.debug(\"got signin response\");\n    const user = await this._buildUser(signinResponse, verifySub);\n    return user;\n  }\n  async _buildUser(signinResponse, verifySub) {\n    const logger2 = this._logger.create(\"_buildUser\");\n    const user = new User(signinResponse);\n    if (verifySub) {\n      if (verifySub !== user.profile.sub) {\n        logger2.debug(\"current user does not match user returned from signin. sub from signin:\", user.profile.sub);\n        throw new ErrorResponse({ ...signinResponse, error: \"login_required\" });\n      }\n      logger2.debug(\"current user matches user returned from signin\");\n    }\n    await this.storeUser(user);\n    logger2.debug(\"user stored\");\n    this._events.load(user);\n    return user;\n  }\n  /**\n   * Returns promise to trigger a redirect of the current window to the end session endpoint.\n   */\n  async signoutRedirect(args = {}) {\n    const logger2 = this._logger.create(\"signoutRedirect\");\n    const {\n      redirectMethod,\n      ...requestArgs\n    } = args;\n    const handle = await this._redirectNavigator.prepare({ redirectMethod });\n    await this._signoutStart({\n      request_type: \"so:r\",\n      post_logout_redirect_uri: this.settings.post_logout_redirect_uri,\n      ...requestArgs\n    }, handle);\n    logger2.info(\"success\");\n  }\n  /**\n   * Returns promise to process response from the end session endpoint.\n   */\n  async signoutRedirectCallback(url = window.location.href) {\n    const logger2 = this._logger.create(\"signoutRedirectCallback\");\n    const response = await this._signoutEnd(url);\n    logger2.info(\"success\");\n    return response;\n  }\n  /**\n   * Returns promise to trigger a redirect of a popup window window to the end session endpoint.\n   */\n  async signoutPopup(args = {}) {\n    const logger2 = this._logger.create(\"signoutPopup\");\n    const {\n      popupWindowFeatures,\n      popupWindowTarget,\n      ...requestArgs\n    } = args;\n    const url = this.settings.popup_post_logout_redirect_uri;\n    const handle = await this._popupNavigator.prepare({ popupWindowFeatures, popupWindowTarget });\n    await this._signout({\n      request_type: \"so:p\",\n      post_logout_redirect_uri: url,\n      // we're putting a dummy entry in here because we\n      // need a unique id from the state for notification\n      // to the parent window, which is necessary if we\n      // plan to return back to the client after signout\n      // and so we can close the popup after signout\n      state: url == null ? void 0 : {},\n      ...requestArgs\n    }, handle);\n    logger2.info(\"success\");\n  }\n  /**\n   * Returns promise to process response from the end session endpoint from a popup window.\n   */\n  async signoutPopupCallback(url = window.location.href, keepOpen = false) {\n    const logger2 = this._logger.create(\"signoutPopupCallback\");\n    await this._popupNavigator.callback(url, { keepOpen });\n    logger2.info(\"success\");\n  }\n  async _signout(args, handle) {\n    const navResponse = await this._signoutStart(args, handle);\n    return await this._signoutEnd(navResponse.url);\n  }\n  async _signoutStart(args = {}, handle) {\n    var _a;\n    const logger2 = this._logger.create(\"_signoutStart\");\n    try {\n      const user = await this._loadUser();\n      logger2.debug(\"loaded current user from storage\");\n      if (this.settings.revokeTokensOnSignout) {\n        await this._revokeInternal(user);\n      }\n      const id_token = args.id_token_hint || user && user.id_token;\n      if (id_token) {\n        logger2.debug(\"setting id_token_hint in signout request\");\n        args.id_token_hint = id_token;\n      }\n      await this.removeUser();\n      logger2.debug(\"user removed, creating signout request\");\n      const signoutRequest = await this._client.createSignoutRequest(args);\n      logger2.debug(\"got signout request\");\n      return await handle.navigate({\n        url: signoutRequest.url,\n        state: (_a = signoutRequest.state) == null ? void 0 : _a.id,\n        scriptOrigin: this.settings.iframeScriptOrigin\n      });\n    } catch (err) {\n      logger2.debug(\"error after preparing navigator, closing navigator window\");\n      handle.close();\n      throw err;\n    }\n  }\n  async _signoutEnd(url) {\n    const logger2 = this._logger.create(\"_signoutEnd\");\n    const signoutResponse = await this._client.processSignoutResponse(url);\n    logger2.debug(\"got signout response\");\n    return signoutResponse;\n  }\n  /**\n   * Returns promise to trigger a silent request (via an iframe) to the end session endpoint.\n   */\n  async signoutSilent(args = {}) {\n    var _a;\n    const logger2 = this._logger.create(\"signoutSilent\");\n    const {\n      silentRequestTimeoutInSeconds,\n      ...requestArgs\n    } = args;\n    const id_token_hint = this.settings.includeIdTokenInSilentSignout ? (_a = await this._loadUser()) == null ? void 0 : _a.id_token : void 0;\n    const url = this.settings.popup_post_logout_redirect_uri;\n    const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n    await this._signout({\n      request_type: \"so:s\",\n      post_logout_redirect_uri: url,\n      id_token_hint,\n      ...requestArgs\n    }, handle);\n    logger2.info(\"success\");\n  }\n  /**\n   * Returns promise to notify the parent window of response from the end session endpoint.\n   */\n  async signoutSilentCallback(url = window.location.href) {\n    const logger2 = this._logger.create(\"signoutSilentCallback\");\n    await this._iframeNavigator.callback(url);\n    logger2.info(\"success\");\n  }\n  async revokeTokens(types) {\n    const user = await this._loadUser();\n    await this._revokeInternal(user, types);\n  }\n  async _revokeInternal(user, types = this.settings.revokeTokenTypes) {\n    const logger2 = this._logger.create(\"_revokeInternal\");\n    if (!user)\n      return;\n    const typesPresent = types.filter((type) => typeof user[type] === \"string\");\n    if (!typesPresent.length) {\n      logger2.debug(\"no need to revoke due to no token(s)\");\n      return;\n    }\n    for (const type of typesPresent) {\n      await this._client.revokeToken(\n        user[type],\n        // eslint-disable-line @typescript-eslint/no-non-null-assertion\n        type\n      );\n      logger2.info(`${type} revoked successfully`);\n      if (type !== \"access_token\") {\n        user[type] = null;\n      }\n    }\n    await this.storeUser(user);\n    logger2.debug(\"user stored\");\n    this._events.load(user);\n  }\n  /**\n   * Enables silent renew for the `UserManager`.\n   */\n  startSilentRenew() {\n    this._logger.create(\"startSilentRenew\");\n    void this._silentRenewService.start();\n  }\n  /**\n   * Disables silent renew for the `UserManager`.\n   */\n  stopSilentRenew() {\n    this._silentRenewService.stop();\n  }\n  get _userStoreKey() {\n    return `user:${this.settings.authority}:${this.settings.client_id}`;\n  }\n  async _loadUser() {\n    const logger2 = this._logger.create(\"_loadUser\");\n    const storageString = await this.settings.userStore.get(this._userStoreKey);\n    if (storageString) {\n      logger2.debug(\"user storageString loaded\");\n      return User.fromStorageString(storageString);\n    }\n    logger2.debug(\"no user storageString\");\n    return null;\n  }\n  async storeUser(user) {\n    const logger2 = this._logger.create(\"storeUser\");\n    if (user) {\n      logger2.debug(\"storing user\");\n      const storageString = user.toStorageString();\n      await this.settings.userStore.set(this._userStoreKey, storageString);\n    } else {\n      this._logger.debug(\"removing user\");\n      await this.settings.userStore.remove(this._userStoreKey);\n    }\n  }\n  /**\n   * Removes stale state entries in storage for incomplete authorize requests.\n   */\n  async clearStaleState() {\n    await this._client.clearStaleState();\n  }\n};\n\n// package.json\nvar version = \"2.4.1\";\n\n// src/Version.ts\nvar Version = version;\n\n//# sourceMappingURL=oidc-client-ts.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vaWRjLWNsaWVudC10cy9kaXN0L2VzbS9vaWRjLWNsaWVudC10cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDeUM7QUFDQTtBQUNJO0FBQ0o7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxXQUFXO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0JBQWtCO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEtBQUssR0FBRyxhQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEtBQUs7QUFDNUIsdUJBQXVCLFFBQVEsRUFBRSxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtEQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdEQUFNO0FBQzNCLGFBQWEsOERBQWdCO0FBQzdCLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdEQUFVO0FBQ2hDLFdBQVcsOERBQWdCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0RBQVU7QUFDdkIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csSUFBSSxHQUFHLDBEQUEwRDtBQUNuSztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsSUFBSTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsWUFBWSxpQ0FBaUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxxQ0FBcUM7QUFDekYsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxnREFBZ0QsY0FBYyxJQUFJO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQkFBcUIsR0FBRyxnQkFBZ0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFCQUFxQixHQUFHLGdCQUFnQixLQUFLLHFCQUFxQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCwrRUFBK0U7QUFDbkksTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxnREFBZ0QsY0FBYyxJQUFJO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscUJBQXFCLEdBQUcsZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFCQUFxQixHQUFHLGdCQUFnQixLQUFLLHFCQUFxQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsNENBQTRDO0FBQ3RIO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxLQUFLO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsSUFBSTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywwQkFBMEI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxrRkFBa0Y7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxtQkFBbUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxrRkFBa0Y7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsb0dBQW9HO0FBQ2pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxnRUFBZ0U7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsY0FBYztBQUMxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixNQUFNLEVBQUUsb0JBQW9CLEVBQUUsVUFBVTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx1REFBdUQ7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2QztBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0EsY0FBYyxvQkFBb0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQ0FBZ0M7QUFDakU7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHFCQUFxQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHdFQUF3RSx5Q0FBeUM7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxNQUFNO0FBQ04sNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEY7QUFDOUYsY0FBYztBQUNkLHlIQUF5SDtBQUN6SDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxrREFBa0QsT0FBTztBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDhCQUE4QiwrQkFBK0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw4Q0FBOEMsdURBQXVEO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCw2QkFBNkIsd0NBQXdDO0FBQ3JFO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEZBQTBGO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkRBQTJELGdCQUFnQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0ZBQXdGLG9GQUFvRjtBQUM1SztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHdDQUF3QztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELCtCQUErQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsK0JBQStCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDRDQUE0QztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDJEQUEyRCxnQkFBZ0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esd0RBQXdELHdDQUF3QztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSx5REFBeUQsK0JBQStCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QixHQUFHLHdCQUF3QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBc0JFO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxUV0UgR0tFXFx0b3Vyd2l0aGVhc2UtZ2tlLWhhY2thdGhvblxcZnJvbnRlbmRcXG15LWFwcFxcbm9kZV9tb2R1bGVzXFxvaWRjLWNsaWVudC10c1xcZGlzdFxcZXNtXFxvaWRjLWNsaWVudC10cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdXRpbHMvQ3J5cHRvVXRpbHMudHNcbmltcG9ydCBDcnlwdG9KUyBmcm9tIFwiY3J5cHRvLWpzL2NvcmUuanNcIjtcbmltcG9ydCBzaGEyNTYgZnJvbSBcImNyeXB0by1qcy9zaGEyNTYuanNcIjtcbmltcG9ydCBCYXNlNjQgZnJvbSBcImNyeXB0by1qcy9lbmMtYmFzZTY0LmpzXCI7XG5pbXBvcnQgVXRmOCBmcm9tIFwiY3J5cHRvLWpzL2VuYy11dGY4LmpzXCI7XG5cbi8vIHNyYy91dGlscy9Mb2dnZXIudHNcbnZhciBub3BMb2dnZXIgPSB7XG4gIGRlYnVnOiAoKSA9PiB2b2lkIDAsXG4gIGluZm86ICgpID0+IHZvaWQgMCxcbiAgd2FybjogKCkgPT4gdm9pZCAwLFxuICBlcnJvcjogKCkgPT4gdm9pZCAwXG59O1xudmFyIGxldmVsO1xudmFyIGxvZ2dlcjtcbnZhciBMb2cgPSAvKiBAX19QVVJFX18gKi8gKChMb2cyKSA9PiB7XG4gIExvZzJbTG9nMltcIk5PTkVcIl0gPSAwXSA9IFwiTk9ORVwiO1xuICBMb2cyW0xvZzJbXCJFUlJPUlwiXSA9IDFdID0gXCJFUlJPUlwiO1xuICBMb2cyW0xvZzJbXCJXQVJOXCJdID0gMl0gPSBcIldBUk5cIjtcbiAgTG9nMltMb2cyW1wiSU5GT1wiXSA9IDNdID0gXCJJTkZPXCI7XG4gIExvZzJbTG9nMltcIkRFQlVHXCJdID0gNF0gPSBcIkRFQlVHXCI7XG4gIHJldHVybiBMb2cyO1xufSkoTG9nIHx8IHt9KTtcbigoTG9nMikgPT4ge1xuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBsZXZlbCA9IDMgLyogSU5GTyAqLztcbiAgICBsb2dnZXIgPSBub3BMb2dnZXI7XG4gIH1cbiAgTG9nMi5yZXNldCA9IHJlc2V0O1xuICBmdW5jdGlvbiBzZXRMZXZlbCh2YWx1ZSkge1xuICAgIGlmICghKDAgLyogTk9ORSAqLyA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSA0IC8qIERFQlVHICovKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBsb2cgbGV2ZWxcIik7XG4gICAgfVxuICAgIGxldmVsID0gdmFsdWU7XG4gIH1cbiAgTG9nMi5zZXRMZXZlbCA9IHNldExldmVsO1xuICBmdW5jdGlvbiBzZXRMb2dnZXIodmFsdWUpIHtcbiAgICBsb2dnZXIgPSB2YWx1ZTtcbiAgfVxuICBMb2cyLnNldExvZ2dlciA9IHNldExvZ2dlcjtcbn0pKExvZyB8fCAoTG9nID0ge30pKTtcbnZhciBMb2dnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKF9uYW1lKSB7XG4gICAgdGhpcy5fbmFtZSA9IF9uYW1lO1xuICB9XG4gIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZW51bS1jb21wYXJpc29uICovXG4gIGRlYnVnKC4uLmFyZ3MpIHtcbiAgICBpZiAobGV2ZWwgPj0gNCAvKiBERUJVRyAqLykge1xuICAgICAgbG9nZ2VyLmRlYnVnKExvZ2dlci5fZm9ybWF0KHRoaXMuX25hbWUsIHRoaXMuX21ldGhvZCksIC4uLmFyZ3MpO1xuICAgIH1cbiAgfVxuICBpbmZvKC4uLmFyZ3MpIHtcbiAgICBpZiAobGV2ZWwgPj0gMyAvKiBJTkZPICovKSB7XG4gICAgICBsb2dnZXIuaW5mbyhMb2dnZXIuX2Zvcm1hdCh0aGlzLl9uYW1lLCB0aGlzLl9tZXRob2QpLCAuLi5hcmdzKTtcbiAgICB9XG4gIH1cbiAgd2FybiguLi5hcmdzKSB7XG4gICAgaWYgKGxldmVsID49IDIgLyogV0FSTiAqLykge1xuICAgICAgbG9nZ2VyLndhcm4oTG9nZ2VyLl9mb3JtYXQodGhpcy5fbmFtZSwgdGhpcy5fbWV0aG9kKSwgLi4uYXJncyk7XG4gICAgfVxuICB9XG4gIGVycm9yKC4uLmFyZ3MpIHtcbiAgICBpZiAobGV2ZWwgPj0gMSAvKiBFUlJPUiAqLykge1xuICAgICAgbG9nZ2VyLmVycm9yKExvZ2dlci5fZm9ybWF0KHRoaXMuX25hbWUsIHRoaXMuX21ldGhvZCksIC4uLmFyZ3MpO1xuICAgIH1cbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZW51bS1jb21wYXJpc29uICovXG4gIHRocm93KGVycikge1xuICAgIHRoaXMuZXJyb3IoZXJyKTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgY3JlYXRlKG1ldGhvZCkge1xuICAgIGNvbnN0IG1ldGhvZExvZ2dlciA9IE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgbWV0aG9kTG9nZ2VyLl9tZXRob2QgPSBtZXRob2Q7XG4gICAgbWV0aG9kTG9nZ2VyLmRlYnVnKFwiYmVnaW5cIik7XG4gICAgcmV0dXJuIG1ldGhvZExvZ2dlcjtcbiAgfVxuICBzdGF0aWMgY3JlYXRlU3RhdGljKG5hbWUsIHN0YXRpY01ldGhvZCkge1xuICAgIGNvbnN0IHN0YXRpY0xvZ2dlciA9IG5ldyBMb2dnZXIoYCR7bmFtZX0uJHtzdGF0aWNNZXRob2R9YCk7XG4gICAgc3RhdGljTG9nZ2VyLmRlYnVnKFwiYmVnaW5cIik7XG4gICAgcmV0dXJuIHN0YXRpY0xvZ2dlcjtcbiAgfVxuICBzdGF0aWMgX2Zvcm1hdChuYW1lLCBtZXRob2QpIHtcbiAgICBjb25zdCBwcmVmaXggPSBgWyR7bmFtZX1dYDtcbiAgICByZXR1cm4gbWV0aG9kID8gYCR7cHJlZml4fSAke21ldGhvZH06YCA6IHByZWZpeDtcbiAgfVxuICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWVudW0tY29tcGFyaXNvbiAqL1xuICAvLyBoZWxwZXJzIGZvciBzdGF0aWMgY2xhc3MgbWV0aG9kc1xuICBzdGF0aWMgZGVidWcobmFtZSwgLi4uYXJncykge1xuICAgIGlmIChsZXZlbCA+PSA0IC8qIERFQlVHICovKSB7XG4gICAgICBsb2dnZXIuZGVidWcoTG9nZ2VyLl9mb3JtYXQobmFtZSksIC4uLmFyZ3MpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgaW5mbyhuYW1lLCAuLi5hcmdzKSB7XG4gICAgaWYgKGxldmVsID49IDMgLyogSU5GTyAqLykge1xuICAgICAgbG9nZ2VyLmluZm8oTG9nZ2VyLl9mb3JtYXQobmFtZSksIC4uLmFyZ3MpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgd2FybihuYW1lLCAuLi5hcmdzKSB7XG4gICAgaWYgKGxldmVsID49IDIgLyogV0FSTiAqLykge1xuICAgICAgbG9nZ2VyLndhcm4oTG9nZ2VyLl9mb3JtYXQobmFtZSksIC4uLmFyZ3MpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZXJyb3IobmFtZSwgLi4uYXJncykge1xuICAgIGlmIChsZXZlbCA+PSAxIC8qIEVSUk9SICovKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoTG9nZ2VyLl9mb3JtYXQobmFtZSksIC4uLmFyZ3MpO1xuICAgIH1cbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZW51bS1jb21wYXJpc29uICovXG59O1xuTG9nLnJlc2V0KCk7XG5cbi8vIHNyYy91dGlscy9DcnlwdG9VdGlscy50c1xudmFyIFVVSURfVjRfVEVNUExBVEUgPSBcIjEwMDAwMDAwLTEwMDAtNDAwMC04MDAwLTEwMDAwMDAwMDAwMFwiO1xudmFyIENyeXB0b1V0aWxzID0gY2xhc3Mge1xuICBzdGF0aWMgX3JhbmRvbVdvcmQoKSB7XG4gICAgcmV0dXJuIENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkucmFuZG9tKDEpLndvcmRzWzBdO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgUkZDNDEyMiB2ZXJzaW9uIDQgZ3VpZFxuICAgKi9cbiAgc3RhdGljIGdlbmVyYXRlVVVJRHY0KCkge1xuICAgIGNvbnN0IHV1aWQgPSBVVUlEX1Y0X1RFTVBMQVRFLnJlcGxhY2UoXG4gICAgICAvWzAxOF0vZyxcbiAgICAgIChjKSA9PiAoK2MgXiBDcnlwdG9VdGlscy5fcmFuZG9tV29yZCgpICYgMTUgPj4gK2MgLyA0KS50b1N0cmluZygxNilcbiAgICApO1xuICAgIHJldHVybiB1dWlkLnJlcGxhY2UoLy0vZywgXCJcIik7XG4gIH1cbiAgLyoqXG4gICAqIFBLQ0U6IEdlbmVyYXRlIGEgY29kZSB2ZXJpZmllclxuICAgKi9cbiAgc3RhdGljIGdlbmVyYXRlQ29kZVZlcmlmaWVyKCkge1xuICAgIHJldHVybiBDcnlwdG9VdGlscy5nZW5lcmF0ZVVVSUR2NCgpICsgQ3J5cHRvVXRpbHMuZ2VuZXJhdGVVVUlEdjQoKSArIENyeXB0b1V0aWxzLmdlbmVyYXRlVVVJRHY0KCk7XG4gIH1cbiAgLyoqXG4gICAqIFBLQ0U6IEdlbmVyYXRlIGEgY29kZSBjaGFsbGVuZ2VcbiAgICovXG4gIHN0YXRpYyBnZW5lcmF0ZUNvZGVDaGFsbGVuZ2UoY29kZV92ZXJpZmllcikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBoYXNoZWQgPSBzaGEyNTYoY29kZV92ZXJpZmllcik7XG4gICAgICByZXR1cm4gQmFzZTY0LnN0cmluZ2lmeShoYXNoZWQpLnJlcGxhY2UoL1xcKy9nLCBcIi1cIikucmVwbGFjZSgvXFwvL2csIFwiX1wiKS5yZXBsYWNlKC89KyQvLCBcIlwiKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIExvZ2dlci5lcnJvcihcIkNyeXB0b1V0aWxzLmdlbmVyYXRlQ29kZUNoYWxsZW5nZVwiLCBlcnIpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nIGZvciBhIGJhc2ljIGF1dGggaGVhZGVyXG4gICAqL1xuICBzdGF0aWMgZ2VuZXJhdGVCYXNpY0F1dGgoY2xpZW50X2lkLCBjbGllbnRfc2VjcmV0KSB7XG4gICAgY29uc3QgYmFzaWNBdXRoID0gVXRmOC5wYXJzZShbY2xpZW50X2lkLCBjbGllbnRfc2VjcmV0XS5qb2luKFwiOlwiKSk7XG4gICAgcmV0dXJuIEJhc2U2NC5zdHJpbmdpZnkoYmFzaWNBdXRoKTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL0V2ZW50LnRzXG52YXIgRXZlbnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKF9uYW1lKSB7XG4gICAgdGhpcy5fbmFtZSA9IF9uYW1lO1xuICAgIHRoaXMuX2xvZ2dlciA9IG5ldyBMb2dnZXIoYEV2ZW50KCcke3RoaXMuX25hbWV9JylgKTtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSBbXTtcbiAgfVxuICBhZGRIYW5kbGVyKGNiKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzLnB1c2goY2IpO1xuICAgIHJldHVybiAoKSA9PiB0aGlzLnJlbW92ZUhhbmRsZXIoY2IpO1xuICB9XG4gIHJlbW92ZUhhbmRsZXIoY2IpIHtcbiAgICBjb25zdCBpZHggPSB0aGlzLl9jYWxsYmFja3MubGFzdEluZGV4T2YoY2IpO1xuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgdGhpcy5fY2FsbGJhY2tzLnNwbGljZShpZHgsIDEpO1xuICAgIH1cbiAgfVxuICByYWlzZSguLi5ldikge1xuICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhcInJhaXNlOlwiLCAuLi5ldik7XG4gICAgZm9yIChjb25zdCBjYiBvZiB0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgIHZvaWQgY2IoLi4uZXYpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL0p3dFV0aWxzLnRzXG5pbXBvcnQgand0X2RlY29kZSBmcm9tIFwiand0LWRlY29kZVwiO1xudmFyIEp3dFV0aWxzID0gY2xhc3Mge1xuICAvLyBJTVBPUlRBTlQ6IGRvZXNuJ3QgdmFsaWRhdGUgdGhlIHRva2VuXG4gIHN0YXRpYyBkZWNvZGUodG9rZW4pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGp3dF9kZWNvZGUodG9rZW4pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgTG9nZ2VyLmVycm9yKFwiSnd0VXRpbHMuZGVjb2RlXCIsIGVycik7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvUG9wdXBVdGlscy50c1xudmFyIFBvcHVwVXRpbHMgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBQb3B1bGF0ZXMgYSBtYXAgb2Ygd2luZG93IGZlYXR1cmVzIHdpdGggYSBwbGFjZW1lbnQgY2VudGVyZWQgaW4gZnJvbnQgb2ZcbiAgICogdGhlIGN1cnJlbnQgd2luZG93LiBJZiBubyBleHBsaWNpdCB3aWR0aCBpcyBnaXZlbiwgYSBkZWZhdWx0IHZhbHVlIGlzXG4gICAqIGJpbm5lZCBpbnRvIFs4MDAsIDcyMCwgNjAwLCA0ODAsIDM2MF0gYmFzZWQgb24gdGhlIGN1cnJlbnQgd2luZG93J3Mgd2lkdGguXG4gICAqL1xuICBzdGF0aWMgY2VudGVyKHsgLi4uZmVhdHVyZXMgfSkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGlmIChmZWF0dXJlcy53aWR0aCA9PSBudWxsKVxuICAgICAgZmVhdHVyZXMud2lkdGggPSAoX2EgPSBbODAwLCA3MjAsIDYwMCwgNDgwXS5maW5kKCh3aWR0aCkgPT4gd2lkdGggPD0gd2luZG93Lm91dGVyV2lkdGggLyAxLjYxOCkpICE9IG51bGwgPyBfYSA6IDM2MDtcbiAgICAoX2IgPSBmZWF0dXJlcy5sZWZ0KSAhPSBudWxsID8gX2IgOiBmZWF0dXJlcy5sZWZ0ID0gTWF0aC5tYXgoMCwgTWF0aC5yb3VuZCh3aW5kb3cuc2NyZWVuWCArICh3aW5kb3cub3V0ZXJXaWR0aCAtIGZlYXR1cmVzLndpZHRoKSAvIDIpKTtcbiAgICBpZiAoZmVhdHVyZXMuaGVpZ2h0ICE9IG51bGwpXG4gICAgICAoX2MgPSBmZWF0dXJlcy50b3ApICE9IG51bGwgPyBfYyA6IGZlYXR1cmVzLnRvcCA9IE1hdGgubWF4KDAsIE1hdGgucm91bmQod2luZG93LnNjcmVlblkgKyAod2luZG93Lm91dGVySGVpZ2h0IC0gZmVhdHVyZXMuaGVpZ2h0KSAvIDIpKTtcbiAgICByZXR1cm4gZmVhdHVyZXM7XG4gIH1cbiAgc3RhdGljIHNlcmlhbGl6ZShmZWF0dXJlcykge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhmZWF0dXJlcykuZmlsdGVyKChbLCB2YWx1ZV0pID0+IHZhbHVlICE9IG51bGwpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBgJHtrZXl9PSR7dHlwZW9mIHZhbHVlICE9PSBcImJvb2xlYW5cIiA/IHZhbHVlIDogdmFsdWUgPyBcInllc1wiIDogXCJub1wifWApLmpvaW4oXCIsXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvVGltZXIudHNcbnZhciBUaW1lciA9IGNsYXNzIGV4dGVuZHMgRXZlbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuX2xvZ2dlciA9IG5ldyBMb2dnZXIoYFRpbWVyKCcke3RoaXMuX25hbWV9JylgKTtcbiAgICB0aGlzLl90aW1lckhhbmRsZSA9IG51bGw7XG4gICAgdGhpcy5fZXhwaXJhdGlvbiA9IDA7XG4gICAgdGhpcy5fY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICBjb25zdCBkaWZmID0gdGhpcy5fZXhwaXJhdGlvbiAtIFRpbWVyLmdldEVwb2NoVGltZSgpO1xuICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwidGltZXIgY29tcGxldGVzIGluXCIsIGRpZmYpO1xuICAgICAgaWYgKHRoaXMuX2V4cGlyYXRpb24gPD0gVGltZXIuZ2V0RXBvY2hUaW1lKCkpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgc3VwZXIucmFpc2UoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8vIGdldCB0aGUgdGltZVxuICBzdGF0aWMgZ2V0RXBvY2hUaW1lKCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMpO1xuICB9XG4gIGluaXQoZHVyYXRpb25JblNlY29uZHMpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcImluaXRcIik7XG4gICAgZHVyYXRpb25JblNlY29uZHMgPSBNYXRoLm1heChNYXRoLmZsb29yKGR1cmF0aW9uSW5TZWNvbmRzKSwgMSk7XG4gICAgY29uc3QgZXhwaXJhdGlvbiA9IFRpbWVyLmdldEVwb2NoVGltZSgpICsgZHVyYXRpb25JblNlY29uZHM7XG4gICAgaWYgKHRoaXMuZXhwaXJhdGlvbiA9PT0gZXhwaXJhdGlvbiAmJiB0aGlzLl90aW1lckhhbmRsZSkge1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcInNraXBwaW5nIHNpbmNlIGFscmVhZHkgaW5pdGlhbGl6ZWQgZm9yIGV4cGlyYXRpb24gYXRcIiwgdGhpcy5leHBpcmF0aW9uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jYW5jZWwoKTtcbiAgICBsb2dnZXIyLmRlYnVnKFwidXNpbmcgZHVyYXRpb25cIiwgZHVyYXRpb25JblNlY29uZHMpO1xuICAgIHRoaXMuX2V4cGlyYXRpb24gPSBleHBpcmF0aW9uO1xuICAgIGNvbnN0IHRpbWVyRHVyYXRpb25JblNlY29uZHMgPSBNYXRoLm1pbihkdXJhdGlvbkluU2Vjb25kcywgNSk7XG4gICAgdGhpcy5fdGltZXJIYW5kbGUgPSBzZXRJbnRlcnZhbCh0aGlzLl9jYWxsYmFjaywgdGltZXJEdXJhdGlvbkluU2Vjb25kcyAqIDFlMyk7XG4gIH1cbiAgZ2V0IGV4cGlyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V4cGlyYXRpb247XG4gIH1cbiAgY2FuY2VsKCkge1xuICAgIHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJjYW5jZWxcIik7XG4gICAgaWYgKHRoaXMuX3RpbWVySGFuZGxlKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX3RpbWVySGFuZGxlKTtcbiAgICAgIHRoaXMuX3RpbWVySGFuZGxlID0gbnVsbDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9VcmxVdGlscy50c1xudmFyIFVybFV0aWxzID0gY2xhc3Mge1xuICBzdGF0aWMgcmVhZFBhcmFtcyh1cmwsIHJlc3BvbnNlTW9kZSA9IFwicXVlcnlcIikge1xuICAgIGlmICghdXJsKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgVVJMXCIpO1xuICAgIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwodXJsLCBcImh0dHA6Ly8xMjcuMC4wLjFcIik7XG4gICAgY29uc3QgcGFyYW1zID0gcGFyc2VkVXJsW3Jlc3BvbnNlTW9kZSA9PT0gXCJmcmFnbWVudFwiID8gXCJoYXNoXCIgOiBcInNlYXJjaFwiXTtcbiAgICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbXMuc2xpY2UoMSkpO1xuICB9XG59O1xudmFyIFVSTF9TVEFURV9ERUxJTUlURVIgPSBcIjtcIjtcblxuLy8gc3JjL2Vycm9ycy9FcnJvclJlc3BvbnNlLnRzXG52YXIgRXJyb3JSZXNwb25zZSA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihhcmdzLCBmb3JtKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgc3VwZXIoYXJncy5lcnJvcl9kZXNjcmlwdGlvbiB8fCBhcmdzLmVycm9yIHx8IFwiXCIpO1xuICAgIHRoaXMuZm9ybSA9IGZvcm07XG4gICAgLyoqIE1hcmtlciB0byBkZXRlY3QgY2xhc3M6IFwiRXJyb3JSZXNwb25zZVwiICovXG4gICAgdGhpcy5uYW1lID0gXCJFcnJvclJlc3BvbnNlXCI7XG4gICAgaWYgKCFhcmdzLmVycm9yKSB7XG4gICAgICBMb2dnZXIuZXJyb3IoXCJFcnJvclJlc3BvbnNlXCIsIFwiTm8gZXJyb3IgcGFzc2VkXCIpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZXJyb3IgcGFzc2VkXCIpO1xuICAgIH1cbiAgICB0aGlzLmVycm9yID0gYXJncy5lcnJvcjtcbiAgICB0aGlzLmVycm9yX2Rlc2NyaXB0aW9uID0gKF9hID0gYXJncy5lcnJvcl9kZXNjcmlwdGlvbikgIT0gbnVsbCA/IF9hIDogbnVsbDtcbiAgICB0aGlzLmVycm9yX3VyaSA9IChfYiA9IGFyZ3MuZXJyb3JfdXJpKSAhPSBudWxsID8gX2IgOiBudWxsO1xuICAgIHRoaXMuc3RhdGUgPSBhcmdzLnVzZXJTdGF0ZTtcbiAgICB0aGlzLnNlc3Npb25fc3RhdGUgPSAoX2MgPSBhcmdzLnNlc3Npb25fc3RhdGUpICE9IG51bGwgPyBfYyA6IG51bGw7XG4gICAgdGhpcy51cmxfc3RhdGUgPSBhcmdzLnVybF9zdGF0ZTtcbiAgfVxufTtcblxuLy8gc3JjL2Vycm9ycy9FcnJvclRpbWVvdXQudHNcbnZhciBFcnJvclRpbWVvdXQgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIC8qKiBNYXJrZXIgdG8gZGV0ZWN0IGNsYXNzOiBcIkVycm9yVGltZW91dFwiICovXG4gICAgdGhpcy5uYW1lID0gXCJFcnJvclRpbWVvdXRcIjtcbiAgfVxufTtcblxuLy8gc3JjL0FjY2Vzc1Rva2VuRXZlbnRzLnRzXG52YXIgQWNjZXNzVG9rZW5FdmVudHMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiQWNjZXNzVG9rZW5FdmVudHNcIik7XG4gICAgdGhpcy5fZXhwaXJpbmdUaW1lciA9IG5ldyBUaW1lcihcIkFjY2VzcyB0b2tlbiBleHBpcmluZ1wiKTtcbiAgICB0aGlzLl9leHBpcmVkVGltZXIgPSBuZXcgVGltZXIoXCJBY2Nlc3MgdG9rZW4gZXhwaXJlZFwiKTtcbiAgICB0aGlzLl9leHBpcmluZ05vdGlmaWNhdGlvblRpbWVJblNlY29uZHMgPSBhcmdzLmV4cGlyaW5nTm90aWZpY2F0aW9uVGltZUluU2Vjb25kcztcbiAgfVxuICBsb2FkKGNvbnRhaW5lcikge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwibG9hZFwiKTtcbiAgICBpZiAoY29udGFpbmVyLmFjY2Vzc190b2tlbiAmJiBjb250YWluZXIuZXhwaXJlc19pbiAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IGNvbnRhaW5lci5leHBpcmVzX2luO1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcImFjY2VzcyB0b2tlbiBwcmVzZW50LCByZW1haW5pbmcgZHVyYXRpb246XCIsIGR1cmF0aW9uKTtcbiAgICAgIGlmIChkdXJhdGlvbiA+IDApIHtcbiAgICAgICAgbGV0IGV4cGlyaW5nID0gZHVyYXRpb24gLSB0aGlzLl9leHBpcmluZ05vdGlmaWNhdGlvblRpbWVJblNlY29uZHM7XG4gICAgICAgIGlmIChleHBpcmluZyA8PSAwKSB7XG4gICAgICAgICAgZXhwaXJpbmcgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlcjIuZGVidWcoXCJyZWdpc3RlcmluZyBleHBpcmluZyB0aW1lciwgcmFpc2luZyBpblwiLCBleHBpcmluZywgXCJzZWNvbmRzXCIpO1xuICAgICAgICB0aGlzLl9leHBpcmluZ1RpbWVyLmluaXQoZXhwaXJpbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyMi5kZWJ1ZyhcImNhbmNlbGluZyBleGlzdGluZyBleHBpcmluZyB0aW1lciBiZWNhdXNlIHdlJ3JlIHBhc3QgZXhwaXJhdGlvbi5cIik7XG4gICAgICAgIHRoaXMuX2V4cGlyaW5nVGltZXIuY2FuY2VsKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBleHBpcmVkID0gZHVyYXRpb24gKyAxO1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcInJlZ2lzdGVyaW5nIGV4cGlyZWQgdGltZXIsIHJhaXNpbmcgaW5cIiwgZXhwaXJlZCwgXCJzZWNvbmRzXCIpO1xuICAgICAgdGhpcy5fZXhwaXJlZFRpbWVyLmluaXQoZXhwaXJlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2V4cGlyaW5nVGltZXIuY2FuY2VsKCk7XG4gICAgICB0aGlzLl9leHBpcmVkVGltZXIuY2FuY2VsKCk7XG4gICAgfVxuICB9XG4gIHVubG9hZCgpIHtcbiAgICB0aGlzLl9sb2dnZXIuZGVidWcoXCJ1bmxvYWQ6IGNhbmNlbGluZyBleGlzdGluZyBhY2Nlc3MgdG9rZW4gdGltZXJzXCIpO1xuICAgIHRoaXMuX2V4cGlyaW5nVGltZXIuY2FuY2VsKCk7XG4gICAgdGhpcy5fZXhwaXJlZFRpbWVyLmNhbmNlbCgpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgY2FsbGJhY2s6IFJhaXNlZCBwcmlvciB0byB0aGUgYWNjZXNzIHRva2VuIGV4cGlyaW5nLlxuICAgKi9cbiAgYWRkQWNjZXNzVG9rZW5FeHBpcmluZyhjYikge1xuICAgIHJldHVybiB0aGlzLl9leHBpcmluZ1RpbWVyLmFkZEhhbmRsZXIoY2IpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgY2FsbGJhY2s6IFJhaXNlZCBwcmlvciB0byB0aGUgYWNjZXNzIHRva2VuIGV4cGlyaW5nLlxuICAgKi9cbiAgcmVtb3ZlQWNjZXNzVG9rZW5FeHBpcmluZyhjYikge1xuICAgIHRoaXMuX2V4cGlyaW5nVGltZXIucmVtb3ZlSGFuZGxlcihjYik7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBjYWxsYmFjazogUmFpc2VkIGFmdGVyIHRoZSBhY2Nlc3MgdG9rZW4gaGFzIGV4cGlyZWQuXG4gICAqL1xuICBhZGRBY2Nlc3NUb2tlbkV4cGlyZWQoY2IpIHtcbiAgICByZXR1cm4gdGhpcy5fZXhwaXJlZFRpbWVyLmFkZEhhbmRsZXIoY2IpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgY2FsbGJhY2s6IFJhaXNlZCBhZnRlciB0aGUgYWNjZXNzIHRva2VuIGhhcyBleHBpcmVkLlxuICAgKi9cbiAgcmVtb3ZlQWNjZXNzVG9rZW5FeHBpcmVkKGNiKSB7XG4gICAgdGhpcy5fZXhwaXJlZFRpbWVyLnJlbW92ZUhhbmRsZXIoY2IpO1xuICB9XG59O1xuXG4vLyBzcmMvQ2hlY2tTZXNzaW9uSUZyYW1lLnRzXG52YXIgQ2hlY2tTZXNzaW9uSUZyYW1lID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihfY2FsbGJhY2ssIF9jbGllbnRfaWQsIHVybCwgX2ludGVydmFsSW5TZWNvbmRzLCBfc3RvcE9uRXJyb3IpIHtcbiAgICB0aGlzLl9jYWxsYmFjayA9IF9jYWxsYmFjaztcbiAgICB0aGlzLl9jbGllbnRfaWQgPSBfY2xpZW50X2lkO1xuICAgIHRoaXMuX2ludGVydmFsSW5TZWNvbmRzID0gX2ludGVydmFsSW5TZWNvbmRzO1xuICAgIHRoaXMuX3N0b3BPbkVycm9yID0gX3N0b3BPbkVycm9yO1xuICAgIHRoaXMuX2xvZ2dlciA9IG5ldyBMb2dnZXIoXCJDaGVja1Nlc3Npb25JRnJhbWVcIik7XG4gICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIHRoaXMuX3Nlc3Npb25fc3RhdGUgPSBudWxsO1xuICAgIHRoaXMuX21lc3NhZ2UgPSAoZSkgPT4ge1xuICAgICAgaWYgKGUub3JpZ2luID09PSB0aGlzLl9mcmFtZV9vcmlnaW4gJiYgZS5zb3VyY2UgPT09IHRoaXMuX2ZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgaWYgKGUuZGF0YSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKFwiZXJyb3IgbWVzc2FnZSBmcm9tIGNoZWNrIHNlc3Npb24gb3AgaWZyYW1lXCIpO1xuICAgICAgICAgIGlmICh0aGlzLl9zdG9wT25FcnJvcikge1xuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YSA9PT0gXCJjaGFuZ2VkXCIpIHtcbiAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoXCJjaGFuZ2VkIG1lc3NhZ2UgZnJvbSBjaGVjayBzZXNzaW9uIG9wIGlmcmFtZVwiKTtcbiAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICB2b2lkIHRoaXMuX2NhbGxiYWNrKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGUuZGF0YSArIFwiIG1lc3NhZ2UgZnJvbSBjaGVjayBzZXNzaW9uIG9wIGlmcmFtZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcGFyc2VkVXJsID0gbmV3IFVSTCh1cmwpO1xuICAgIHRoaXMuX2ZyYW1lX29yaWdpbiA9IHBhcnNlZFVybC5vcmlnaW47XG4gICAgdGhpcy5fZnJhbWUgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICB0aGlzLl9mcmFtZS5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICB0aGlzLl9mcmFtZS5zdHlsZS5wb3NpdGlvbiA9IFwiZml4ZWRcIjtcbiAgICB0aGlzLl9mcmFtZS5zdHlsZS5sZWZ0ID0gXCItMTAwMHB4XCI7XG4gICAgdGhpcy5fZnJhbWUuc3R5bGUudG9wID0gXCIwXCI7XG4gICAgdGhpcy5fZnJhbWUud2lkdGggPSBcIjBcIjtcbiAgICB0aGlzLl9mcmFtZS5oZWlnaHQgPSBcIjBcIjtcbiAgICB0aGlzLl9mcmFtZS5zcmMgPSBwYXJzZWRVcmwuaHJlZjtcbiAgfVxuICBsb2FkKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5fZnJhbWUub25sb2FkID0gKCkgPT4ge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9O1xuICAgICAgd2luZG93LmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fZnJhbWUpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuX21lc3NhZ2UsIGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuICBzdGFydChzZXNzaW9uX3N0YXRlKSB7XG4gICAgaWYgKHRoaXMuX3Nlc3Npb25fc3RhdGUgPT09IHNlc3Npb25fc3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInN0YXJ0XCIpO1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIHRoaXMuX3Nlc3Npb25fc3RhdGUgPSBzZXNzaW9uX3N0YXRlO1xuICAgIGNvbnN0IHNlbmQgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2ZyYW1lLmNvbnRlbnRXaW5kb3cgfHwgIXRoaXMuX3Nlc3Npb25fc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZSh0aGlzLl9jbGllbnRfaWQgKyBcIiBcIiArIHRoaXMuX3Nlc3Npb25fc3RhdGUsIHRoaXMuX2ZyYW1lX29yaWdpbik7XG4gICAgfTtcbiAgICBzZW5kKCk7XG4gICAgdGhpcy5fdGltZXIgPSBzZXRJbnRlcnZhbChzZW5kLCB0aGlzLl9pbnRlcnZhbEluU2Vjb25kcyAqIDFlMyk7XG4gIH1cbiAgc3RvcCgpIHtcbiAgICB0aGlzLl9sb2dnZXIuY3JlYXRlKFwic3RvcFwiKTtcbiAgICB0aGlzLl9zZXNzaW9uX3N0YXRlID0gbnVsbDtcbiAgICBpZiAodGhpcy5fdGltZXIpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fdGltZXIpO1xuICAgICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL0luTWVtb3J5V2ViU3RvcmFnZS50c1xudmFyIEluTWVtb3J5V2ViU3RvcmFnZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIkluTWVtb3J5V2ViU3RvcmFnZVwiKTtcbiAgICB0aGlzLl9kYXRhID0ge307XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShcImNsZWFyXCIpO1xuICAgIHRoaXMuX2RhdGEgPSB7fTtcbiAgfVxuICBnZXRJdGVtKGtleSkge1xuICAgIHRoaXMuX2xvZ2dlci5jcmVhdGUoYGdldEl0ZW0oJyR7a2V5fScpYCk7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFba2V5XTtcbiAgfVxuICBzZXRJdGVtKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLl9sb2dnZXIuY3JlYXRlKGBzZXRJdGVtKCcke2tleX0nKWApO1xuICAgIHRoaXMuX2RhdGFba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJlbW92ZUl0ZW0oa2V5KSB7XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShgcmVtb3ZlSXRlbSgnJHtrZXl9JylgKTtcbiAgICBkZWxldGUgdGhpcy5fZGF0YVtrZXldO1xuICB9XG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuX2RhdGEpLmxlbmd0aDtcbiAgfVxuICBrZXkoaW5kZXgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5fZGF0YSlbaW5kZXhdO1xuICB9XG59O1xuXG4vLyBzcmMvSnNvblNlcnZpY2UudHNcbnZhciBKc29uU2VydmljZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoYWRkaXRpb25hbENvbnRlbnRUeXBlcyA9IFtdLCBfand0SGFuZGxlciA9IG51bGwsIF9leHRyYUhlYWRlcnMgPSB7fSkge1xuICAgIHRoaXMuX2p3dEhhbmRsZXIgPSBfand0SGFuZGxlcjtcbiAgICB0aGlzLl9leHRyYUhlYWRlcnMgPSBfZXh0cmFIZWFkZXJzO1xuICAgIHRoaXMuX2xvZ2dlciA9IG5ldyBMb2dnZXIoXCJKc29uU2VydmljZVwiKTtcbiAgICB0aGlzLl9jb250ZW50VHlwZXMgPSBbXTtcbiAgICB0aGlzLl9jb250ZW50VHlwZXMucHVzaCguLi5hZGRpdGlvbmFsQ29udGVudFR5cGVzLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgaWYgKF9qd3RIYW5kbGVyKSB7XG4gICAgICB0aGlzLl9jb250ZW50VHlwZXMucHVzaChcImFwcGxpY2F0aW9uL2p3dFwiKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZmV0Y2hXaXRoVGltZW91dChpbnB1dCwgaW5pdCA9IHt9KSB7XG4gICAgY29uc3QgeyB0aW1lb3V0SW5TZWNvbmRzLCAuLi5pbml0RmV0Y2ggfSA9IGluaXQ7XG4gICAgaWYgKCF0aW1lb3V0SW5TZWNvbmRzKSB7XG4gICAgICByZXR1cm4gYXdhaXQgZmV0Y2goaW5wdXQsIGluaXRGZXRjaCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIHRpbWVvdXRJblNlY29uZHMgKiAxZTMpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGlucHV0LCB7XG4gICAgICAgIC4uLmluaXQsXG4gICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbiAmJiBlcnIubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yVGltZW91dChcIk5ldHdvcmsgdGltZWQgb3V0XCIpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZ2V0SnNvbih1cmwsIHtcbiAgICB0b2tlbixcbiAgICBjcmVkZW50aWFsc1xuICB9ID0ge30pIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcImdldEpzb25cIik7XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgIFwiQWNjZXB0XCI6IHRoaXMuX2NvbnRlbnRUeXBlcy5qb2luKFwiLCBcIilcbiAgICB9O1xuICAgIGlmICh0b2tlbikge1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcInRva2VuIHBhc3NlZCwgc2V0dGluZyBBdXRob3JpemF0aW9uIGhlYWRlclwiKTtcbiAgICAgIGhlYWRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gXCJCZWFyZXIgXCIgKyB0b2tlbjtcbiAgICB9XG4gICAgdGhpcy5hcHBlbmRFeHRyYUhlYWRlcnMoaGVhZGVycyk7XG4gICAgbGV0IHJlc3BvbnNlO1xuICAgIHRyeSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwidXJsOlwiLCB1cmwpO1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoV2l0aFRpbWVvdXQodXJsLCB7IG1ldGhvZDogXCJHRVRcIiwgaGVhZGVycywgY3JlZGVudGlhbHMgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2dnZXIyLmVycm9yKFwiTmV0d29yayBFcnJvclwiKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcIkhUVFAgcmVzcG9uc2UgcmVjZWl2ZWQsIHN0YXR1c1wiLCByZXNwb25zZS5zdGF0dXMpO1xuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIik7XG4gICAgaWYgKGNvbnRlbnRUeXBlICYmICF0aGlzLl9jb250ZW50VHlwZXMuZmluZCgoaXRlbSkgPT4gY29udGVudFR5cGUuc3RhcnRzV2l0aChpdGVtKSkpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKGBJbnZhbGlkIHJlc3BvbnNlIENvbnRlbnQtVHlwZTogJHtjb250ZW50VHlwZSAhPSBudWxsID8gY29udGVudFR5cGUgOiBcInVuZGVmaW5lZFwifSwgZnJvbSBVUkw6ICR7dXJsfWApKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLm9rICYmIHRoaXMuX2p3dEhhbmRsZXIgJiYgKGNvbnRlbnRUeXBlID09IG51bGwgPyB2b2lkIDAgOiBjb250ZW50VHlwZS5zdGFydHNXaXRoKFwiYXBwbGljYXRpb24vand0XCIpKSkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2p3dEhhbmRsZXIoYXdhaXQgcmVzcG9uc2UudGV4dCgpKTtcbiAgICB9XG4gICAgbGV0IGpzb247XG4gICAgdHJ5IHtcbiAgICAgIGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2dnZXIyLmVycm9yKFwiRXJyb3IgcGFyc2luZyBKU09OIHJlc3BvbnNlXCIsIGVycik7XG4gICAgICBpZiAocmVzcG9uc2Uub2spXG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtyZXNwb25zZS5zdGF0dXNUZXh0fSAoJHtyZXNwb25zZS5zdGF0dXN9KWApO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBsb2dnZXIyLmVycm9yKFwiRXJyb3IgZnJvbSBzZXJ2ZXI6XCIsIGpzb24pO1xuICAgICAgaWYgKGpzb24uZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yUmVzcG9uc2UoanNvbik7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0gKCR7cmVzcG9uc2Uuc3RhdHVzfSk6ICR7SlNPTi5zdHJpbmdpZnkoanNvbil9YCk7XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xuICB9XG4gIGFzeW5jIHBvc3RGb3JtKHVybCwge1xuICAgIGJvZHksXG4gICAgYmFzaWNBdXRoLFxuICAgIHRpbWVvdXRJblNlY29uZHMsXG4gICAgaW5pdENyZWRlbnRpYWxzXG4gIH0pIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInBvc3RGb3JtXCIpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICBcIkFjY2VwdFwiOiB0aGlzLl9jb250ZW50VHlwZXMuam9pbihcIiwgXCIpLFxuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIlxuICAgIH07XG4gICAgaWYgKGJhc2ljQXV0aCAhPT0gdm9pZCAwKSB7XG4gICAgICBoZWFkZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IFwiQmFzaWMgXCIgKyBiYXNpY0F1dGg7XG4gICAgfVxuICAgIHRoaXMuYXBwZW5kRXh0cmFIZWFkZXJzKGhlYWRlcnMpO1xuICAgIGxldCByZXNwb25zZTtcbiAgICB0cnkge1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcInVybDpcIiwgdXJsKTtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaFdpdGhUaW1lb3V0KHVybCwgeyBtZXRob2Q6IFwiUE9TVFwiLCBoZWFkZXJzLCBib2R5LCB0aW1lb3V0SW5TZWNvbmRzLCBjcmVkZW50aWFsczogaW5pdENyZWRlbnRpYWxzIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nZ2VyMi5lcnJvcihcIk5ldHdvcmsgZXJyb3JcIik7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIGxvZ2dlcjIuZGVidWcoXCJIVFRQIHJlc3BvbnNlIHJlY2VpdmVkLCBzdGF0dXNcIiwgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpO1xuICAgIGlmIChjb250ZW50VHlwZSAmJiAhdGhpcy5fY29udGVudFR5cGVzLmZpbmQoKGl0ZW0pID0+IGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoaXRlbSkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcmVzcG9uc2UgQ29udGVudC1UeXBlOiAke2NvbnRlbnRUeXBlICE9IG51bGwgPyBjb250ZW50VHlwZSA6IFwidW5kZWZpbmVkXCJ9LCBmcm9tIFVSTDogJHt1cmx9YCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICBsZXQganNvbiA9IHt9O1xuICAgIGlmIChyZXNwb25zZVRleHQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGpzb24gPSBKU09OLnBhcnNlKHJlc3BvbnNlVGV4dCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nZ2VyMi5lcnJvcihcIkVycm9yIHBhcnNpbmcgSlNPTiByZXNwb25zZVwiLCBlcnIpO1xuICAgICAgICBpZiAocmVzcG9uc2Uub2spXG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0gKCR7cmVzcG9uc2Uuc3RhdHVzfSlgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgbG9nZ2VyMi5lcnJvcihcIkVycm9yIGZyb20gc2VydmVyOlwiLCBqc29uKTtcbiAgICAgIGlmIChqc29uLmVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvclJlc3BvbnNlKGpzb24sIGJvZHkpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3Jlc3BvbnNlLnN0YXR1c1RleHR9ICgke3Jlc3BvbnNlLnN0YXR1c30pOiAke0pTT04uc3RyaW5naWZ5KGpzb24pfWApO1xuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbiAgfVxuICBhcHBlbmRFeHRyYUhlYWRlcnMoaGVhZGVycykge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiYXBwZW5kRXh0cmFIZWFkZXJzXCIpO1xuICAgIGNvbnN0IGN1c3RvbUtleXMgPSBPYmplY3Qua2V5cyh0aGlzLl9leHRyYUhlYWRlcnMpO1xuICAgIGNvbnN0IHByb3RlY3RlZEhlYWRlcnMgPSBbXG4gICAgICBcImF1dGhvcml6YXRpb25cIixcbiAgICAgIFwiYWNjZXB0XCIsXG4gICAgICBcImNvbnRlbnQtdHlwZVwiXG4gICAgXTtcbiAgICBpZiAoY3VzdG9tS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3VzdG9tS2V5cy5mb3JFYWNoKChoZWFkZXJOYW1lKSA9PiB7XG4gICAgICBpZiAocHJvdGVjdGVkSGVhZGVycy5pbmNsdWRlcyhoZWFkZXJOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgIGxvZ2dlcjIud2FybihcIlByb3RlY3RlZCBoZWFkZXIgY291bGQgbm90IGJlIG92ZXJyaWRkZW5cIiwgaGVhZGVyTmFtZSwgcHJvdGVjdGVkSGVhZGVycyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0eXBlb2YgdGhpcy5fZXh0cmFIZWFkZXJzW2hlYWRlck5hbWVdID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzLl9leHRyYUhlYWRlcnNbaGVhZGVyTmFtZV0oKSA6IHRoaXMuX2V4dHJhSGVhZGVyc1toZWFkZXJOYW1lXTtcbiAgICAgIGlmIChjb250ZW50ICYmIGNvbnRlbnQgIT09IFwiXCIpIHtcbiAgICAgICAgaGVhZGVyc1toZWFkZXJOYW1lXSA9IGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9NZXRhZGF0YVNlcnZpY2UudHNcbnZhciBNZXRhZGF0YVNlcnZpY2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKF9zZXR0aW5ncykge1xuICAgIHRoaXMuX3NldHRpbmdzID0gX3NldHRpbmdzO1xuICAgIHRoaXMuX2xvZ2dlciA9IG5ldyBMb2dnZXIoXCJNZXRhZGF0YVNlcnZpY2VcIik7XG4gICAgdGhpcy5fc2lnbmluZ0tleXMgPSBudWxsO1xuICAgIHRoaXMuX21ldGFkYXRhID0gbnVsbDtcbiAgICB0aGlzLl9tZXRhZGF0YVVybCA9IHRoaXMuX3NldHRpbmdzLm1ldGFkYXRhVXJsO1xuICAgIHRoaXMuX2pzb25TZXJ2aWNlID0gbmV3IEpzb25TZXJ2aWNlKFxuICAgICAgW1wiYXBwbGljYXRpb24vandrLXNldCtqc29uXCJdLFxuICAgICAgbnVsbCxcbiAgICAgIHRoaXMuX3NldHRpbmdzLmV4dHJhSGVhZGVyc1xuICAgICk7XG4gICAgaWYgKHRoaXMuX3NldHRpbmdzLnNpZ25pbmdLZXlzKSB7XG4gICAgICB0aGlzLl9sb2dnZXIuZGVidWcoXCJ1c2luZyBzaWduaW5nS2V5cyBmcm9tIHNldHRpbmdzXCIpO1xuICAgICAgdGhpcy5fc2lnbmluZ0tleXMgPSB0aGlzLl9zZXR0aW5ncy5zaWduaW5nS2V5cztcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NldHRpbmdzLm1ldGFkYXRhKSB7XG4gICAgICB0aGlzLl9sb2dnZXIuZGVidWcoXCJ1c2luZyBtZXRhZGF0YSBmcm9tIHNldHRpbmdzXCIpO1xuICAgICAgdGhpcy5fbWV0YWRhdGEgPSB0aGlzLl9zZXR0aW5ncy5tZXRhZGF0YTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NldHRpbmdzLmZldGNoUmVxdWVzdENyZWRlbnRpYWxzKSB7XG4gICAgICB0aGlzLl9sb2dnZXIuZGVidWcoXCJ1c2luZyBmZXRjaFJlcXVlc3RDcmVkZW50aWFscyBmcm9tIHNldHRpbmdzXCIpO1xuICAgICAgdGhpcy5fZmV0Y2hSZXF1ZXN0Q3JlZGVudGlhbHMgPSB0aGlzLl9zZXR0aW5ncy5mZXRjaFJlcXVlc3RDcmVkZW50aWFscztcbiAgICB9XG4gIH1cbiAgcmVzZXRTaWduaW5nS2V5cygpIHtcbiAgICB0aGlzLl9zaWduaW5nS2V5cyA9IG51bGw7XG4gIH1cbiAgYXN5bmMgZ2V0TWV0YWRhdGEoKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJnZXRNZXRhZGF0YVwiKTtcbiAgICBpZiAodGhpcy5fbWV0YWRhdGEpIHtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJ1c2luZyBjYWNoZWQgdmFsdWVzXCIpO1xuICAgICAgcmV0dXJuIHRoaXMuX21ldGFkYXRhO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX21ldGFkYXRhVXJsKSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIk5vIGF1dGhvcml0eSBvciBtZXRhZGF0YVVybCBjb25maWd1cmVkIG9uIHNldHRpbmdzXCIpKTtcbiAgICAgIHRocm93IG51bGw7XG4gICAgfVxuICAgIGxvZ2dlcjIuZGVidWcoXCJnZXR0aW5nIG1ldGFkYXRhIGZyb21cIiwgdGhpcy5fbWV0YWRhdGFVcmwpO1xuICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgdGhpcy5fanNvblNlcnZpY2UuZ2V0SnNvbih0aGlzLl9tZXRhZGF0YVVybCwgeyBjcmVkZW50aWFsczogdGhpcy5fZmV0Y2hSZXF1ZXN0Q3JlZGVudGlhbHMgfSk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcIm1lcmdpbmcgcmVtb3RlIEpTT04gd2l0aCBzZWVkIG1ldGFkYXRhXCIpO1xuICAgIHRoaXMuX21ldGFkYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fc2V0dGluZ3MubWV0YWRhdGFTZWVkLCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIHRoaXMuX21ldGFkYXRhO1xuICB9XG4gIGdldElzc3VlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TWV0YWRhdGFQcm9wZXJ0eShcImlzc3VlclwiKTtcbiAgfVxuICBnZXRBdXRob3JpemF0aW9uRW5kcG9pbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldE1ldGFkYXRhUHJvcGVydHkoXCJhdXRob3JpemF0aW9uX2VuZHBvaW50XCIpO1xuICB9XG4gIGdldFVzZXJJbmZvRW5kcG9pbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldE1ldGFkYXRhUHJvcGVydHkoXCJ1c2VyaW5mb19lbmRwb2ludFwiKTtcbiAgfVxuICBnZXRUb2tlbkVuZHBvaW50KG9wdGlvbmFsID0gdHJ1ZSkge1xuICAgIHJldHVybiB0aGlzLl9nZXRNZXRhZGF0YVByb3BlcnR5KFwidG9rZW5fZW5kcG9pbnRcIiwgb3B0aW9uYWwpO1xuICB9XG4gIGdldENoZWNrU2Vzc2lvbklmcmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TWV0YWRhdGFQcm9wZXJ0eShcImNoZWNrX3Nlc3Npb25faWZyYW1lXCIsIHRydWUpO1xuICB9XG4gIGdldEVuZFNlc3Npb25FbmRwb2ludCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TWV0YWRhdGFQcm9wZXJ0eShcImVuZF9zZXNzaW9uX2VuZHBvaW50XCIsIHRydWUpO1xuICB9XG4gIGdldFJldm9jYXRpb25FbmRwb2ludChvcHRpb25hbCA9IHRydWUpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TWV0YWRhdGFQcm9wZXJ0eShcInJldm9jYXRpb25fZW5kcG9pbnRcIiwgb3B0aW9uYWwpO1xuICB9XG4gIGdldEtleXNFbmRwb2ludChvcHRpb25hbCA9IHRydWUpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TWV0YWRhdGFQcm9wZXJ0eShcImp3a3NfdXJpXCIsIG9wdGlvbmFsKTtcbiAgfVxuICBhc3luYyBfZ2V0TWV0YWRhdGFQcm9wZXJ0eShuYW1lLCBvcHRpb25hbCA9IGZhbHNlKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoYF9nZXRNZXRhZGF0YVByb3BlcnR5KCcke25hbWV9JylgKTtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHRoaXMuZ2V0TWV0YWRhdGEoKTtcbiAgICBsb2dnZXIyLmRlYnVnKFwicmVzb2x2ZWRcIik7XG4gICAgaWYgKG1ldGFkYXRhW25hbWVdID09PSB2b2lkIDApIHtcbiAgICAgIGlmIChvcHRpb25hbCA9PT0gdHJ1ZSkge1xuICAgICAgICBsb2dnZXIyLndhcm4oXCJNZXRhZGF0YSBkb2VzIG5vdCBjb250YWluIG9wdGlvbmFsIHByb3BlcnR5XCIpO1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJNZXRhZGF0YSBkb2VzIG5vdCBjb250YWluIHByb3BlcnR5IFwiICsgbmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gbWV0YWRhdGFbbmFtZV07XG4gIH1cbiAgYXN5bmMgZ2V0U2lnbmluZ0tleXMoKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJnZXRTaWduaW5nS2V5c1wiKTtcbiAgICBpZiAodGhpcy5fc2lnbmluZ0tleXMpIHtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJyZXR1cm5pbmcgc2lnbmluZ0tleXMgZnJvbSBjYWNoZVwiKTtcbiAgICAgIHJldHVybiB0aGlzLl9zaWduaW5nS2V5cztcbiAgICB9XG4gICAgY29uc3Qgandrc191cmkgPSBhd2FpdCB0aGlzLmdldEtleXNFbmRwb2ludChmYWxzZSk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcImdvdCBqd2tzX3VyaVwiLCBqd2tzX3VyaSk7XG4gICAgY29uc3Qga2V5U2V0ID0gYXdhaXQgdGhpcy5fanNvblNlcnZpY2UuZ2V0SnNvbihqd2tzX3VyaSk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcImdvdCBrZXkgc2V0XCIsIGtleVNldCk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGtleVNldC5rZXlzKSkge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJNaXNzaW5nIGtleXMgb24ga2V5c2V0XCIpKTtcbiAgICAgIHRocm93IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX3NpZ25pbmdLZXlzID0ga2V5U2V0LmtleXM7XG4gICAgcmV0dXJuIHRoaXMuX3NpZ25pbmdLZXlzO1xuICB9XG59O1xuXG4vLyBzcmMvV2ViU3RvcmFnZVN0YXRlU3RvcmUudHNcbnZhciBXZWJTdG9yYWdlU3RhdGVTdG9yZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHByZWZpeCA9IFwib2lkYy5cIixcbiAgICBzdG9yZSA9IGxvY2FsU3RvcmFnZVxuICB9ID0ge30pIHtcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiV2ViU3RvcmFnZVN0YXRlU3RvcmVcIik7XG4gICAgdGhpcy5fc3RvcmUgPSBzdG9yZTtcbiAgICB0aGlzLl9wcmVmaXggPSBwcmVmaXg7XG4gIH1cbiAgYXN5bmMgc2V0KGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLl9sb2dnZXIuY3JlYXRlKGBzZXQoJyR7a2V5fScpYCk7XG4gICAga2V5ID0gdGhpcy5fcHJlZml4ICsga2V5O1xuICAgIGF3YWl0IHRoaXMuX3N0b3JlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gIH1cbiAgYXN5bmMgZ2V0KGtleSkge1xuICAgIHRoaXMuX2xvZ2dlci5jcmVhdGUoYGdldCgnJHtrZXl9JylgKTtcbiAgICBrZXkgPSB0aGlzLl9wcmVmaXggKyBrZXk7XG4gICAgY29uc3QgaXRlbSA9IGF3YWl0IHRoaXMuX3N0b3JlLmdldEl0ZW0oa2V5KTtcbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuICBhc3luYyByZW1vdmUoa2V5KSB7XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShgcmVtb3ZlKCcke2tleX0nKWApO1xuICAgIGtleSA9IHRoaXMuX3ByZWZpeCArIGtleTtcbiAgICBjb25zdCBpdGVtID0gYXdhaXQgdGhpcy5fc3RvcmUuZ2V0SXRlbShrZXkpO1xuICAgIGF3YWl0IHRoaXMuX3N0b3JlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuICBhc3luYyBnZXRBbGxLZXlzKCkge1xuICAgIHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJnZXRBbGxLZXlzXCIpO1xuICAgIGNvbnN0IGxlbiA9IGF3YWl0IHRoaXMuX3N0b3JlLmxlbmd0aDtcbiAgICBjb25zdCBrZXlzID0gW107XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxlbjsgaW5kZXgrKykge1xuICAgICAgY29uc3Qga2V5ID0gYXdhaXQgdGhpcy5fc3RvcmUua2V5KGluZGV4KTtcbiAgICAgIGlmIChrZXkgJiYga2V5LmluZGV4T2YodGhpcy5fcHJlZml4KSA9PT0gMCkge1xuICAgICAgICBrZXlzLnB1c2goa2V5LnN1YnN0cih0aGlzLl9wcmVmaXgubGVuZ3RoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xuICB9XG59O1xuXG4vLyBzcmMvT2lkY0NsaWVudFNldHRpbmdzLnRzXG52YXIgRGVmYXVsdFJlc3BvbnNlVHlwZSA9IFwiY29kZVwiO1xudmFyIERlZmF1bHRTY29wZSA9IFwib3BlbmlkXCI7XG52YXIgRGVmYXVsdENsaWVudEF1dGhlbnRpY2F0aW9uID0gXCJjbGllbnRfc2VjcmV0X3Bvc3RcIjtcbnZhciBEZWZhdWx0UmVzcG9uc2VNb2RlID0gXCJxdWVyeVwiO1xudmFyIERlZmF1bHRTdGFsZVN0YXRlQWdlSW5TZWNvbmRzID0gNjAgKiAxNTtcbnZhciBEZWZhdWx0Q2xvY2tTa2V3SW5TZWNvbmRzID0gNjAgKiA1O1xudmFyIE9pZGNDbGllbnRTZXR0aW5nc1N0b3JlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgLy8gbWV0YWRhdGEgcmVsYXRlZFxuICAgIGF1dGhvcml0eSxcbiAgICBtZXRhZGF0YVVybCxcbiAgICBtZXRhZGF0YSxcbiAgICBzaWduaW5nS2V5cyxcbiAgICBtZXRhZGF0YVNlZWQsXG4gICAgLy8gY2xpZW50IHJlbGF0ZWRcbiAgICBjbGllbnRfaWQsXG4gICAgY2xpZW50X3NlY3JldCxcbiAgICByZXNwb25zZV90eXBlID0gRGVmYXVsdFJlc3BvbnNlVHlwZSxcbiAgICBzY29wZSA9IERlZmF1bHRTY29wZSxcbiAgICByZWRpcmVjdF91cmksXG4gICAgcG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpLFxuICAgIGNsaWVudF9hdXRoZW50aWNhdGlvbiA9IERlZmF1bHRDbGllbnRBdXRoZW50aWNhdGlvbixcbiAgICAvLyBvcHRpb25hbCBwcm90b2NvbFxuICAgIHByb21wdCxcbiAgICBkaXNwbGF5LFxuICAgIG1heF9hZ2UsXG4gICAgdWlfbG9jYWxlcyxcbiAgICBhY3JfdmFsdWVzLFxuICAgIHJlc291cmNlLFxuICAgIHJlc3BvbnNlX21vZGUgPSBEZWZhdWx0UmVzcG9uc2VNb2RlLFxuICAgIC8vIGJlaGF2aW9yIGZsYWdzXG4gICAgZmlsdGVyUHJvdG9jb2xDbGFpbXMgPSB0cnVlLFxuICAgIGxvYWRVc2VySW5mbyA9IGZhbHNlLFxuICAgIHN0YWxlU3RhdGVBZ2VJblNlY29uZHMgPSBEZWZhdWx0U3RhbGVTdGF0ZUFnZUluU2Vjb25kcyxcbiAgICBjbG9ja1NrZXdJblNlY29uZHMgPSBEZWZhdWx0Q2xvY2tTa2V3SW5TZWNvbmRzLFxuICAgIHVzZXJJbmZvSnd0SXNzdWVyID0gXCJPUFwiLFxuICAgIG1lcmdlQ2xhaW1zID0gZmFsc2UsXG4gICAgZGlzYWJsZVBLQ0UgPSBmYWxzZSxcbiAgICAvLyBvdGhlciBiZWhhdmlvclxuICAgIHN0YXRlU3RvcmUsXG4gICAgcmVmcmVzaFRva2VuQ3JlZGVudGlhbHMsXG4gICAgcmV2b2tlVG9rZW5BZGRpdGlvbmFsQ29udGVudFR5cGVzLFxuICAgIGZldGNoUmVxdWVzdENyZWRlbnRpYWxzLFxuICAgIHJlZnJlc2hUb2tlbkFsbG93ZWRTY29wZSxcbiAgICAvLyBleHRyYVxuICAgIGV4dHJhUXVlcnlQYXJhbXMgPSB7fSxcbiAgICBleHRyYVRva2VuUGFyYW1zID0ge30sXG4gICAgZXh0cmFIZWFkZXJzID0ge31cbiAgfSkge1xuICAgIHRoaXMuYXV0aG9yaXR5ID0gYXV0aG9yaXR5O1xuICAgIGlmIChtZXRhZGF0YVVybCkge1xuICAgICAgdGhpcy5tZXRhZGF0YVVybCA9IG1ldGFkYXRhVXJsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1ldGFkYXRhVXJsID0gYXV0aG9yaXR5O1xuICAgICAgaWYgKGF1dGhvcml0eSkge1xuICAgICAgICBpZiAoIXRoaXMubWV0YWRhdGFVcmwuZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgdGhpcy5tZXRhZGF0YVVybCArPSBcIi9cIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1ldGFkYXRhVXJsICs9IFwiLndlbGwta25vd24vb3BlbmlkLWNvbmZpZ3VyYXRpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgIHRoaXMubWV0YWRhdGFTZWVkID0gbWV0YWRhdGFTZWVkO1xuICAgIHRoaXMuc2lnbmluZ0tleXMgPSBzaWduaW5nS2V5cztcbiAgICB0aGlzLmNsaWVudF9pZCA9IGNsaWVudF9pZDtcbiAgICB0aGlzLmNsaWVudF9zZWNyZXQgPSBjbGllbnRfc2VjcmV0O1xuICAgIHRoaXMucmVzcG9uc2VfdHlwZSA9IHJlc3BvbnNlX3R5cGU7XG4gICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIHRoaXMucmVkaXJlY3RfdXJpID0gcmVkaXJlY3RfdXJpO1xuICAgIHRoaXMucG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpID0gcG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpO1xuICAgIHRoaXMuY2xpZW50X2F1dGhlbnRpY2F0aW9uID0gY2xpZW50X2F1dGhlbnRpY2F0aW9uO1xuICAgIHRoaXMucHJvbXB0ID0gcHJvbXB0O1xuICAgIHRoaXMuZGlzcGxheSA9IGRpc3BsYXk7XG4gICAgdGhpcy5tYXhfYWdlID0gbWF4X2FnZTtcbiAgICB0aGlzLnVpX2xvY2FsZXMgPSB1aV9sb2NhbGVzO1xuICAgIHRoaXMuYWNyX3ZhbHVlcyA9IGFjcl92YWx1ZXM7XG4gICAgdGhpcy5yZXNvdXJjZSA9IHJlc291cmNlO1xuICAgIHRoaXMucmVzcG9uc2VfbW9kZSA9IHJlc3BvbnNlX21vZGU7XG4gICAgdGhpcy5maWx0ZXJQcm90b2NvbENsYWltcyA9IGZpbHRlclByb3RvY29sQ2xhaW1zICE9IG51bGwgPyBmaWx0ZXJQcm90b2NvbENsYWltcyA6IHRydWU7XG4gICAgdGhpcy5sb2FkVXNlckluZm8gPSAhIWxvYWRVc2VySW5mbztcbiAgICB0aGlzLnN0YWxlU3RhdGVBZ2VJblNlY29uZHMgPSBzdGFsZVN0YXRlQWdlSW5TZWNvbmRzO1xuICAgIHRoaXMuY2xvY2tTa2V3SW5TZWNvbmRzID0gY2xvY2tTa2V3SW5TZWNvbmRzO1xuICAgIHRoaXMudXNlckluZm9Kd3RJc3N1ZXIgPSB1c2VySW5mb0p3dElzc3VlcjtcbiAgICB0aGlzLm1lcmdlQ2xhaW1zID0gISFtZXJnZUNsYWltcztcbiAgICB0aGlzLmRpc2FibGVQS0NFID0gISFkaXNhYmxlUEtDRTtcbiAgICB0aGlzLnJldm9rZVRva2VuQWRkaXRpb25hbENvbnRlbnRUeXBlcyA9IHJldm9rZVRva2VuQWRkaXRpb25hbENvbnRlbnRUeXBlcztcbiAgICBpZiAoZmV0Y2hSZXF1ZXN0Q3JlZGVudGlhbHMgJiYgcmVmcmVzaFRva2VuQ3JlZGVudGlhbHMpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkJvdGggZmV0Y2hSZXF1ZXN0Q3JlZGVudGlhbHMgYW5kIHJlZnJlc2hUb2tlbkNyZWRlbnRpYWxzIGlzIHNldC4gT25seSBmZXRjaFJlcXVlc3RDcmVkZW50aWFscyB3aWxsIGJlIHVzZWQuXCIpO1xuICAgIH1cbiAgICB0aGlzLmZldGNoUmVxdWVzdENyZWRlbnRpYWxzID0gZmV0Y2hSZXF1ZXN0Q3JlZGVudGlhbHMgPyBmZXRjaFJlcXVlc3RDcmVkZW50aWFscyA6IHJlZnJlc2hUb2tlbkNyZWRlbnRpYWxzID8gcmVmcmVzaFRva2VuQ3JlZGVudGlhbHMgOiBcInNhbWUtb3JpZ2luXCI7XG4gICAgaWYgKHN0YXRlU3RvcmUpIHtcbiAgICAgIHRoaXMuc3RhdGVTdG9yZSA9IHN0YXRlU3RvcmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0b3JlID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5sb2NhbFN0b3JhZ2UgOiBuZXcgSW5NZW1vcnlXZWJTdG9yYWdlKCk7XG4gICAgICB0aGlzLnN0YXRlU3RvcmUgPSBuZXcgV2ViU3RvcmFnZVN0YXRlU3RvcmUoeyBzdG9yZSB9KTtcbiAgICB9XG4gICAgdGhpcy5yZWZyZXNoVG9rZW5BbGxvd2VkU2NvcGUgPSByZWZyZXNoVG9rZW5BbGxvd2VkU2NvcGU7XG4gICAgdGhpcy5leHRyYVF1ZXJ5UGFyYW1zID0gZXh0cmFRdWVyeVBhcmFtcztcbiAgICB0aGlzLmV4dHJhVG9rZW5QYXJhbXMgPSBleHRyYVRva2VuUGFyYW1zO1xuICAgIHRoaXMuZXh0cmFIZWFkZXJzID0gZXh0cmFIZWFkZXJzO1xuICB9XG59O1xuXG4vLyBzcmMvVXNlckluZm9TZXJ2aWNlLnRzXG52YXIgVXNlckluZm9TZXJ2aWNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihfc2V0dGluZ3MsIF9tZXRhZGF0YVNlcnZpY2UpIHtcbiAgICB0aGlzLl9zZXR0aW5ncyA9IF9zZXR0aW5ncztcbiAgICB0aGlzLl9tZXRhZGF0YVNlcnZpY2UgPSBfbWV0YWRhdGFTZXJ2aWNlO1xuICAgIHRoaXMuX2xvZ2dlciA9IG5ldyBMb2dnZXIoXCJVc2VySW5mb1NlcnZpY2VcIik7XG4gICAgdGhpcy5fZ2V0Q2xhaW1zRnJvbUp3dCA9IGFzeW5jIChyZXNwb25zZVRleHQpID0+IHtcbiAgICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiX2dldENsYWltc0Zyb21Kd3RcIik7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gSnd0VXRpbHMuZGVjb2RlKHJlc3BvbnNlVGV4dCk7XG4gICAgICAgIGxvZ2dlcjIuZGVidWcoXCJKV1QgZGVjb2Rpbmcgc3VjY2Vzc2Z1bFwiKTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nZ2VyMi5lcnJvcihcIkVycm9yIHBhcnNpbmcgSldUIHJlc3BvbnNlXCIpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9qc29uU2VydmljZSA9IG5ldyBKc29uU2VydmljZShcbiAgICAgIHZvaWQgMCxcbiAgICAgIHRoaXMuX2dldENsYWltc0Zyb21Kd3QsXG4gICAgICB0aGlzLl9zZXR0aW5ncy5leHRyYUhlYWRlcnNcbiAgICApO1xuICB9XG4gIGFzeW5jIGdldENsYWltcyh0b2tlbikge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiZ2V0Q2xhaW1zXCIpO1xuICAgIGlmICghdG9rZW4pIHtcbiAgICAgIHRoaXMuX2xvZ2dlci50aHJvdyhuZXcgRXJyb3IoXCJObyB0b2tlbiBwYXNzZWRcIikpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLl9tZXRhZGF0YVNlcnZpY2UuZ2V0VXNlckluZm9FbmRwb2ludCgpO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJnb3QgdXNlcmluZm8gdXJsXCIsIHVybCk7XG4gICAgY29uc3QgY2xhaW1zID0gYXdhaXQgdGhpcy5fanNvblNlcnZpY2UuZ2V0SnNvbih1cmwsIHtcbiAgICAgIHRva2VuLFxuICAgICAgY3JlZGVudGlhbHM6IHRoaXMuX3NldHRpbmdzLmZldGNoUmVxdWVzdENyZWRlbnRpYWxzXG4gICAgfSk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcImdvdCBjbGFpbXNcIiwgY2xhaW1zKTtcbiAgICByZXR1cm4gY2xhaW1zO1xuICB9XG59O1xuXG4vLyBzcmMvVG9rZW5DbGllbnQudHNcbnZhciBUb2tlbkNsaWVudCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoX3NldHRpbmdzLCBfbWV0YWRhdGFTZXJ2aWNlKSB7XG4gICAgdGhpcy5fc2V0dGluZ3MgPSBfc2V0dGluZ3M7XG4gICAgdGhpcy5fbWV0YWRhdGFTZXJ2aWNlID0gX21ldGFkYXRhU2VydmljZTtcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiVG9rZW5DbGllbnRcIik7XG4gICAgdGhpcy5fanNvblNlcnZpY2UgPSBuZXcgSnNvblNlcnZpY2UoXG4gICAgICB0aGlzLl9zZXR0aW5ncy5yZXZva2VUb2tlbkFkZGl0aW9uYWxDb250ZW50VHlwZXMsXG4gICAgICBudWxsLFxuICAgICAgdGhpcy5fc2V0dGluZ3MuZXh0cmFIZWFkZXJzXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogRXhjaGFuZ2UgY29kZS5cbiAgICpcbiAgICogQHNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNjc0OSNzZWN0aW9uLTQuMS4zXG4gICAqL1xuICBhc3luYyBleGNoYW5nZUNvZGUoe1xuICAgIGdyYW50X3R5cGUgPSBcImF1dGhvcml6YXRpb25fY29kZVwiLFxuICAgIHJlZGlyZWN0X3VyaSA9IHRoaXMuX3NldHRpbmdzLnJlZGlyZWN0X3VyaSxcbiAgICBjbGllbnRfaWQgPSB0aGlzLl9zZXR0aW5ncy5jbGllbnRfaWQsXG4gICAgY2xpZW50X3NlY3JldCA9IHRoaXMuX3NldHRpbmdzLmNsaWVudF9zZWNyZXQsXG4gICAgLi4uYXJnc1xuICB9KSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJleGNoYW5nZUNvZGVcIik7XG4gICAgaWYgKCFjbGllbnRfaWQpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiQSBjbGllbnRfaWQgaXMgcmVxdWlyZWRcIikpO1xuICAgIH1cbiAgICBpZiAoIXJlZGlyZWN0X3VyaSkge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJBIHJlZGlyZWN0X3VyaSBpcyByZXF1aXJlZFwiKSk7XG4gICAgfVxuICAgIGlmICghYXJncy5jb2RlKSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIkEgY29kZSBpcyByZXF1aXJlZFwiKSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBncmFudF90eXBlLCByZWRpcmVjdF91cmkgfSk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYXJncykpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHBhcmFtcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBiYXNpY0F1dGg7XG4gICAgc3dpdGNoICh0aGlzLl9zZXR0aW5ncy5jbGllbnRfYXV0aGVudGljYXRpb24pIHtcbiAgICAgIGNhc2UgXCJjbGllbnRfc2VjcmV0X2Jhc2ljXCI6XG4gICAgICAgIGlmICghY2xpZW50X3NlY3JldCkge1xuICAgICAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiQSBjbGllbnRfc2VjcmV0IGlzIHJlcXVpcmVkXCIpKTtcbiAgICAgICAgICB0aHJvdyBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGJhc2ljQXV0aCA9IENyeXB0b1V0aWxzLmdlbmVyYXRlQmFzaWNBdXRoKGNsaWVudF9pZCwgY2xpZW50X3NlY3JldCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImNsaWVudF9zZWNyZXRfcG9zdFwiOlxuICAgICAgICBwYXJhbXMuYXBwZW5kKFwiY2xpZW50X2lkXCIsIGNsaWVudF9pZCk7XG4gICAgICAgIGlmIChjbGllbnRfc2VjcmV0KSB7XG4gICAgICAgICAgcGFyYW1zLmFwcGVuZChcImNsaWVudF9zZWNyZXRcIiwgY2xpZW50X3NlY3JldCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IGF3YWl0IHRoaXMuX21ldGFkYXRhU2VydmljZS5nZXRUb2tlbkVuZHBvaW50KGZhbHNlKTtcbiAgICBsb2dnZXIyLmRlYnVnKFwiZ290IHRva2VuIGVuZHBvaW50XCIpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fanNvblNlcnZpY2UucG9zdEZvcm0odXJsLCB7IGJvZHk6IHBhcmFtcywgYmFzaWNBdXRoLCBpbml0Q3JlZGVudGlhbHM6IHRoaXMuX3NldHRpbmdzLmZldGNoUmVxdWVzdENyZWRlbnRpYWxzIH0pO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJnb3QgcmVzcG9uc2VcIik7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIC8qKlxuICAgKiBFeGNoYW5nZSBjcmVkZW50aWFscy5cbiAgICpcbiAgICogQHNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNjc0OSNzZWN0aW9uLTQuMy4yXG4gICAqL1xuICBhc3luYyBleGNoYW5nZUNyZWRlbnRpYWxzKHtcbiAgICBncmFudF90eXBlID0gXCJwYXNzd29yZFwiLFxuICAgIGNsaWVudF9pZCA9IHRoaXMuX3NldHRpbmdzLmNsaWVudF9pZCxcbiAgICBjbGllbnRfc2VjcmV0ID0gdGhpcy5fc2V0dGluZ3MuY2xpZW50X3NlY3JldCxcbiAgICBzY29wZSA9IHRoaXMuX3NldHRpbmdzLnNjb3BlLFxuICAgIC4uLmFyZ3NcbiAgfSkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiZXhjaGFuZ2VDcmVkZW50aWFsc1wiKTtcbiAgICBpZiAoIWNsaWVudF9pZCkge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJBIGNsaWVudF9pZCBpcyByZXF1aXJlZFwiKSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBncmFudF90eXBlLCBzY29wZSB9KTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhcmdzKSkge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcGFyYW1zLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGJhc2ljQXV0aDtcbiAgICBzd2l0Y2ggKHRoaXMuX3NldHRpbmdzLmNsaWVudF9hdXRoZW50aWNhdGlvbikge1xuICAgICAgY2FzZSBcImNsaWVudF9zZWNyZXRfYmFzaWNcIjpcbiAgICAgICAgaWYgKCFjbGllbnRfc2VjcmV0KSB7XG4gICAgICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJBIGNsaWVudF9zZWNyZXQgaXMgcmVxdWlyZWRcIikpO1xuICAgICAgICAgIHRocm93IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYmFzaWNBdXRoID0gQ3J5cHRvVXRpbHMuZ2VuZXJhdGVCYXNpY0F1dGgoY2xpZW50X2lkLCBjbGllbnRfc2VjcmV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY2xpZW50X3NlY3JldF9wb3N0XCI6XG4gICAgICAgIHBhcmFtcy5hcHBlbmQoXCJjbGllbnRfaWRcIiwgY2xpZW50X2lkKTtcbiAgICAgICAgaWYgKGNsaWVudF9zZWNyZXQpIHtcbiAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiY2xpZW50X3NlY3JldFwiLCBjbGllbnRfc2VjcmV0KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgdXJsID0gYXdhaXQgdGhpcy5fbWV0YWRhdGFTZXJ2aWNlLmdldFRva2VuRW5kcG9pbnQoZmFsc2UpO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJnb3QgdG9rZW4gZW5kcG9pbnRcIik7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9qc29uU2VydmljZS5wb3N0Rm9ybSh1cmwsIHsgYm9keTogcGFyYW1zLCBiYXNpY0F1dGgsIGluaXRDcmVkZW50aWFsczogdGhpcy5fc2V0dGluZ3MuZmV0Y2hSZXF1ZXN0Q3JlZGVudGlhbHMgfSk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcImdvdCByZXNwb25zZVwiKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbiAgLyoqXG4gICAqIEV4Y2hhbmdlIGEgcmVmcmVzaCB0b2tlbi5cbiAgICpcbiAgICogQHNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNjc0OSNzZWN0aW9uLTZcbiAgICovXG4gIGFzeW5jIGV4Y2hhbmdlUmVmcmVzaFRva2VuKHtcbiAgICBncmFudF90eXBlID0gXCJyZWZyZXNoX3Rva2VuXCIsXG4gICAgY2xpZW50X2lkID0gdGhpcy5fc2V0dGluZ3MuY2xpZW50X2lkLFxuICAgIGNsaWVudF9zZWNyZXQgPSB0aGlzLl9zZXR0aW5ncy5jbGllbnRfc2VjcmV0LFxuICAgIHRpbWVvdXRJblNlY29uZHMsXG4gICAgLi4uYXJnc1xuICB9KSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJleGNoYW5nZVJlZnJlc2hUb2tlblwiKTtcbiAgICBpZiAoIWNsaWVudF9pZCkge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJBIGNsaWVudF9pZCBpcyByZXF1aXJlZFwiKSk7XG4gICAgfVxuICAgIGlmICghYXJncy5yZWZyZXNoX3Rva2VuKSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIkEgcmVmcmVzaF90b2tlbiBpcyByZXF1aXJlZFwiKSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBncmFudF90eXBlIH0pO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGFyZ3MpKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuZm9yRWFjaCgocGFyYW0pID0+IHBhcmFtcy5hcHBlbmQoa2V5LCBwYXJhbSkpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHBhcmFtcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBiYXNpY0F1dGg7XG4gICAgc3dpdGNoICh0aGlzLl9zZXR0aW5ncy5jbGllbnRfYXV0aGVudGljYXRpb24pIHtcbiAgICAgIGNhc2UgXCJjbGllbnRfc2VjcmV0X2Jhc2ljXCI6XG4gICAgICAgIGlmICghY2xpZW50X3NlY3JldCkge1xuICAgICAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiQSBjbGllbnRfc2VjcmV0IGlzIHJlcXVpcmVkXCIpKTtcbiAgICAgICAgICB0aHJvdyBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGJhc2ljQXV0aCA9IENyeXB0b1V0aWxzLmdlbmVyYXRlQmFzaWNBdXRoKGNsaWVudF9pZCwgY2xpZW50X3NlY3JldCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImNsaWVudF9zZWNyZXRfcG9zdFwiOlxuICAgICAgICBwYXJhbXMuYXBwZW5kKFwiY2xpZW50X2lkXCIsIGNsaWVudF9pZCk7XG4gICAgICAgIGlmIChjbGllbnRfc2VjcmV0KSB7XG4gICAgICAgICAgcGFyYW1zLmFwcGVuZChcImNsaWVudF9zZWNyZXRcIiwgY2xpZW50X3NlY3JldCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IGF3YWl0IHRoaXMuX21ldGFkYXRhU2VydmljZS5nZXRUb2tlbkVuZHBvaW50KGZhbHNlKTtcbiAgICBsb2dnZXIyLmRlYnVnKFwiZ290IHRva2VuIGVuZHBvaW50XCIpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fanNvblNlcnZpY2UucG9zdEZvcm0odXJsLCB7IGJvZHk6IHBhcmFtcywgYmFzaWNBdXRoLCB0aW1lb3V0SW5TZWNvbmRzLCBpbml0Q3JlZGVudGlhbHM6IHRoaXMuX3NldHRpbmdzLmZldGNoUmVxdWVzdENyZWRlbnRpYWxzIH0pO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJnb3QgcmVzcG9uc2VcIik7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIC8qKlxuICAgKiBSZXZva2UgYW4gYWNjZXNzIG9yIHJlZnJlc2ggdG9rZW4uXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM3MDA5I3NlY3Rpb24tMi4xXG4gICAqL1xuICBhc3luYyByZXZva2UoYXJncykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInJldm9rZVwiKTtcbiAgICBpZiAoIWFyZ3MudG9rZW4pIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiQSB0b2tlbiBpcyByZXF1aXJlZFwiKSk7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IGF3YWl0IHRoaXMuX21ldGFkYXRhU2VydmljZS5nZXRSZXZvY2F0aW9uRW5kcG9pbnQoZmFsc2UpO1xuICAgIGxvZ2dlcjIuZGVidWcoYGdvdCByZXZvY2F0aW9uIGVuZHBvaW50LCByZXZva2luZyAkeyhfYSA9IGFyZ3MudG9rZW5fdHlwZV9oaW50KSAhPSBudWxsID8gX2EgOiBcImRlZmF1bHQgdG9rZW4gdHlwZVwifWApO1xuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhcmdzKSkge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcGFyYW1zLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcGFyYW1zLnNldChcImNsaWVudF9pZFwiLCB0aGlzLl9zZXR0aW5ncy5jbGllbnRfaWQpO1xuICAgIGlmICh0aGlzLl9zZXR0aW5ncy5jbGllbnRfc2VjcmV0KSB7XG4gICAgICBwYXJhbXMuc2V0KFwiY2xpZW50X3NlY3JldFwiLCB0aGlzLl9zZXR0aW5ncy5jbGllbnRfc2VjcmV0KTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5fanNvblNlcnZpY2UucG9zdEZvcm0odXJsLCB7IGJvZHk6IHBhcmFtcyB9KTtcbiAgICBsb2dnZXIyLmRlYnVnKFwiZ290IHJlc3BvbnNlXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvUmVzcG9uc2VWYWxpZGF0b3IudHNcbnZhciBSZXNwb25zZVZhbGlkYXRvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoX3NldHRpbmdzLCBfbWV0YWRhdGFTZXJ2aWNlLCBfY2xhaW1zU2VydmljZSkge1xuICAgIHRoaXMuX3NldHRpbmdzID0gX3NldHRpbmdzO1xuICAgIHRoaXMuX21ldGFkYXRhU2VydmljZSA9IF9tZXRhZGF0YVNlcnZpY2U7XG4gICAgdGhpcy5fY2xhaW1zU2VydmljZSA9IF9jbGFpbXNTZXJ2aWNlO1xuICAgIHRoaXMuX2xvZ2dlciA9IG5ldyBMb2dnZXIoXCJSZXNwb25zZVZhbGlkYXRvclwiKTtcbiAgICB0aGlzLl91c2VySW5mb1NlcnZpY2UgPSBuZXcgVXNlckluZm9TZXJ2aWNlKHRoaXMuX3NldHRpbmdzLCB0aGlzLl9tZXRhZGF0YVNlcnZpY2UpO1xuICAgIHRoaXMuX3Rva2VuQ2xpZW50ID0gbmV3IFRva2VuQ2xpZW50KHRoaXMuX3NldHRpbmdzLCB0aGlzLl9tZXRhZGF0YVNlcnZpY2UpO1xuICB9XG4gIGFzeW5jIHZhbGlkYXRlU2lnbmluUmVzcG9uc2UocmVzcG9uc2UsIHN0YXRlKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJ2YWxpZGF0ZVNpZ25pblJlc3BvbnNlXCIpO1xuICAgIHRoaXMuX3Byb2Nlc3NTaWduaW5TdGF0ZShyZXNwb25zZSwgc3RhdGUpO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJzdGF0ZSBwcm9jZXNzZWRcIik7XG4gICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0NvZGUocmVzcG9uc2UsIHN0YXRlKTtcbiAgICBsb2dnZXIyLmRlYnVnKFwiY29kZSBwcm9jZXNzZWRcIik7XG4gICAgaWYgKHJlc3BvbnNlLmlzT3BlbklkKSB7XG4gICAgICB0aGlzLl92YWxpZGF0ZUlkVG9rZW5BdHRyaWJ1dGVzKHJlc3BvbnNlKTtcbiAgICB9XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcInRva2VucyB2YWxpZGF0ZWRcIik7XG4gICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0NsYWltcyhyZXNwb25zZSwgc3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLnNraXBVc2VySW5mbywgcmVzcG9uc2UuaXNPcGVuSWQpO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJjbGFpbXMgcHJvY2Vzc2VkXCIpO1xuICB9XG4gIGFzeW5jIHZhbGlkYXRlQ3JlZGVudGlhbHNSZXNwb25zZShyZXNwb25zZSwgc2tpcFVzZXJJbmZvKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJ2YWxpZGF0ZUNyZWRlbnRpYWxzUmVzcG9uc2VcIik7XG4gICAgaWYgKHJlc3BvbnNlLmlzT3BlbklkICYmICEhcmVzcG9uc2UuaWRfdG9rZW4pIHtcbiAgICAgIHRoaXMuX3ZhbGlkYXRlSWRUb2tlbkF0dHJpYnV0ZXMocmVzcG9uc2UpO1xuICAgIH1cbiAgICBsb2dnZXIyLmRlYnVnKFwidG9rZW5zIHZhbGlkYXRlZFwiKTtcbiAgICBhd2FpdCB0aGlzLl9wcm9jZXNzQ2xhaW1zKHJlc3BvbnNlLCBza2lwVXNlckluZm8sIHJlc3BvbnNlLmlzT3BlbklkKTtcbiAgICBsb2dnZXIyLmRlYnVnKFwiY2xhaW1zIHByb2Nlc3NlZFwiKTtcbiAgfVxuICBhc3luYyB2YWxpZGF0ZVJlZnJlc2hSZXNwb25zZShyZXNwb25zZSwgc3RhdGUpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwidmFsaWRhdGVSZWZyZXNoUmVzcG9uc2VcIik7XG4gICAgcmVzcG9uc2UudXNlclN0YXRlID0gc3RhdGUuZGF0YTtcbiAgICAoX2EgPSByZXNwb25zZS5zZXNzaW9uX3N0YXRlKSAhPSBudWxsID8gX2EgOiByZXNwb25zZS5zZXNzaW9uX3N0YXRlID0gc3RhdGUuc2Vzc2lvbl9zdGF0ZTtcbiAgICAoX2IgPSByZXNwb25zZS5zY29wZSkgIT0gbnVsbCA/IF9iIDogcmVzcG9uc2Uuc2NvcGUgPSBzdGF0ZS5zY29wZTtcbiAgICBpZiAocmVzcG9uc2UuaXNPcGVuSWQgJiYgISFyZXNwb25zZS5pZF90b2tlbikge1xuICAgICAgdGhpcy5fdmFsaWRhdGVJZFRva2VuQXR0cmlidXRlcyhyZXNwb25zZSwgc3RhdGUuaWRfdG9rZW4pO1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcIklEIFRva2VuIHZhbGlkYXRlZFwiKTtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5pZF90b2tlbikge1xuICAgICAgcmVzcG9uc2UuaWRfdG9rZW4gPSBzdGF0ZS5pZF90b2tlbjtcbiAgICAgIHJlc3BvbnNlLnByb2ZpbGUgPSBzdGF0ZS5wcm9maWxlO1xuICAgIH1cbiAgICBjb25zdCBoYXNJZFRva2VuID0gcmVzcG9uc2UuaXNPcGVuSWQgJiYgISFyZXNwb25zZS5pZF90b2tlbjtcbiAgICBhd2FpdCB0aGlzLl9wcm9jZXNzQ2xhaW1zKHJlc3BvbnNlLCBmYWxzZSwgaGFzSWRUb2tlbik7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcImNsYWltcyBwcm9jZXNzZWRcIik7XG4gIH1cbiAgdmFsaWRhdGVTaWdub3V0UmVzcG9uc2UocmVzcG9uc2UsIHN0YXRlKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJ2YWxpZGF0ZVNpZ25vdXRSZXNwb25zZVwiKTtcbiAgICBpZiAoc3RhdGUuaWQgIT09IHJlc3BvbnNlLnN0YXRlKSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIlN0YXRlIGRvZXMgbm90IG1hdGNoXCIpKTtcbiAgICB9XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcInN0YXRlIHZhbGlkYXRlZFwiKTtcbiAgICByZXNwb25zZS51c2VyU3RhdGUgPSBzdGF0ZS5kYXRhO1xuICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgbG9nZ2VyMi53YXJuKFwiUmVzcG9uc2Ugd2FzIGVycm9yXCIsIHJlc3BvbnNlLmVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvclJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9XG4gIH1cbiAgX3Byb2Nlc3NTaWduaW5TdGF0ZShyZXNwb25zZSwgc3RhdGUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJfcHJvY2Vzc1NpZ25pblN0YXRlXCIpO1xuICAgIGlmIChzdGF0ZS5pZCAhPT0gcmVzcG9uc2Uuc3RhdGUpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiU3RhdGUgZG9lcyBub3QgbWF0Y2hcIikpO1xuICAgIH1cbiAgICBpZiAoIXN0YXRlLmNsaWVudF9pZCkge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJObyBjbGllbnRfaWQgb24gc3RhdGVcIikpO1xuICAgIH1cbiAgICBpZiAoIXN0YXRlLmF1dGhvcml0eSkge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJObyBhdXRob3JpdHkgb24gc3RhdGVcIikpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc2V0dGluZ3MuYXV0aG9yaXR5ICE9PSBzdGF0ZS5hdXRob3JpdHkpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiYXV0aG9yaXR5IG1pc21hdGNoIG9uIHNldHRpbmdzIHZzLiBzaWduaW4gc3RhdGVcIikpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc2V0dGluZ3MuY2xpZW50X2lkICYmIHRoaXMuX3NldHRpbmdzLmNsaWVudF9pZCAhPT0gc3RhdGUuY2xpZW50X2lkKSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcImNsaWVudF9pZCBtaXNtYXRjaCBvbiBzZXR0aW5ncyB2cy4gc2lnbmluIHN0YXRlXCIpKTtcbiAgICB9XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcInN0YXRlIHZhbGlkYXRlZFwiKTtcbiAgICByZXNwb25zZS51c2VyU3RhdGUgPSBzdGF0ZS5kYXRhO1xuICAgIHJlc3BvbnNlLnVybF9zdGF0ZSA9IHN0YXRlLnVybF9zdGF0ZTtcbiAgICAoX2EgPSByZXNwb25zZS5zY29wZSkgIT0gbnVsbCA/IF9hIDogcmVzcG9uc2Uuc2NvcGUgPSBzdGF0ZS5zY29wZTtcbiAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjIud2FybihcIlJlc3BvbnNlIHdhcyBlcnJvclwiLCByZXNwb25zZS5lcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JSZXNwb25zZShyZXNwb25zZSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5jb2RlX3ZlcmlmaWVyICYmICFyZXNwb25zZS5jb2RlKSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIkV4cGVjdGVkIGNvZGUgaW4gcmVzcG9uc2VcIikpO1xuICAgIH1cbiAgfVxuICBhc3luYyBfcHJvY2Vzc0NsYWltcyhyZXNwb25zZSwgc2tpcFVzZXJJbmZvID0gZmFsc2UsIHZhbGlkYXRlU3ViID0gdHJ1ZSkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiX3Byb2Nlc3NDbGFpbXNcIik7XG4gICAgcmVzcG9uc2UucHJvZmlsZSA9IHRoaXMuX2NsYWltc1NlcnZpY2UuZmlsdGVyUHJvdG9jb2xDbGFpbXMocmVzcG9uc2UucHJvZmlsZSk7XG4gICAgaWYgKHNraXBVc2VySW5mbyB8fCAhdGhpcy5fc2V0dGluZ3MubG9hZFVzZXJJbmZvIHx8ICFyZXNwb25zZS5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJub3QgbG9hZGluZyB1c2VyIGluZm9cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvZ2dlcjIuZGVidWcoXCJsb2FkaW5nIHVzZXIgaW5mb1wiKTtcbiAgICBjb25zdCBjbGFpbXMgPSBhd2FpdCB0aGlzLl91c2VySW5mb1NlcnZpY2UuZ2V0Q2xhaW1zKHJlc3BvbnNlLmFjY2Vzc190b2tlbik7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcInVzZXIgaW5mbyBjbGFpbXMgcmVjZWl2ZWQgZnJvbSB1c2VyIGluZm8gZW5kcG9pbnRcIik7XG4gICAgaWYgKHZhbGlkYXRlU3ViICYmIGNsYWltcy5zdWIgIT09IHJlc3BvbnNlLnByb2ZpbGUuc3ViKSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcInN1YmplY3QgZnJvbSBVc2VySW5mbyByZXNwb25zZSBkb2VzIG5vdCBtYXRjaCBzdWJqZWN0IGluIElEIFRva2VuXCIpKTtcbiAgICB9XG4gICAgcmVzcG9uc2UucHJvZmlsZSA9IHRoaXMuX2NsYWltc1NlcnZpY2UubWVyZ2VDbGFpbXMocmVzcG9uc2UucHJvZmlsZSwgdGhpcy5fY2xhaW1zU2VydmljZS5maWx0ZXJQcm90b2NvbENsYWltcyhjbGFpbXMpKTtcbiAgICBsb2dnZXIyLmRlYnVnKFwidXNlciBpbmZvIGNsYWltcyByZWNlaXZlZCwgdXBkYXRlZCBwcm9maWxlOlwiLCByZXNwb25zZS5wcm9maWxlKTtcbiAgfVxuICBhc3luYyBfcHJvY2Vzc0NvZGUocmVzcG9uc2UsIHN0YXRlKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJfcHJvY2Vzc0NvZGVcIik7XG4gICAgaWYgKHJlc3BvbnNlLmNvZGUpIHtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJWYWxpZGF0aW5nIGNvZGVcIik7XG4gICAgICBjb25zdCB0b2tlblJlc3BvbnNlID0gYXdhaXQgdGhpcy5fdG9rZW5DbGllbnQuZXhjaGFuZ2VDb2RlKHtcbiAgICAgICAgY2xpZW50X2lkOiBzdGF0ZS5jbGllbnRfaWQsXG4gICAgICAgIGNsaWVudF9zZWNyZXQ6IHN0YXRlLmNsaWVudF9zZWNyZXQsXG4gICAgICAgIGNvZGU6IHJlc3BvbnNlLmNvZGUsXG4gICAgICAgIHJlZGlyZWN0X3VyaTogc3RhdGUucmVkaXJlY3RfdXJpLFxuICAgICAgICBjb2RlX3ZlcmlmaWVyOiBzdGF0ZS5jb2RlX3ZlcmlmaWVyLFxuICAgICAgICAuLi5zdGF0ZS5leHRyYVRva2VuUGFyYW1zXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5hc3NpZ24ocmVzcG9uc2UsIHRva2VuUmVzcG9uc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwiTm8gY29kZSB0byBwcm9jZXNzXCIpO1xuICAgIH1cbiAgfVxuICBfdmFsaWRhdGVJZFRva2VuQXR0cmlidXRlcyhyZXNwb25zZSwgZXhpc3RpbmdUb2tlbikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIl92YWxpZGF0ZUlkVG9rZW5BdHRyaWJ1dGVzXCIpO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJkZWNvZGluZyBJRCBUb2tlbiBKV1RcIik7XG4gICAgY29uc3QgaW5jb21pbmcgPSBKd3RVdGlscy5kZWNvZGUoKF9hID0gcmVzcG9uc2UuaWRfdG9rZW4pICE9IG51bGwgPyBfYSA6IFwiXCIpO1xuICAgIGlmICghaW5jb21pbmcuc3ViKSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIklEIFRva2VuIGlzIG1pc3NpbmcgYSBzdWJqZWN0IGNsYWltXCIpKTtcbiAgICB9XG4gICAgaWYgKGV4aXN0aW5nVG9rZW4pIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gSnd0VXRpbHMuZGVjb2RlKGV4aXN0aW5nVG9rZW4pO1xuICAgICAgaWYgKGluY29taW5nLnN1YiAhPT0gZXhpc3Rpbmcuc3ViKSB7XG4gICAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwic3ViIGluIGlkX3Rva2VuIGRvZXMgbm90IG1hdGNoIGN1cnJlbnQgc3ViXCIpKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmNvbWluZy5hdXRoX3RpbWUgJiYgaW5jb21pbmcuYXV0aF90aW1lICE9PSBleGlzdGluZy5hdXRoX3RpbWUpIHtcbiAgICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJhdXRoX3RpbWUgaW4gaWRfdG9rZW4gZG9lcyBub3QgbWF0Y2ggb3JpZ2luYWwgYXV0aF90aW1lXCIpKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmNvbWluZy5henAgJiYgaW5jb21pbmcuYXpwICE9PSBleGlzdGluZy5henApIHtcbiAgICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJhenAgaW4gaWRfdG9rZW4gZG9lcyBub3QgbWF0Y2ggb3JpZ2luYWwgYXpwXCIpKTtcbiAgICAgIH1cbiAgICAgIGlmICghaW5jb21pbmcuYXpwICYmIGV4aXN0aW5nLmF6cCkge1xuICAgICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcImF6cCBub3QgaW4gaWRfdG9rZW4sIGJ1dCBwcmVzZW50IGluIG9yaWdpbmFsIGlkX3Rva2VuXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzcG9uc2UucHJvZmlsZSA9IGluY29taW5nO1xuICB9XG59O1xuXG4vLyBzcmMvU3RhdGUudHNcbnZhciBTdGF0ZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHRoaXMuaWQgPSBhcmdzLmlkIHx8IENyeXB0b1V0aWxzLmdlbmVyYXRlVVVJRHY0KCk7XG4gICAgdGhpcy5kYXRhID0gYXJncy5kYXRhO1xuICAgIGlmIChhcmdzLmNyZWF0ZWQgJiYgYXJncy5jcmVhdGVkID4gMCkge1xuICAgICAgdGhpcy5jcmVhdGVkID0gYXJncy5jcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNyZWF0ZWQgPSBUaW1lci5nZXRFcG9jaFRpbWUoKTtcbiAgICB9XG4gICAgdGhpcy5yZXF1ZXN0X3R5cGUgPSBhcmdzLnJlcXVlc3RfdHlwZTtcbiAgICB0aGlzLnVybF9zdGF0ZSA9IGFyZ3MudXJsX3N0YXRlO1xuICB9XG4gIHRvU3RvcmFnZVN0cmluZygpIHtcbiAgICBuZXcgTG9nZ2VyKFwiU3RhdGVcIikuY3JlYXRlKFwidG9TdG9yYWdlU3RyaW5nXCIpO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIGRhdGE6IHRoaXMuZGF0YSxcbiAgICAgIGNyZWF0ZWQ6IHRoaXMuY3JlYXRlZCxcbiAgICAgIHJlcXVlc3RfdHlwZTogdGhpcy5yZXF1ZXN0X3R5cGUsXG4gICAgICB1cmxfc3RhdGU6IHRoaXMudXJsX3N0YXRlXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGZyb21TdG9yYWdlU3RyaW5nKHN0b3JhZ2VTdHJpbmcpIHtcbiAgICBMb2dnZXIuY3JlYXRlU3RhdGljKFwiU3RhdGVcIiwgXCJmcm9tU3RvcmFnZVN0cmluZ1wiKTtcbiAgICByZXR1cm4gbmV3IFN0YXRlKEpTT04ucGFyc2Uoc3RvcmFnZVN0cmluZykpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBjbGVhclN0YWxlU3RhdGUoc3RvcmFnZSwgYWdlKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IExvZ2dlci5jcmVhdGVTdGF0aWMoXCJTdGF0ZVwiLCBcImNsZWFyU3RhbGVTdGF0ZVwiKTtcbiAgICBjb25zdCBjdXRvZmYgPSBUaW1lci5nZXRFcG9jaFRpbWUoKSAtIGFnZTtcbiAgICBjb25zdCBrZXlzID0gYXdhaXQgc3RvcmFnZS5nZXRBbGxLZXlzKCk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcImdvdCBrZXlzXCIsIGtleXMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCBzdG9yYWdlLmdldChrZXkpO1xuICAgICAgbGV0IHJlbW92ZSA9IGZhbHNlO1xuICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IFN0YXRlLmZyb21TdG9yYWdlU3RyaW5nKGl0ZW0pO1xuICAgICAgICAgIGxvZ2dlcjIuZGVidWcoXCJnb3QgaXRlbSBmcm9tIGtleTpcIiwga2V5LCBzdGF0ZS5jcmVhdGVkKTtcbiAgICAgICAgICBpZiAoc3RhdGUuY3JlYXRlZCA8PSBjdXRvZmYpIHtcbiAgICAgICAgICAgIHJlbW92ZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBsb2dnZXIyLmVycm9yKFwiRXJyb3IgcGFyc2luZyBzdGF0ZSBmb3Iga2V5OlwiLCBrZXksIGVycik7XG4gICAgICAgICAgcmVtb3ZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyMi5kZWJ1ZyhcIm5vIGl0ZW0gaW4gc3RvcmFnZSBmb3Iga2V5OlwiLCBrZXkpO1xuICAgICAgICByZW1vdmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICBsb2dnZXIyLmRlYnVnKFwicmVtb3ZlZCBpdGVtIGZvciBrZXk6XCIsIGtleSk7XG4gICAgICAgIHZvaWQgc3RvcmFnZS5yZW1vdmUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9TaWduaW5TdGF0ZS50c1xudmFyIFNpZ25pblN0YXRlID0gY2xhc3MgZXh0ZW5kcyBTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICBzdXBlcihhcmdzKTtcbiAgICBpZiAoYXJncy5jb2RlX3ZlcmlmaWVyID09PSB0cnVlKSB7XG4gICAgICB0aGlzLmNvZGVfdmVyaWZpZXIgPSBDcnlwdG9VdGlscy5nZW5lcmF0ZUNvZGVWZXJpZmllcigpO1xuICAgIH0gZWxzZSBpZiAoYXJncy5jb2RlX3ZlcmlmaWVyKSB7XG4gICAgICB0aGlzLmNvZGVfdmVyaWZpZXIgPSBhcmdzLmNvZGVfdmVyaWZpZXI7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvZGVfdmVyaWZpZXIpIHtcbiAgICAgIHRoaXMuY29kZV9jaGFsbGVuZ2UgPSBDcnlwdG9VdGlscy5nZW5lcmF0ZUNvZGVDaGFsbGVuZ2UodGhpcy5jb2RlX3ZlcmlmaWVyKTtcbiAgICB9XG4gICAgdGhpcy5hdXRob3JpdHkgPSBhcmdzLmF1dGhvcml0eTtcbiAgICB0aGlzLmNsaWVudF9pZCA9IGFyZ3MuY2xpZW50X2lkO1xuICAgIHRoaXMucmVkaXJlY3RfdXJpID0gYXJncy5yZWRpcmVjdF91cmk7XG4gICAgdGhpcy5zY29wZSA9IGFyZ3Muc2NvcGU7XG4gICAgdGhpcy5jbGllbnRfc2VjcmV0ID0gYXJncy5jbGllbnRfc2VjcmV0O1xuICAgIHRoaXMuZXh0cmFUb2tlblBhcmFtcyA9IGFyZ3MuZXh0cmFUb2tlblBhcmFtcztcbiAgICB0aGlzLnJlc3BvbnNlX21vZGUgPSBhcmdzLnJlc3BvbnNlX21vZGU7XG4gICAgdGhpcy5za2lwVXNlckluZm8gPSBhcmdzLnNraXBVc2VySW5mbztcbiAgfVxuICB0b1N0b3JhZ2VTdHJpbmcoKSB7XG4gICAgbmV3IExvZ2dlcihcIlNpZ25pblN0YXRlXCIpLmNyZWF0ZShcInRvU3RvcmFnZVN0cmluZ1wiKTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICBjcmVhdGVkOiB0aGlzLmNyZWF0ZWQsXG4gICAgICByZXF1ZXN0X3R5cGU6IHRoaXMucmVxdWVzdF90eXBlLFxuICAgICAgdXJsX3N0YXRlOiB0aGlzLnVybF9zdGF0ZSxcbiAgICAgIGNvZGVfdmVyaWZpZXI6IHRoaXMuY29kZV92ZXJpZmllcixcbiAgICAgIGF1dGhvcml0eTogdGhpcy5hdXRob3JpdHksXG4gICAgICBjbGllbnRfaWQ6IHRoaXMuY2xpZW50X2lkLFxuICAgICAgcmVkaXJlY3RfdXJpOiB0aGlzLnJlZGlyZWN0X3VyaSxcbiAgICAgIHNjb3BlOiB0aGlzLnNjb3BlLFxuICAgICAgY2xpZW50X3NlY3JldDogdGhpcy5jbGllbnRfc2VjcmV0LFxuICAgICAgZXh0cmFUb2tlblBhcmFtczogdGhpcy5leHRyYVRva2VuUGFyYW1zLFxuICAgICAgcmVzcG9uc2VfbW9kZTogdGhpcy5yZXNwb25zZV9tb2RlLFxuICAgICAgc2tpcFVzZXJJbmZvOiB0aGlzLnNraXBVc2VySW5mb1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBmcm9tU3RvcmFnZVN0cmluZyhzdG9yYWdlU3RyaW5nKSB7XG4gICAgTG9nZ2VyLmNyZWF0ZVN0YXRpYyhcIlNpZ25pblN0YXRlXCIsIFwiZnJvbVN0b3JhZ2VTdHJpbmdcIik7XG4gICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2Uoc3RvcmFnZVN0cmluZyk7XG4gICAgcmV0dXJuIG5ldyBTaWduaW5TdGF0ZShkYXRhKTtcbiAgfVxufTtcblxuLy8gc3JjL1NpZ25pblJlcXVlc3QudHNcbnZhciBTaWduaW5SZXF1ZXN0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgLy8gbWFuZGF0b3J5XG4gICAgdXJsLFxuICAgIGF1dGhvcml0eSxcbiAgICBjbGllbnRfaWQsXG4gICAgcmVkaXJlY3RfdXJpLFxuICAgIHJlc3BvbnNlX3R5cGUsXG4gICAgc2NvcGUsXG4gICAgLy8gb3B0aW9uYWxcbiAgICBzdGF0ZV9kYXRhLFxuICAgIHJlc3BvbnNlX21vZGUsXG4gICAgcmVxdWVzdF90eXBlLFxuICAgIGNsaWVudF9zZWNyZXQsXG4gICAgbm9uY2UsXG4gICAgdXJsX3N0YXRlLFxuICAgIHJlc291cmNlLFxuICAgIHNraXBVc2VySW5mbyxcbiAgICBleHRyYVF1ZXJ5UGFyYW1zLFxuICAgIGV4dHJhVG9rZW5QYXJhbXMsXG4gICAgZGlzYWJsZVBLQ0UsXG4gICAgLi4ub3B0aW9uYWxQYXJhbXNcbiAgfSkge1xuICAgIHRoaXMuX2xvZ2dlciA9IG5ldyBMb2dnZXIoXCJTaWduaW5SZXF1ZXN0XCIpO1xuICAgIGlmICghdXJsKSB7XG4gICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoXCJjdG9yOiBObyB1cmwgcGFzc2VkXCIpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidXJsXCIpO1xuICAgIH1cbiAgICBpZiAoIWNsaWVudF9pZCkge1xuICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKFwiY3RvcjogTm8gY2xpZW50X2lkIHBhc3NlZFwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNsaWVudF9pZFwiKTtcbiAgICB9XG4gICAgaWYgKCFyZWRpcmVjdF91cmkpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihcImN0b3I6IE5vIHJlZGlyZWN0X3VyaSBwYXNzZWRcIik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWRpcmVjdF91cmlcIik7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2VfdHlwZSkge1xuICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKFwiY3RvcjogTm8gcmVzcG9uc2VfdHlwZSBwYXNzZWRcIik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZXNwb25zZV90eXBlXCIpO1xuICAgIH1cbiAgICBpZiAoIXNjb3BlKSB7XG4gICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoXCJjdG9yOiBObyBzY29wZSBwYXNzZWRcIik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY29wZVwiKTtcbiAgICB9XG4gICAgaWYgKCFhdXRob3JpdHkpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihcImN0b3I6IE5vIGF1dGhvcml0eSBwYXNzZWRcIik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdXRob3JpdHlcIik7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSBuZXcgU2lnbmluU3RhdGUoe1xuICAgICAgZGF0YTogc3RhdGVfZGF0YSxcbiAgICAgIHJlcXVlc3RfdHlwZSxcbiAgICAgIHVybF9zdGF0ZSxcbiAgICAgIGNvZGVfdmVyaWZpZXI6ICFkaXNhYmxlUEtDRSxcbiAgICAgIGNsaWVudF9pZCxcbiAgICAgIGF1dGhvcml0eSxcbiAgICAgIHJlZGlyZWN0X3VyaSxcbiAgICAgIHJlc3BvbnNlX21vZGUsXG4gICAgICBjbGllbnRfc2VjcmV0LFxuICAgICAgc2NvcGUsXG4gICAgICBleHRyYVRva2VuUGFyYW1zLFxuICAgICAgc2tpcFVzZXJJbmZvXG4gICAgfSk7XG4gICAgY29uc3QgcGFyc2VkVXJsID0gbmV3IFVSTCh1cmwpO1xuICAgIHBhcnNlZFVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwiY2xpZW50X2lkXCIsIGNsaWVudF9pZCk7XG4gICAgcGFyc2VkVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJyZWRpcmVjdF91cmlcIiwgcmVkaXJlY3RfdXJpKTtcbiAgICBwYXJzZWRVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcInJlc3BvbnNlX3R5cGVcIiwgcmVzcG9uc2VfdHlwZSk7XG4gICAgcGFyc2VkVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJzY29wZVwiLCBzY29wZSk7XG4gICAgaWYgKG5vbmNlKSB7XG4gICAgICBwYXJzZWRVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcIm5vbmNlXCIsIG5vbmNlKTtcbiAgICB9XG4gICAgbGV0IHN0YXRlID0gdGhpcy5zdGF0ZS5pZDtcbiAgICBpZiAodXJsX3N0YXRlKSB7XG4gICAgICBzdGF0ZSA9IGAke3N0YXRlfSR7VVJMX1NUQVRFX0RFTElNSVRFUn0ke3VybF9zdGF0ZX1gO1xuICAgIH1cbiAgICBwYXJzZWRVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcInN0YXRlXCIsIHN0YXRlKTtcbiAgICBpZiAodGhpcy5zdGF0ZS5jb2RlX2NoYWxsZW5nZSkge1xuICAgICAgcGFyc2VkVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJjb2RlX2NoYWxsZW5nZVwiLCB0aGlzLnN0YXRlLmNvZGVfY2hhbGxlbmdlKTtcbiAgICAgIHBhcnNlZFVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwiY29kZV9jaGFsbGVuZ2VfbWV0aG9kXCIsIFwiUzI1NlwiKTtcbiAgICB9XG4gICAgaWYgKHJlc291cmNlKSB7XG4gICAgICBjb25zdCByZXNvdXJjZXMgPSBBcnJheS5pc0FycmF5KHJlc291cmNlKSA/IHJlc291cmNlIDogW3Jlc291cmNlXTtcbiAgICAgIHJlc291cmNlcy5mb3JFYWNoKChyKSA9PiBwYXJzZWRVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcInJlc291cmNlXCIsIHIpKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoeyByZXNwb25zZV9tb2RlLCAuLi5vcHRpb25hbFBhcmFtcywgLi4uZXh0cmFRdWVyeVBhcmFtcyB9KSkge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcGFyc2VkVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51cmwgPSBwYXJzZWRVcmwuaHJlZjtcbiAgfVxufTtcblxuLy8gc3JjL1NpZ25pblJlc3BvbnNlLnRzXG52YXIgT2lkY1Njb3BlID0gXCJvcGVuaWRcIjtcbnZhciBTaWduaW5SZXNwb25zZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgLyoqIEBzZWUge0BsaW5rIFVzZXIuYWNjZXNzX3Rva2VufSAqL1xuICAgIHRoaXMuYWNjZXNzX3Rva2VuID0gXCJcIjtcbiAgICAvKiogQHNlZSB7QGxpbmsgVXNlci50b2tlbl90eXBlfSAqL1xuICAgIHRoaXMudG9rZW5fdHlwZSA9IFwiXCI7XG4gICAgLyoqIEBzZWUge0BsaW5rIFVzZXIucHJvZmlsZX0gKi9cbiAgICB0aGlzLnByb2ZpbGUgPSB7fTtcbiAgICB0aGlzLnN0YXRlID0gcGFyYW1zLmdldChcInN0YXRlXCIpO1xuICAgIHRoaXMuc2Vzc2lvbl9zdGF0ZSA9IHBhcmFtcy5nZXQoXCJzZXNzaW9uX3N0YXRlXCIpO1xuICAgIGlmICh0aGlzLnN0YXRlKSB7XG4gICAgICBjb25zdCBzcGxpdFN0YXRlID0gZGVjb2RlVVJJQ29tcG9uZW50KHRoaXMuc3RhdGUpLnNwbGl0KFVSTF9TVEFURV9ERUxJTUlURVIpO1xuICAgICAgdGhpcy5zdGF0ZSA9IHNwbGl0U3RhdGVbMF07XG4gICAgICBpZiAoc3BsaXRTdGF0ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMudXJsX3N0YXRlID0gc3BsaXRTdGF0ZS5zbGljZSgxKS5qb2luKFVSTF9TVEFURV9ERUxJTUlURVIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmVycm9yID0gcGFyYW1zLmdldChcImVycm9yXCIpO1xuICAgIHRoaXMuZXJyb3JfZGVzY3JpcHRpb24gPSBwYXJhbXMuZ2V0KFwiZXJyb3JfZGVzY3JpcHRpb25cIik7XG4gICAgdGhpcy5lcnJvcl91cmkgPSBwYXJhbXMuZ2V0KFwiZXJyb3JfdXJpXCIpO1xuICAgIHRoaXMuY29kZSA9IHBhcmFtcy5nZXQoXCJjb2RlXCIpO1xuICB9XG4gIGdldCBleHBpcmVzX2luKCkge1xuICAgIGlmICh0aGlzLmV4cGlyZXNfYXQgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZXhwaXJlc19hdCAtIFRpbWVyLmdldEVwb2NoVGltZSgpO1xuICB9XG4gIHNldCBleHBpcmVzX2luKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgIHZhbHVlID0gTnVtYmVyKHZhbHVlKTtcbiAgICBpZiAodmFsdWUgIT09IHZvaWQgMCAmJiB2YWx1ZSA+PSAwKSB7XG4gICAgICB0aGlzLmV4cGlyZXNfYXQgPSBNYXRoLmZsb29yKHZhbHVlKSArIFRpbWVyLmdldEVwb2NoVGltZSgpO1xuICAgIH1cbiAgfVxuICBnZXQgaXNPcGVuSWQoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gdGhpcy5zY29wZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNwbGl0KFwiIFwiKS5pbmNsdWRlcyhPaWRjU2NvcGUpKSB8fCAhIXRoaXMuaWRfdG9rZW47XG4gIH1cbn07XG5cbi8vIHNyYy9TaWdub3V0UmVxdWVzdC50c1xudmFyIFNpZ25vdXRSZXF1ZXN0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdXJsLFxuICAgIHN0YXRlX2RhdGEsXG4gICAgaWRfdG9rZW5faGludCxcbiAgICBwb3N0X2xvZ291dF9yZWRpcmVjdF91cmksXG4gICAgZXh0cmFRdWVyeVBhcmFtcyxcbiAgICByZXF1ZXN0X3R5cGUsXG4gICAgY2xpZW50X2lkXG4gIH0pIHtcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiU2lnbm91dFJlcXVlc3RcIik7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihcImN0b3I6IE5vIHVybCBwYXNzZWRcIik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1cmxcIik7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwodXJsKTtcbiAgICBpZiAoaWRfdG9rZW5faGludCkge1xuICAgICAgcGFyc2VkVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJpZF90b2tlbl9oaW50XCIsIGlkX3Rva2VuX2hpbnQpO1xuICAgIH1cbiAgICBpZiAoY2xpZW50X2lkKSB7XG4gICAgICBwYXJzZWRVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcImNsaWVudF9pZFwiLCBjbGllbnRfaWQpO1xuICAgIH1cbiAgICBpZiAocG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpKSB7XG4gICAgICBwYXJzZWRVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcInBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaVwiLCBwb3N0X2xvZ291dF9yZWRpcmVjdF91cmkpO1xuICAgICAgaWYgKHN0YXRlX2RhdGEpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG5ldyBTdGF0ZSh7IGRhdGE6IHN0YXRlX2RhdGEsIHJlcXVlc3RfdHlwZSB9KTtcbiAgICAgICAgcGFyc2VkVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJzdGF0ZVwiLCB0aGlzLnN0YXRlLmlkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoeyAuLi5leHRyYVF1ZXJ5UGFyYW1zIH0pKSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBwYXJzZWRVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnVybCA9IHBhcnNlZFVybC5ocmVmO1xuICB9XG59O1xuXG4vLyBzcmMvU2lnbm91dFJlc3BvbnNlLnRzXG52YXIgU2lnbm91dFJlc3BvbnNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICB0aGlzLnN0YXRlID0gcGFyYW1zLmdldChcInN0YXRlXCIpO1xuICAgIHRoaXMuZXJyb3IgPSBwYXJhbXMuZ2V0KFwiZXJyb3JcIik7XG4gICAgdGhpcy5lcnJvcl9kZXNjcmlwdGlvbiA9IHBhcmFtcy5nZXQoXCJlcnJvcl9kZXNjcmlwdGlvblwiKTtcbiAgICB0aGlzLmVycm9yX3VyaSA9IHBhcmFtcy5nZXQoXCJlcnJvcl91cmlcIik7XG4gIH1cbn07XG5cbi8vIHNyYy9DbGFpbXNTZXJ2aWNlLnRzXG52YXIgRGVmYXVsdFByb3RvY29sQ2xhaW1zID0gW1xuICBcIm5iZlwiLFxuICBcImp0aVwiLFxuICBcImF1dGhfdGltZVwiLFxuICBcIm5vbmNlXCIsXG4gIFwiYWNyXCIsXG4gIFwiYW1yXCIsXG4gIFwiYXpwXCIsXG4gIFwiYXRfaGFzaFwiXG4gIC8vIGh0dHBzOi8vb3BlbmlkLm5ldC9zcGVjcy9vcGVuaWQtY29ubmVjdC1jb3JlLTFfMC5odG1sI0NvZGVJRFRva2VuXG5dO1xudmFyIEludGVybmFsUmVxdWlyZWRQcm90b2NvbENsYWltcyA9IFtcInN1YlwiLCBcImlzc1wiLCBcImF1ZFwiLCBcImV4cFwiLCBcImlhdFwiXTtcbnZhciBDbGFpbXNTZXJ2aWNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihfc2V0dGluZ3MpIHtcbiAgICB0aGlzLl9zZXR0aW5ncyA9IF9zZXR0aW5ncztcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiQ2xhaW1zU2VydmljZVwiKTtcbiAgfVxuICBmaWx0ZXJQcm90b2NvbENsYWltcyhjbGFpbXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7IC4uLmNsYWltcyB9O1xuICAgIGlmICh0aGlzLl9zZXR0aW5ncy5maWx0ZXJQcm90b2NvbENsYWltcykge1xuICAgICAgbGV0IHByb3RvY29sQ2xhaW1zO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5fc2V0dGluZ3MuZmlsdGVyUHJvdG9jb2xDbGFpbXMpKSB7XG4gICAgICAgIHByb3RvY29sQ2xhaW1zID0gdGhpcy5fc2V0dGluZ3MuZmlsdGVyUHJvdG9jb2xDbGFpbXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm90b2NvbENsYWltcyA9IERlZmF1bHRQcm90b2NvbENsYWltcztcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgY2xhaW0gb2YgcHJvdG9jb2xDbGFpbXMpIHtcbiAgICAgICAgaWYgKCFJbnRlcm5hbFJlcXVpcmVkUHJvdG9jb2xDbGFpbXMuaW5jbHVkZXMoY2xhaW0pKSB7XG4gICAgICAgICAgZGVsZXRlIHJlc3VsdFtjbGFpbV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBtZXJnZUNsYWltcyhjbGFpbXMxLCBjbGFpbXMyKSB7XG4gICAgY29uc3QgcmVzdWx0ID0geyAuLi5jbGFpbXMxIH07XG4gICAgZm9yIChjb25zdCBbY2xhaW0sIHZhbHVlc10gb2YgT2JqZWN0LmVudHJpZXMoY2xhaW1zMikpIHtcbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgQXJyYXkuaXNBcnJheSh2YWx1ZXMpID8gdmFsdWVzIDogW3ZhbHVlc10pIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IHJlc3VsdFtjbGFpbV07XG4gICAgICAgIGlmIChwcmV2aW91c1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICByZXN1bHRbY2xhaW1dID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwcmV2aW91c1ZhbHVlKSkge1xuICAgICAgICAgIGlmICghcHJldmlvdXNWYWx1ZS5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHByZXZpb3VzVmFsdWUucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdFtjbGFpbV0gIT09IHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB0aGlzLl9zZXR0aW5ncy5tZXJnZUNsYWltcykge1xuICAgICAgICAgICAgcmVzdWx0W2NsYWltXSA9IHRoaXMubWVyZ2VDbGFpbXMocHJldmlvdXNWYWx1ZSwgdmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRbY2xhaW1dID0gW3ByZXZpb3VzVmFsdWUsIHZhbHVlXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxuLy8gc3JjL09pZGNDbGllbnQudHNcbnZhciBPaWRjQ2xpZW50ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncywgbWV0YWRhdGFTZXJ2aWNlKSB7XG4gICAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIk9pZGNDbGllbnRcIik7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzIGluc3RhbmNlb2YgT2lkY0NsaWVudFNldHRpbmdzU3RvcmUgPyBzZXR0aW5ncyA6IG5ldyBPaWRjQ2xpZW50U2V0dGluZ3NTdG9yZShzZXR0aW5ncyk7XG4gICAgdGhpcy5tZXRhZGF0YVNlcnZpY2UgPSBtZXRhZGF0YVNlcnZpY2UgIT0gbnVsbCA/IG1ldGFkYXRhU2VydmljZSA6IG5ldyBNZXRhZGF0YVNlcnZpY2UodGhpcy5zZXR0aW5ncyk7XG4gICAgdGhpcy5fY2xhaW1zU2VydmljZSA9IG5ldyBDbGFpbXNTZXJ2aWNlKHRoaXMuc2V0dGluZ3MpO1xuICAgIHRoaXMuX3ZhbGlkYXRvciA9IG5ldyBSZXNwb25zZVZhbGlkYXRvcih0aGlzLnNldHRpbmdzLCB0aGlzLm1ldGFkYXRhU2VydmljZSwgdGhpcy5fY2xhaW1zU2VydmljZSk7XG4gICAgdGhpcy5fdG9rZW5DbGllbnQgPSBuZXcgVG9rZW5DbGllbnQodGhpcy5zZXR0aW5ncywgdGhpcy5tZXRhZGF0YVNlcnZpY2UpO1xuICB9XG4gIGFzeW5jIGNyZWF0ZVNpZ25pblJlcXVlc3Qoe1xuICAgIHN0YXRlLFxuICAgIHJlcXVlc3QsXG4gICAgcmVxdWVzdF91cmksXG4gICAgcmVxdWVzdF90eXBlLFxuICAgIGlkX3Rva2VuX2hpbnQsXG4gICAgbG9naW5faGludCxcbiAgICBza2lwVXNlckluZm8sXG4gICAgbm9uY2UsXG4gICAgdXJsX3N0YXRlLFxuICAgIHJlc3BvbnNlX3R5cGUgPSB0aGlzLnNldHRpbmdzLnJlc3BvbnNlX3R5cGUsXG4gICAgc2NvcGUgPSB0aGlzLnNldHRpbmdzLnNjb3BlLFxuICAgIHJlZGlyZWN0X3VyaSA9IHRoaXMuc2V0dGluZ3MucmVkaXJlY3RfdXJpLFxuICAgIHByb21wdCA9IHRoaXMuc2V0dGluZ3MucHJvbXB0LFxuICAgIGRpc3BsYXkgPSB0aGlzLnNldHRpbmdzLmRpc3BsYXksXG4gICAgbWF4X2FnZSA9IHRoaXMuc2V0dGluZ3MubWF4X2FnZSxcbiAgICB1aV9sb2NhbGVzID0gdGhpcy5zZXR0aW5ncy51aV9sb2NhbGVzLFxuICAgIGFjcl92YWx1ZXMgPSB0aGlzLnNldHRpbmdzLmFjcl92YWx1ZXMsXG4gICAgcmVzb3VyY2UgPSB0aGlzLnNldHRpbmdzLnJlc291cmNlLFxuICAgIHJlc3BvbnNlX21vZGUgPSB0aGlzLnNldHRpbmdzLnJlc3BvbnNlX21vZGUsXG4gICAgZXh0cmFRdWVyeVBhcmFtcyA9IHRoaXMuc2V0dGluZ3MuZXh0cmFRdWVyeVBhcmFtcyxcbiAgICBleHRyYVRva2VuUGFyYW1zID0gdGhpcy5zZXR0aW5ncy5leHRyYVRva2VuUGFyYW1zXG4gIH0pIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcImNyZWF0ZVNpZ25pblJlcXVlc3RcIik7XG4gICAgaWYgKHJlc3BvbnNlX3R5cGUgIT09IFwiY29kZVwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IHRoZSBBdXRob3JpemF0aW9uIENvZGUgZmxvdyAod2l0aCBQS0NFKSBpcyBzdXBwb3J0ZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IGF3YWl0IHRoaXMubWV0YWRhdGFTZXJ2aWNlLmdldEF1dGhvcml6YXRpb25FbmRwb2ludCgpO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJSZWNlaXZlZCBhdXRob3JpemF0aW9uIGVuZHBvaW50XCIsIHVybCk7XG4gICAgY29uc3Qgc2lnbmluUmVxdWVzdCA9IG5ldyBTaWduaW5SZXF1ZXN0KHtcbiAgICAgIHVybCxcbiAgICAgIGF1dGhvcml0eTogdGhpcy5zZXR0aW5ncy5hdXRob3JpdHksXG4gICAgICBjbGllbnRfaWQ6IHRoaXMuc2V0dGluZ3MuY2xpZW50X2lkLFxuICAgICAgcmVkaXJlY3RfdXJpLFxuICAgICAgcmVzcG9uc2VfdHlwZSxcbiAgICAgIHNjb3BlLFxuICAgICAgc3RhdGVfZGF0YTogc3RhdGUsXG4gICAgICB1cmxfc3RhdGUsXG4gICAgICBwcm9tcHQsXG4gICAgICBkaXNwbGF5LFxuICAgICAgbWF4X2FnZSxcbiAgICAgIHVpX2xvY2FsZXMsXG4gICAgICBpZF90b2tlbl9oaW50LFxuICAgICAgbG9naW5faGludCxcbiAgICAgIGFjcl92YWx1ZXMsXG4gICAgICByZXNvdXJjZSxcbiAgICAgIHJlcXVlc3QsXG4gICAgICByZXF1ZXN0X3VyaSxcbiAgICAgIGV4dHJhUXVlcnlQYXJhbXMsXG4gICAgICBleHRyYVRva2VuUGFyYW1zLFxuICAgICAgcmVxdWVzdF90eXBlLFxuICAgICAgcmVzcG9uc2VfbW9kZSxcbiAgICAgIGNsaWVudF9zZWNyZXQ6IHRoaXMuc2V0dGluZ3MuY2xpZW50X3NlY3JldCxcbiAgICAgIHNraXBVc2VySW5mbyxcbiAgICAgIG5vbmNlLFxuICAgICAgZGlzYWJsZVBLQ0U6IHRoaXMuc2V0dGluZ3MuZGlzYWJsZVBLQ0VcbiAgICB9KTtcbiAgICBhd2FpdCB0aGlzLmNsZWFyU3RhbGVTdGF0ZSgpO1xuICAgIGNvbnN0IHNpZ25pblN0YXRlID0gc2lnbmluUmVxdWVzdC5zdGF0ZTtcbiAgICBhd2FpdCB0aGlzLnNldHRpbmdzLnN0YXRlU3RvcmUuc2V0KHNpZ25pblN0YXRlLmlkLCBzaWduaW5TdGF0ZS50b1N0b3JhZ2VTdHJpbmcoKSk7XG4gICAgcmV0dXJuIHNpZ25pblJlcXVlc3Q7XG4gIH1cbiAgYXN5bmMgcmVhZFNpZ25pblJlc3BvbnNlU3RhdGUodXJsLCByZW1vdmVTdGF0ZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJyZWFkU2lnbmluUmVzcG9uc2VTdGF0ZVwiKTtcbiAgICBjb25zdCByZXNwb25zZSA9IG5ldyBTaWduaW5SZXNwb25zZShVcmxVdGlscy5yZWFkUGFyYW1zKHVybCwgdGhpcy5zZXR0aW5ncy5yZXNwb25zZV9tb2RlKSk7XG4gICAgaWYgKCFyZXNwb25zZS5zdGF0ZSkge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJObyBzdGF0ZSBpbiByZXNwb25zZVwiKSk7XG4gICAgICB0aHJvdyBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzdG9yZWRTdGF0ZVN0cmluZyA9IGF3YWl0IHRoaXMuc2V0dGluZ3Muc3RhdGVTdG9yZVtyZW1vdmVTdGF0ZSA/IFwicmVtb3ZlXCIgOiBcImdldFwiXShyZXNwb25zZS5zdGF0ZSk7XG4gICAgaWYgKCFzdG9yZWRTdGF0ZVN0cmluZykge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJObyBtYXRjaGluZyBzdGF0ZSBmb3VuZCBpbiBzdG9yYWdlXCIpKTtcbiAgICAgIHRocm93IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0gU2lnbmluU3RhdGUuZnJvbVN0b3JhZ2VTdHJpbmcoc3RvcmVkU3RhdGVTdHJpbmcpO1xuICAgIHJldHVybiB7IHN0YXRlLCByZXNwb25zZSB9O1xuICB9XG4gIGFzeW5jIHByb2Nlc3NTaWduaW5SZXNwb25zZSh1cmwpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInByb2Nlc3NTaWduaW5SZXNwb25zZVwiKTtcbiAgICBjb25zdCB7IHN0YXRlLCByZXNwb25zZSB9ID0gYXdhaXQgdGhpcy5yZWFkU2lnbmluUmVzcG9uc2VTdGF0ZSh1cmwsIHRydWUpO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJyZWNlaXZlZCBzdGF0ZSBmcm9tIHN0b3JhZ2U7IHZhbGlkYXRpbmcgcmVzcG9uc2VcIik7XG4gICAgYXdhaXQgdGhpcy5fdmFsaWRhdG9yLnZhbGlkYXRlU2lnbmluUmVzcG9uc2UocmVzcG9uc2UsIHN0YXRlKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc1Jlc291cmNlT3duZXJQYXNzd29yZENyZWRlbnRpYWxzKHtcbiAgICB1c2VybmFtZSxcbiAgICBwYXNzd29yZCxcbiAgICBza2lwVXNlckluZm8gPSBmYWxzZSxcbiAgICBleHRyYVRva2VuUGFyYW1zID0ge31cbiAgfSkge1xuICAgIGNvbnN0IHRva2VuUmVzcG9uc2UgPSBhd2FpdCB0aGlzLl90b2tlbkNsaWVudC5leGNoYW5nZUNyZWRlbnRpYWxzKHsgdXNlcm5hbWUsIHBhc3N3b3JkLCAuLi5leHRyYVRva2VuUGFyYW1zIH0pO1xuICAgIGNvbnN0IHNpZ25pblJlc3BvbnNlID0gbmV3IFNpZ25pblJlc3BvbnNlKG5ldyBVUkxTZWFyY2hQYXJhbXMoKSk7XG4gICAgT2JqZWN0LmFzc2lnbihzaWduaW5SZXNwb25zZSwgdG9rZW5SZXNwb25zZSk7XG4gICAgYXdhaXQgdGhpcy5fdmFsaWRhdG9yLnZhbGlkYXRlQ3JlZGVudGlhbHNSZXNwb25zZShzaWduaW5SZXNwb25zZSwgc2tpcFVzZXJJbmZvKTtcbiAgICByZXR1cm4gc2lnbmluUmVzcG9uc2U7XG4gIH1cbiAgYXN5bmMgdXNlUmVmcmVzaFRva2VuKHtcbiAgICBzdGF0ZSxcbiAgICB0aW1lb3V0SW5TZWNvbmRzXG4gIH0pIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJ1c2VSZWZyZXNoVG9rZW5cIik7XG4gICAgbGV0IHNjb3BlO1xuICAgIGlmICh0aGlzLnNldHRpbmdzLnJlZnJlc2hUb2tlbkFsbG93ZWRTY29wZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzY29wZSA9IHN0YXRlLnNjb3BlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBhbGxvd2FibGVTY29wZXMgPSB0aGlzLnNldHRpbmdzLnJlZnJlc2hUb2tlbkFsbG93ZWRTY29wZS5zcGxpdChcIiBcIik7XG4gICAgICBjb25zdCBwcm92aWRlZFNjb3BlcyA9ICgoX2EgPSBzdGF0ZS5zY29wZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNwbGl0KFwiIFwiKSkgfHwgW107XG4gICAgICBzY29wZSA9IHByb3ZpZGVkU2NvcGVzLmZpbHRlcigocykgPT4gYWxsb3dhYmxlU2NvcGVzLmluY2x1ZGVzKHMpKS5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fdG9rZW5DbGllbnQuZXhjaGFuZ2VSZWZyZXNoVG9rZW4oe1xuICAgICAgcmVmcmVzaF90b2tlbjogc3RhdGUucmVmcmVzaF90b2tlbixcbiAgICAgIHJlc291cmNlOiBzdGF0ZS5yZXNvdXJjZSxcbiAgICAgIC8vIHByb3ZpZGUgdGhlIChwb3NzaWJsZSBmaWx0ZXJlZCkgc2NvcGUgbGlzdFxuICAgICAgc2NvcGUsXG4gICAgICB0aW1lb3V0SW5TZWNvbmRzXG4gICAgfSk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBuZXcgU2lnbmluUmVzcG9uc2UobmV3IFVSTFNlYXJjaFBhcmFtcygpKTtcbiAgICBPYmplY3QuYXNzaWduKHJlc3BvbnNlLCByZXN1bHQpO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJ2YWxpZGF0aW5nIHJlc3BvbnNlXCIsIHJlc3BvbnNlKTtcbiAgICBhd2FpdCB0aGlzLl92YWxpZGF0b3IudmFsaWRhdGVSZWZyZXNoUmVzcG9uc2UocmVzcG9uc2UsIHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgLy8gb3ZlcmlkZSB0aGUgc2NvcGUgaW4gdGhlIHN0YXRlIGhhbmRlZCBvdmVyIHRvIHRoZSB2YWxpZGF0b3JcbiAgICAgIC8vIHNvIGl0IGNhbiBzZXQgdGhlIGdyYW50ZWQgc2NvcGUgdG8gdGhlIHJlcXVlc3RlZCBzY29wZSBpbiBjYXNlIG5vbmUgaXMgaW5jbHVkZWQgaW4gdGhlIHJlc3BvbnNlXG4gICAgICBzY29wZVxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICBhc3luYyBjcmVhdGVTaWdub3V0UmVxdWVzdCh7XG4gICAgc3RhdGUsXG4gICAgaWRfdG9rZW5faGludCxcbiAgICBjbGllbnRfaWQsXG4gICAgcmVxdWVzdF90eXBlLFxuICAgIHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSA9IHRoaXMuc2V0dGluZ3MucG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpLFxuICAgIGV4dHJhUXVlcnlQYXJhbXMgPSB0aGlzLnNldHRpbmdzLmV4dHJhUXVlcnlQYXJhbXNcbiAgfSA9IHt9KSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJjcmVhdGVTaWdub3V0UmVxdWVzdFwiKTtcbiAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLm1ldGFkYXRhU2VydmljZS5nZXRFbmRTZXNzaW9uRW5kcG9pbnQoKTtcbiAgICBpZiAoIXVybCkge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJObyBlbmQgc2Vzc2lvbiBlbmRwb2ludFwiKSk7XG4gICAgICB0aHJvdyBudWxsO1xuICAgIH1cbiAgICBsb2dnZXIyLmRlYnVnKFwiUmVjZWl2ZWQgZW5kIHNlc3Npb24gZW5kcG9pbnRcIiwgdXJsKTtcbiAgICBpZiAoIWNsaWVudF9pZCAmJiBwb3N0X2xvZ291dF9yZWRpcmVjdF91cmkgJiYgIWlkX3Rva2VuX2hpbnQpIHtcbiAgICAgIGNsaWVudF9pZCA9IHRoaXMuc2V0dGluZ3MuY2xpZW50X2lkO1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFNpZ25vdXRSZXF1ZXN0KHtcbiAgICAgIHVybCxcbiAgICAgIGlkX3Rva2VuX2hpbnQsXG4gICAgICBjbGllbnRfaWQsXG4gICAgICBwb3N0X2xvZ291dF9yZWRpcmVjdF91cmksXG4gICAgICBzdGF0ZV9kYXRhOiBzdGF0ZSxcbiAgICAgIGV4dHJhUXVlcnlQYXJhbXMsXG4gICAgICByZXF1ZXN0X3R5cGVcbiAgICB9KTtcbiAgICBhd2FpdCB0aGlzLmNsZWFyU3RhbGVTdGF0ZSgpO1xuICAgIGNvbnN0IHNpZ25vdXRTdGF0ZSA9IHJlcXVlc3Quc3RhdGU7XG4gICAgaWYgKHNpZ25vdXRTdGF0ZSkge1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcIlNpZ25vdXQgcmVxdWVzdCBoYXMgc3RhdGUgdG8gcGVyc2lzdFwiKTtcbiAgICAgIGF3YWl0IHRoaXMuc2V0dGluZ3Muc3RhdGVTdG9yZS5zZXQoc2lnbm91dFN0YXRlLmlkLCBzaWdub3V0U3RhdGUudG9TdG9yYWdlU3RyaW5nKCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfVxuICBhc3luYyByZWFkU2lnbm91dFJlc3BvbnNlU3RhdGUodXJsLCByZW1vdmVTdGF0ZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJyZWFkU2lnbm91dFJlc3BvbnNlU3RhdGVcIik7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBuZXcgU2lnbm91dFJlc3BvbnNlKFVybFV0aWxzLnJlYWRQYXJhbXModXJsLCB0aGlzLnNldHRpbmdzLnJlc3BvbnNlX21vZGUpKTtcbiAgICBpZiAoIXJlc3BvbnNlLnN0YXRlKSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwiTm8gc3RhdGUgaW4gcmVzcG9uc2VcIik7XG4gICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyMi53YXJuKFwiUmVzcG9uc2Ugd2FzIGVycm9yOlwiLCByZXNwb25zZS5lcnJvcik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvclJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHN0YXRlOiB2b2lkIDAsIHJlc3BvbnNlIH07XG4gICAgfVxuICAgIGNvbnN0IHN0b3JlZFN0YXRlU3RyaW5nID0gYXdhaXQgdGhpcy5zZXR0aW5ncy5zdGF0ZVN0b3JlW3JlbW92ZVN0YXRlID8gXCJyZW1vdmVcIiA6IFwiZ2V0XCJdKHJlc3BvbnNlLnN0YXRlKTtcbiAgICBpZiAoIXN0b3JlZFN0YXRlU3RyaW5nKSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIk5vIG1hdGNoaW5nIHN0YXRlIGZvdW5kIGluIHN0b3JhZ2VcIikpO1xuICAgICAgdGhyb3cgbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc3RhdGUgPSBTdGF0ZS5mcm9tU3RvcmFnZVN0cmluZyhzdG9yZWRTdGF0ZVN0cmluZyk7XG4gICAgcmV0dXJuIHsgc3RhdGUsIHJlc3BvbnNlIH07XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc1NpZ25vdXRSZXNwb25zZSh1cmwpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInByb2Nlc3NTaWdub3V0UmVzcG9uc2VcIik7XG4gICAgY29uc3QgeyBzdGF0ZSwgcmVzcG9uc2UgfSA9IGF3YWl0IHRoaXMucmVhZFNpZ25vdXRSZXNwb25zZVN0YXRlKHVybCwgdHJ1ZSk7XG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwiUmVjZWl2ZWQgc3RhdGUgZnJvbSBzdG9yYWdlOyB2YWxpZGF0aW5nIHJlc3BvbnNlXCIpO1xuICAgICAgdGhpcy5fdmFsaWRhdG9yLnZhbGlkYXRlU2lnbm91dFJlc3BvbnNlKHJlc3BvbnNlLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJObyBzdGF0ZSBmcm9tIHN0b3JhZ2U7IHNraXBwaW5nIHJlc3BvbnNlIHZhbGlkYXRpb25cIik7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICBjbGVhclN0YWxlU3RhdGUoKSB7XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShcImNsZWFyU3RhbGVTdGF0ZVwiKTtcbiAgICByZXR1cm4gU3RhdGUuY2xlYXJTdGFsZVN0YXRlKHRoaXMuc2V0dGluZ3Muc3RhdGVTdG9yZSwgdGhpcy5zZXR0aW5ncy5zdGFsZVN0YXRlQWdlSW5TZWNvbmRzKTtcbiAgfVxuICBhc3luYyByZXZva2VUb2tlbih0b2tlbiwgdHlwZSkge1xuICAgIHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJyZXZva2VUb2tlblwiKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fdG9rZW5DbGllbnQucmV2b2tlKHtcbiAgICAgIHRva2VuLFxuICAgICAgdG9rZW5fdHlwZV9oaW50OiB0eXBlXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9TZXNzaW9uTW9uaXRvci50c1xudmFyIFNlc3Npb25Nb25pdG9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihfdXNlck1hbmFnZXIpIHtcbiAgICB0aGlzLl91c2VyTWFuYWdlciA9IF91c2VyTWFuYWdlcjtcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiU2Vzc2lvbk1vbml0b3JcIik7XG4gICAgdGhpcy5fc3RhcnQgPSBhc3luYyAodXNlcikgPT4ge1xuICAgICAgY29uc3Qgc2Vzc2lvbl9zdGF0ZSA9IHVzZXIuc2Vzc2lvbl9zdGF0ZTtcbiAgICAgIGlmICghc2Vzc2lvbl9zdGF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIl9zdGFydFwiKTtcbiAgICAgIGlmICh1c2VyLnByb2ZpbGUpIHtcbiAgICAgICAgdGhpcy5fc3ViID0gdXNlci5wcm9maWxlLnN1YjtcbiAgICAgICAgdGhpcy5fc2lkID0gdXNlci5wcm9maWxlLnNpZDtcbiAgICAgICAgbG9nZ2VyMi5kZWJ1ZyhcInNlc3Npb25fc3RhdGVcIiwgc2Vzc2lvbl9zdGF0ZSwgXCIsIHN1YlwiLCB0aGlzLl9zdWIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc3ViID0gdm9pZCAwO1xuICAgICAgICB0aGlzLl9zaWQgPSB2b2lkIDA7XG4gICAgICAgIGxvZ2dlcjIuZGVidWcoXCJzZXNzaW9uX3N0YXRlXCIsIHNlc3Npb25fc3RhdGUsIFwiLCBhbm9ueW1vdXMgdXNlclwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9jaGVja1Nlc3Npb25JRnJhbWUpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tTZXNzaW9uSUZyYW1lLnN0YXJ0KHNlc3Npb25fc3RhdGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLl91c2VyTWFuYWdlci5tZXRhZGF0YVNlcnZpY2UuZ2V0Q2hlY2tTZXNzaW9uSWZyYW1lKCk7XG4gICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICBsb2dnZXIyLmRlYnVnKFwiaW5pdGlhbGl6aW5nIGNoZWNrIHNlc3Npb24gaWZyYW1lXCIpO1xuICAgICAgICAgIGNvbnN0IGNsaWVudF9pZCA9IHRoaXMuX3VzZXJNYW5hZ2VyLnNldHRpbmdzLmNsaWVudF9pZDtcbiAgICAgICAgICBjb25zdCBpbnRlcnZhbEluU2Vjb25kcyA9IHRoaXMuX3VzZXJNYW5hZ2VyLnNldHRpbmdzLmNoZWNrU2Vzc2lvbkludGVydmFsSW5TZWNvbmRzO1xuICAgICAgICAgIGNvbnN0IHN0b3BPbkVycm9yID0gdGhpcy5fdXNlck1hbmFnZXIuc2V0dGluZ3Muc3RvcENoZWNrU2Vzc2lvbk9uRXJyb3I7XG4gICAgICAgICAgY29uc3QgY2hlY2tTZXNzaW9uSUZyYW1lID0gbmV3IENoZWNrU2Vzc2lvbklGcmFtZSh0aGlzLl9jYWxsYmFjaywgY2xpZW50X2lkLCB1cmwsIGludGVydmFsSW5TZWNvbmRzLCBzdG9wT25FcnJvcik7XG4gICAgICAgICAgYXdhaXQgY2hlY2tTZXNzaW9uSUZyYW1lLmxvYWQoKTtcbiAgICAgICAgICB0aGlzLl9jaGVja1Nlc3Npb25JRnJhbWUgPSBjaGVja1Nlc3Npb25JRnJhbWU7XG4gICAgICAgICAgY2hlY2tTZXNzaW9uSUZyYW1lLnN0YXJ0KHNlc3Npb25fc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlcjIud2FybihcIm5vIGNoZWNrIHNlc3Npb24gaWZyYW1lIGZvdW5kIGluIHRoZSBtZXRhZGF0YVwiKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ2dlcjIuZXJyb3IoXCJFcnJvciBmcm9tIGdldENoZWNrU2Vzc2lvbklmcmFtZTpcIiwgZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IGVycik7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9zdG9wID0gKCkgPT4ge1xuICAgICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJfc3RvcFwiKTtcbiAgICAgIHRoaXMuX3N1YiA9IHZvaWQgMDtcbiAgICAgIHRoaXMuX3NpZCA9IHZvaWQgMDtcbiAgICAgIGlmICh0aGlzLl9jaGVja1Nlc3Npb25JRnJhbWUpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tTZXNzaW9uSUZyYW1lLnN0b3AoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl91c2VyTWFuYWdlci5zZXR0aW5ncy5tb25pdG9yQW5vbnltb3VzU2Vzc2lvbikge1xuICAgICAgICBjb25zdCB0aW1lckhhbmRsZSA9IHNldEludGVydmFsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICBjbGVhckludGVydmFsKHRpbWVySGFuZGxlKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IHRoaXMuX3VzZXJNYW5hZ2VyLnF1ZXJ5U2Vzc2lvblN0YXR1cygpO1xuICAgICAgICAgICAgaWYgKHNlc3Npb24pIHtcbiAgICAgICAgICAgICAgY29uc3QgdG1wVXNlciA9IHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uX3N0YXRlOiBzZXNzaW9uLnNlc3Npb25fc3RhdGUsXG4gICAgICAgICAgICAgICAgcHJvZmlsZTogc2Vzc2lvbi5zdWIgJiYgc2Vzc2lvbi5zaWQgPyB7XG4gICAgICAgICAgICAgICAgICBzdWI6IHNlc3Npb24uc3ViLFxuICAgICAgICAgICAgICAgICAgc2lkOiBzZXNzaW9uLnNpZFxuICAgICAgICAgICAgICAgIH0gOiBudWxsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHZvaWQgdGhpcy5fc3RhcnQodG1wVXNlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBsb2dnZXIyLmVycm9yKFwiZXJyb3IgZnJvbSBxdWVyeVNlc3Npb25TdGF0dXNcIiwgZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAxZTMpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fY2FsbGJhY2sgPSBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIl9jYWxsYmFja1wiKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCB0aGlzLl91c2VyTWFuYWdlci5xdWVyeVNlc3Npb25TdGF0dXMoKTtcbiAgICAgICAgbGV0IHJhaXNlRXZlbnQgPSB0cnVlO1xuICAgICAgICBpZiAoc2Vzc2lvbiAmJiB0aGlzLl9jaGVja1Nlc3Npb25JRnJhbWUpIHtcbiAgICAgICAgICBpZiAoc2Vzc2lvbi5zdWIgPT09IHRoaXMuX3N1Yikge1xuICAgICAgICAgICAgcmFpc2VFdmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tTZXNzaW9uSUZyYW1lLnN0YXJ0KHNlc3Npb24uc2Vzc2lvbl9zdGF0ZSk7XG4gICAgICAgICAgICBpZiAoc2Vzc2lvbi5zaWQgPT09IHRoaXMuX3NpZCkge1xuICAgICAgICAgICAgICBsb2dnZXIyLmRlYnVnKFwic2FtZSBzdWIgc3RpbGwgbG9nZ2VkIGluIGF0IE9QLCByZXN0YXJ0aW5nIGNoZWNrIHNlc3Npb24gaWZyYW1lOyBzZXNzaW9uX3N0YXRlXCIsIHNlc3Npb24uc2Vzc2lvbl9zdGF0ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsb2dnZXIyLmRlYnVnKFwic2FtZSBzdWIgc3RpbGwgbG9nZ2VkIGluIGF0IE9QLCBzZXNzaW9uIHN0YXRlIGhhcyBjaGFuZ2VkLCByZXN0YXJ0aW5nIGNoZWNrIHNlc3Npb24gaWZyYW1lOyBzZXNzaW9uX3N0YXRlXCIsIHNlc3Npb24uc2Vzc2lvbl9zdGF0ZSk7XG4gICAgICAgICAgICAgIHRoaXMuX3VzZXJNYW5hZ2VyLmV2ZW50cy5fcmFpc2VVc2VyU2Vzc2lvbkNoYW5nZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyMi5kZWJ1ZyhcImRpZmZlcmVudCBzdWJqZWN0IHNpZ25lZCBpbnRvIE9QXCIsIHNlc3Npb24uc3ViKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyMi5kZWJ1ZyhcInN1YmplY3Qgbm8gbG9uZ2VyIHNpZ25lZCBpbnRvIE9QXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyYWlzZUV2ZW50KSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3N1Yikge1xuICAgICAgICAgICAgdGhpcy5fdXNlck1hbmFnZXIuZXZlbnRzLl9yYWlzZVVzZXJTaWduZWRPdXQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdXNlck1hbmFnZXIuZXZlbnRzLl9yYWlzZVVzZXJTaWduZWRJbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIyLmRlYnVnKFwibm8gY2hhbmdlIGluIHNlc3Npb24gZGV0ZWN0ZWQsIG5vIGV2ZW50IHRvIHJhaXNlXCIpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N1Yikge1xuICAgICAgICAgIGxvZ2dlcjIuZGVidWcoXCJFcnJvciBjYWxsaW5nIHF1ZXJ5Q3VycmVudFNpZ25pblNlc3Npb247IHJhaXNpbmcgc2lnbmVkIG91dCBldmVudFwiLCBlcnIpO1xuICAgICAgICAgIHRoaXMuX3VzZXJNYW5hZ2VyLmV2ZW50cy5fcmFpc2VVc2VyU2lnbmVkT3V0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICghX3VzZXJNYW5hZ2VyKSB7XG4gICAgICB0aGlzLl9sb2dnZXIudGhyb3cobmV3IEVycm9yKFwiTm8gdXNlciBtYW5hZ2VyIHBhc3NlZFwiKSk7XG4gICAgfVxuICAgIHRoaXMuX3VzZXJNYW5hZ2VyLmV2ZW50cy5hZGRVc2VyTG9hZGVkKHRoaXMuX3N0YXJ0KTtcbiAgICB0aGlzLl91c2VyTWFuYWdlci5ldmVudHMuYWRkVXNlclVubG9hZGVkKHRoaXMuX3N0b3ApO1xuICAgIHRoaXMuX2luaXQoKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoZXJyKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBfaW5pdCgpIHtcbiAgICB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiX2luaXRcIik7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMuX3VzZXJNYW5hZ2VyLmdldFVzZXIoKTtcbiAgICBpZiAodXNlcikge1xuICAgICAgdm9pZCB0aGlzLl9zdGFydCh1c2VyKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3VzZXJNYW5hZ2VyLnNldHRpbmdzLm1vbml0b3JBbm9ueW1vdXNTZXNzaW9uKSB7XG4gICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgdGhpcy5fdXNlck1hbmFnZXIucXVlcnlTZXNzaW9uU3RhdHVzKCk7XG4gICAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgICBjb25zdCB0bXBVc2VyID0ge1xuICAgICAgICAgIHNlc3Npb25fc3RhdGU6IHNlc3Npb24uc2Vzc2lvbl9zdGF0ZSxcbiAgICAgICAgICBwcm9maWxlOiBzZXNzaW9uLnN1YiAmJiBzZXNzaW9uLnNpZCA/IHtcbiAgICAgICAgICAgIHN1Yjogc2Vzc2lvbi5zdWIsXG4gICAgICAgICAgICBzaWQ6IHNlc3Npb24uc2lkXG4gICAgICAgICAgfSA6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgdm9pZCB0aGlzLl9zdGFydCh0bXBVc2VyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9Vc2VyLnRzXG52YXIgVXNlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHZhciBfYTtcbiAgICB0aGlzLmlkX3Rva2VuID0gYXJncy5pZF90b2tlbjtcbiAgICB0aGlzLnNlc3Npb25fc3RhdGUgPSAoX2EgPSBhcmdzLnNlc3Npb25fc3RhdGUpICE9IG51bGwgPyBfYSA6IG51bGw7XG4gICAgdGhpcy5hY2Nlc3NfdG9rZW4gPSBhcmdzLmFjY2Vzc190b2tlbjtcbiAgICB0aGlzLnJlZnJlc2hfdG9rZW4gPSBhcmdzLnJlZnJlc2hfdG9rZW47XG4gICAgdGhpcy50b2tlbl90eXBlID0gYXJncy50b2tlbl90eXBlO1xuICAgIHRoaXMuc2NvcGUgPSBhcmdzLnNjb3BlO1xuICAgIHRoaXMucHJvZmlsZSA9IGFyZ3MucHJvZmlsZTtcbiAgICB0aGlzLmV4cGlyZXNfYXQgPSBhcmdzLmV4cGlyZXNfYXQ7XG4gICAgdGhpcy5zdGF0ZSA9IGFyZ3MudXNlclN0YXRlO1xuICAgIHRoaXMudXJsX3N0YXRlID0gYXJncy51cmxfc3RhdGU7XG4gIH1cbiAgLyoqIENvbXB1dGVkIG51bWJlciBvZiBzZWNvbmRzIHRoZSBhY2Nlc3MgdG9rZW4gaGFzIHJlbWFpbmluZy4gKi9cbiAgZ2V0IGV4cGlyZXNfaW4oKSB7XG4gICAgaWYgKHRoaXMuZXhwaXJlc19hdCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5leHBpcmVzX2F0IC0gVGltZXIuZ2V0RXBvY2hUaW1lKCk7XG4gIH1cbiAgc2V0IGV4cGlyZXNfaW4odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5leHBpcmVzX2F0ID0gTWF0aC5mbG9vcih2YWx1ZSkgKyBUaW1lci5nZXRFcG9jaFRpbWUoKTtcbiAgICB9XG4gIH1cbiAgLyoqIENvbXB1dGVkIHZhbHVlIGluZGljYXRpbmcgaWYgdGhlIGFjY2VzcyB0b2tlbiBpcyBleHBpcmVkLiAqL1xuICBnZXQgZXhwaXJlZCgpIHtcbiAgICBjb25zdCBleHBpcmVzX2luID0gdGhpcy5leHBpcmVzX2luO1xuICAgIGlmIChleHBpcmVzX2luID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBleHBpcmVzX2luIDw9IDA7XG4gIH1cbiAgLyoqIEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGFyc2VkIHZhbHVlcyBmcm9tIHRoZSBgc2NvcGVgLiAqL1xuICBnZXQgc2NvcGVzKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuc2NvcGUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zcGxpdChcIiBcIikpICE9IG51bGwgPyBfYiA6IFtdO1xuICB9XG4gIHRvU3RvcmFnZVN0cmluZygpIHtcbiAgICBuZXcgTG9nZ2VyKFwiVXNlclwiKS5jcmVhdGUoXCJ0b1N0b3JhZ2VTdHJpbmdcIik7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIGlkX3Rva2VuOiB0aGlzLmlkX3Rva2VuLFxuICAgICAgc2Vzc2lvbl9zdGF0ZTogdGhpcy5zZXNzaW9uX3N0YXRlLFxuICAgICAgYWNjZXNzX3Rva2VuOiB0aGlzLmFjY2Vzc190b2tlbixcbiAgICAgIHJlZnJlc2hfdG9rZW46IHRoaXMucmVmcmVzaF90b2tlbixcbiAgICAgIHRva2VuX3R5cGU6IHRoaXMudG9rZW5fdHlwZSxcbiAgICAgIHNjb3BlOiB0aGlzLnNjb3BlLFxuICAgICAgcHJvZmlsZTogdGhpcy5wcm9maWxlLFxuICAgICAgZXhwaXJlc19hdDogdGhpcy5leHBpcmVzX2F0XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGZyb21TdG9yYWdlU3RyaW5nKHN0b3JhZ2VTdHJpbmcpIHtcbiAgICBMb2dnZXIuY3JlYXRlU3RhdGljKFwiVXNlclwiLCBcImZyb21TdG9yYWdlU3RyaW5nXCIpO1xuICAgIHJldHVybiBuZXcgVXNlcihKU09OLnBhcnNlKHN0b3JhZ2VTdHJpbmcpKTtcbiAgfVxufTtcblxuLy8gc3JjL25hdmlnYXRvcnMvQWJzdHJhY3RDaGlsZFdpbmRvdy50c1xudmFyIG1lc3NhZ2VTb3VyY2UgPSBcIm9pZGMtY2xpZW50XCI7XG52YXIgQWJzdHJhY3RDaGlsZFdpbmRvdyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fYWJvcnQgPSBuZXcgRXZlbnQoXCJXaW5kb3cgbmF2aWdhdGlvbiBhYm9ydGVkXCIpO1xuICAgIHRoaXMuX2Rpc3Bvc2VIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5fd2luZG93ID0gbnVsbDtcbiAgfVxuICBhc3luYyBuYXZpZ2F0ZShwYXJhbXMpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIm5hdmlnYXRlXCIpO1xuICAgIGlmICghdGhpcy5fd2luZG93KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gbmF2aWdhdGUgb24gYSBkaXNwb3NlZCB3aW5kb3dcIik7XG4gICAgfVxuICAgIGxvZ2dlcjIuZGVidWcoXCJzZXR0aW5nIFVSTCBpbiB3aW5kb3dcIik7XG4gICAgdGhpcy5fd2luZG93LmxvY2F0aW9uLnJlcGxhY2UocGFyYW1zLnVybCk7XG4gICAgY29uc3QgeyB1cmwsIGtlZXBPcGVuIH0gPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBsaXN0ZW5lciA9IChlKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGUuZGF0YTtcbiAgICAgICAgY29uc3Qgb3JpZ2luID0gKF9hID0gcGFyYW1zLnNjcmlwdE9yaWdpbikgIT0gbnVsbCA/IF9hIDogd2luZG93LmxvY2F0aW9uLm9yaWdpbjtcbiAgICAgICAgaWYgKGUub3JpZ2luICE9PSBvcmlnaW4gfHwgKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuc291cmNlKSAhPT0gbWVzc2FnZVNvdXJjZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gVXJsVXRpbHMucmVhZFBhcmFtcyhkYXRhLnVybCwgcGFyYW1zLnJlc3BvbnNlX21vZGUpLmdldChcInN0YXRlXCIpO1xuICAgICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgIGxvZ2dlcjIud2FybihcIm5vIHN0YXRlIGZvdW5kIGluIHJlc3BvbnNlIHVybFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGUuc291cmNlICE9PSB0aGlzLl93aW5kb3cgJiYgc3RhdGUgIT09IHBhcmFtcy5zdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhpcy5fZGlzcG9zZSgpO1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIGZyb20gd2luZG93XCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgfTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgdGhpcy5fZGlzcG9zZUhhbmRsZXJzLmFkZCgoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgbGlzdGVuZXIsIGZhbHNlKSk7XG4gICAgICB0aGlzLl9kaXNwb3NlSGFuZGxlcnMuYWRkKHRoaXMuX2Fib3J0LmFkZEhhbmRsZXIoKHJlYXNvbikgPT4ge1xuICAgICAgICB0aGlzLl9kaXNwb3NlKCk7XG4gICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgfSkpO1xuICAgIH0pO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJnb3QgcmVzcG9uc2UgZnJvbSB3aW5kb3dcIik7XG4gICAgdGhpcy5fZGlzcG9zZSgpO1xuICAgIGlmICgha2VlcE9wZW4pIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdXJsIH07XG4gIH1cbiAgX2Rpc3Bvc2UoKSB7XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIl9kaXNwb3NlXCIpO1xuICAgIGZvciAoY29uc3QgZGlzcG9zZSBvZiB0aGlzLl9kaXNwb3NlSGFuZGxlcnMpIHtcbiAgICAgIGRpc3Bvc2UoKTtcbiAgICB9XG4gICAgdGhpcy5fZGlzcG9zZUhhbmRsZXJzLmNsZWFyKCk7XG4gIH1cbiAgc3RhdGljIF9ub3RpZnlQYXJlbnQocGFyZW50LCB1cmwsIGtlZXBPcGVuID0gZmFsc2UsIHRhcmdldE9yaWdpbiA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pIHtcbiAgICBwYXJlbnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgc291cmNlOiBtZXNzYWdlU291cmNlLFxuICAgICAgdXJsLFxuICAgICAga2VlcE9wZW5cbiAgICB9LCB0YXJnZXRPcmlnaW4pO1xuICB9XG59O1xuXG4vLyBzcmMvVXNlck1hbmFnZXJTZXR0aW5ncy50c1xudmFyIERlZmF1bHRQb3B1cFdpbmRvd0ZlYXR1cmVzID0ge1xuICBsb2NhdGlvbjogZmFsc2UsXG4gIHRvb2xiYXI6IGZhbHNlLFxuICBoZWlnaHQ6IDY0MCxcbiAgY2xvc2VQb3B1cFdpbmRvd0FmdGVySW5TZWNvbmRzOiAtMVxufTtcbnZhciBEZWZhdWx0UG9wdXBUYXJnZXQgPSBcIl9ibGFua1wiO1xudmFyIERlZmF1bHRBY2Nlc3NUb2tlbkV4cGlyaW5nTm90aWZpY2F0aW9uVGltZUluU2Vjb25kcyA9IDYwO1xudmFyIERlZmF1bHRDaGVja1Nlc3Npb25JbnRlcnZhbEluU2Vjb25kcyA9IDI7XG52YXIgRGVmYXVsdFNpbGVudFJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzID0gMTA7XG52YXIgVXNlck1hbmFnZXJTZXR0aW5nc1N0b3JlID0gY2xhc3MgZXh0ZW5kcyBPaWRjQ2xpZW50U2V0dGluZ3NTdG9yZSB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICBjb25zdCB7XG4gICAgICBwb3B1cF9yZWRpcmVjdF91cmkgPSBhcmdzLnJlZGlyZWN0X3VyaSxcbiAgICAgIHBvcHVwX3Bvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSA9IGFyZ3MucG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpLFxuICAgICAgcG9wdXBXaW5kb3dGZWF0dXJlcyA9IERlZmF1bHRQb3B1cFdpbmRvd0ZlYXR1cmVzLFxuICAgICAgcG9wdXBXaW5kb3dUYXJnZXQgPSBEZWZhdWx0UG9wdXBUYXJnZXQsXG4gICAgICByZWRpcmVjdE1ldGhvZCA9IFwiYXNzaWduXCIsXG4gICAgICByZWRpcmVjdFRhcmdldCA9IFwic2VsZlwiLFxuICAgICAgaWZyYW1lTm90aWZ5UGFyZW50T3JpZ2luID0gYXJncy5pZnJhbWVOb3RpZnlQYXJlbnRPcmlnaW4sXG4gICAgICBpZnJhbWVTY3JpcHRPcmlnaW4gPSBhcmdzLmlmcmFtZVNjcmlwdE9yaWdpbixcbiAgICAgIHNpbGVudF9yZWRpcmVjdF91cmkgPSBhcmdzLnJlZGlyZWN0X3VyaSxcbiAgICAgIHNpbGVudFJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzID0gRGVmYXVsdFNpbGVudFJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzLFxuICAgICAgYXV0b21hdGljU2lsZW50UmVuZXcgPSB0cnVlLFxuICAgICAgdmFsaWRhdGVTdWJPblNpbGVudFJlbmV3ID0gdHJ1ZSxcbiAgICAgIGluY2x1ZGVJZFRva2VuSW5TaWxlbnRSZW5ldyA9IGZhbHNlLFxuICAgICAgbW9uaXRvclNlc3Npb24gPSBmYWxzZSxcbiAgICAgIG1vbml0b3JBbm9ueW1vdXNTZXNzaW9uID0gZmFsc2UsXG4gICAgICBjaGVja1Nlc3Npb25JbnRlcnZhbEluU2Vjb25kcyA9IERlZmF1bHRDaGVja1Nlc3Npb25JbnRlcnZhbEluU2Vjb25kcyxcbiAgICAgIHF1ZXJ5X3N0YXR1c19yZXNwb25zZV90eXBlID0gXCJjb2RlXCIsXG4gICAgICBzdG9wQ2hlY2tTZXNzaW9uT25FcnJvciA9IHRydWUsXG4gICAgICByZXZva2VUb2tlblR5cGVzID0gW1wiYWNjZXNzX3Rva2VuXCIsIFwicmVmcmVzaF90b2tlblwiXSxcbiAgICAgIHJldm9rZVRva2Vuc09uU2lnbm91dCA9IGZhbHNlLFxuICAgICAgaW5jbHVkZUlkVG9rZW5JblNpbGVudFNpZ25vdXQgPSBmYWxzZSxcbiAgICAgIGFjY2Vzc1Rva2VuRXhwaXJpbmdOb3RpZmljYXRpb25UaW1lSW5TZWNvbmRzID0gRGVmYXVsdEFjY2Vzc1Rva2VuRXhwaXJpbmdOb3RpZmljYXRpb25UaW1lSW5TZWNvbmRzLFxuICAgICAgdXNlclN0b3JlXG4gICAgfSA9IGFyZ3M7XG4gICAgc3VwZXIoYXJncyk7XG4gICAgdGhpcy5wb3B1cF9yZWRpcmVjdF91cmkgPSBwb3B1cF9yZWRpcmVjdF91cmk7XG4gICAgdGhpcy5wb3B1cF9wb3N0X2xvZ291dF9yZWRpcmVjdF91cmkgPSBwb3B1cF9wb3N0X2xvZ291dF9yZWRpcmVjdF91cmk7XG4gICAgdGhpcy5wb3B1cFdpbmRvd0ZlYXR1cmVzID0gcG9wdXBXaW5kb3dGZWF0dXJlcztcbiAgICB0aGlzLnBvcHVwV2luZG93VGFyZ2V0ID0gcG9wdXBXaW5kb3dUYXJnZXQ7XG4gICAgdGhpcy5yZWRpcmVjdE1ldGhvZCA9IHJlZGlyZWN0TWV0aG9kO1xuICAgIHRoaXMucmVkaXJlY3RUYXJnZXQgPSByZWRpcmVjdFRhcmdldDtcbiAgICB0aGlzLmlmcmFtZU5vdGlmeVBhcmVudE9yaWdpbiA9IGlmcmFtZU5vdGlmeVBhcmVudE9yaWdpbjtcbiAgICB0aGlzLmlmcmFtZVNjcmlwdE9yaWdpbiA9IGlmcmFtZVNjcmlwdE9yaWdpbjtcbiAgICB0aGlzLnNpbGVudF9yZWRpcmVjdF91cmkgPSBzaWxlbnRfcmVkaXJlY3RfdXJpO1xuICAgIHRoaXMuc2lsZW50UmVxdWVzdFRpbWVvdXRJblNlY29uZHMgPSBzaWxlbnRSZXF1ZXN0VGltZW91dEluU2Vjb25kcztcbiAgICB0aGlzLmF1dG9tYXRpY1NpbGVudFJlbmV3ID0gYXV0b21hdGljU2lsZW50UmVuZXc7XG4gICAgdGhpcy52YWxpZGF0ZVN1Yk9uU2lsZW50UmVuZXcgPSB2YWxpZGF0ZVN1Yk9uU2lsZW50UmVuZXc7XG4gICAgdGhpcy5pbmNsdWRlSWRUb2tlbkluU2lsZW50UmVuZXcgPSBpbmNsdWRlSWRUb2tlbkluU2lsZW50UmVuZXc7XG4gICAgdGhpcy5tb25pdG9yU2Vzc2lvbiA9IG1vbml0b3JTZXNzaW9uO1xuICAgIHRoaXMubW9uaXRvckFub255bW91c1Nlc3Npb24gPSBtb25pdG9yQW5vbnltb3VzU2Vzc2lvbjtcbiAgICB0aGlzLmNoZWNrU2Vzc2lvbkludGVydmFsSW5TZWNvbmRzID0gY2hlY2tTZXNzaW9uSW50ZXJ2YWxJblNlY29uZHM7XG4gICAgdGhpcy5zdG9wQ2hlY2tTZXNzaW9uT25FcnJvciA9IHN0b3BDaGVja1Nlc3Npb25PbkVycm9yO1xuICAgIHRoaXMucXVlcnlfc3RhdHVzX3Jlc3BvbnNlX3R5cGUgPSBxdWVyeV9zdGF0dXNfcmVzcG9uc2VfdHlwZTtcbiAgICB0aGlzLnJldm9rZVRva2VuVHlwZXMgPSByZXZva2VUb2tlblR5cGVzO1xuICAgIHRoaXMucmV2b2tlVG9rZW5zT25TaWdub3V0ID0gcmV2b2tlVG9rZW5zT25TaWdub3V0O1xuICAgIHRoaXMuaW5jbHVkZUlkVG9rZW5JblNpbGVudFNpZ25vdXQgPSBpbmNsdWRlSWRUb2tlbkluU2lsZW50U2lnbm91dDtcbiAgICB0aGlzLmFjY2Vzc1Rva2VuRXhwaXJpbmdOb3RpZmljYXRpb25UaW1lSW5TZWNvbmRzID0gYWNjZXNzVG9rZW5FeHBpcmluZ05vdGlmaWNhdGlvblRpbWVJblNlY29uZHM7XG4gICAgaWYgKHVzZXJTdG9yZSkge1xuICAgICAgdGhpcy51c2VyU3RvcmUgPSB1c2VyU3RvcmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0b3JlID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5zZXNzaW9uU3RvcmFnZSA6IG5ldyBJbk1lbW9yeVdlYlN0b3JhZ2UoKTtcbiAgICAgIHRoaXMudXNlclN0b3JlID0gbmV3IFdlYlN0b3JhZ2VTdGF0ZVN0b3JlKHsgc3RvcmUgfSk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvbmF2aWdhdG9ycy9JRnJhbWVXaW5kb3cudHNcbnZhciBJRnJhbWVXaW5kb3cgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0Q2hpbGRXaW5kb3cge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgc2lsZW50UmVxdWVzdFRpbWVvdXRJblNlY29uZHMgPSBEZWZhdWx0U2lsZW50UmVxdWVzdFRpbWVvdXRJblNlY29uZHNcbiAgfSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIklGcmFtZVdpbmRvd1wiKTtcbiAgICB0aGlzLl90aW1lb3V0SW5TZWNvbmRzID0gc2lsZW50UmVxdWVzdFRpbWVvdXRJblNlY29uZHM7XG4gICAgdGhpcy5fZnJhbWUgPSBJRnJhbWVXaW5kb3cuY3JlYXRlSGlkZGVuSWZyYW1lKCk7XG4gICAgdGhpcy5fd2luZG93ID0gdGhpcy5fZnJhbWUuY29udGVudFdpbmRvdztcbiAgfVxuICBzdGF0aWMgY3JlYXRlSGlkZGVuSWZyYW1lKCkge1xuICAgIGNvbnN0IGlmcmFtZSA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgIGlmcmFtZS5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICBpZnJhbWUuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG4gICAgaWZyYW1lLnN0eWxlLmxlZnQgPSBcIi0xMDAwcHhcIjtcbiAgICBpZnJhbWUuc3R5bGUudG9wID0gXCIwXCI7XG4gICAgaWZyYW1lLndpZHRoID0gXCIwXCI7XG4gICAgaWZyYW1lLmhlaWdodCA9IFwiMFwiO1xuICAgIHdpbmRvdy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgcmV0dXJuIGlmcmFtZTtcbiAgfVxuICBhc3luYyBuYXZpZ2F0ZShwYXJhbXMpIHtcbiAgICB0aGlzLl9sb2dnZXIuZGVidWcoXCJuYXZpZ2F0ZTogVXNpbmcgdGltZW91dCBvZjpcIiwgdGhpcy5fdGltZW91dEluU2Vjb25kcyk7XG4gICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuX2Fib3J0LnJhaXNlKG5ldyBFcnJvclRpbWVvdXQoXCJJRnJhbWUgdGltZWQgb3V0IHdpdGhvdXQgYSByZXNwb25zZVwiKSksIHRoaXMuX3RpbWVvdXRJblNlY29uZHMgKiAxZTMpO1xuICAgIHRoaXMuX2Rpc3Bvc2VIYW5kbGVycy5hZGQoKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVyKSk7XG4gICAgcmV0dXJuIGF3YWl0IHN1cGVyLm5hdmlnYXRlKHBhcmFtcyk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICh0aGlzLl9mcmFtZSkge1xuICAgICAgaWYgKHRoaXMuX2ZyYW1lLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGhpcy5fZnJhbWUuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKGV2KSA9PiB7XG4gICAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgICBjb25zdCBmcmFtZSA9IGV2LnRhcmdldDtcbiAgICAgICAgICAoX2EyID0gZnJhbWUucGFyZW50Tm9kZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5yZW1vdmVDaGlsZChmcmFtZSk7XG4gICAgICAgICAgdGhpcy5fYWJvcnQucmFpc2UobmV3IEVycm9yKFwiSUZyYW1lIHJlbW92ZWQgZnJvbSBET01cIikpO1xuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgKF9hID0gdGhpcy5fZnJhbWUuY29udGVudFdpbmRvdykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmxvY2F0aW9uLnJlcGxhY2UoXCJhYm91dDpibGFua1wiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZyYW1lID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fd2luZG93ID0gbnVsbDtcbiAgfVxuICBzdGF0aWMgbm90aWZ5UGFyZW50KHVybCwgdGFyZ2V0T3JpZ2luKSB7XG4gICAgcmV0dXJuIHN1cGVyLl9ub3RpZnlQYXJlbnQod2luZG93LnBhcmVudCwgdXJsLCBmYWxzZSwgdGFyZ2V0T3JpZ2luKTtcbiAgfVxufTtcblxuLy8gc3JjL25hdmlnYXRvcnMvSUZyYW1lTmF2aWdhdG9yLnRzXG52YXIgSUZyYW1lTmF2aWdhdG9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihfc2V0dGluZ3MpIHtcbiAgICB0aGlzLl9zZXR0aW5ncyA9IF9zZXR0aW5ncztcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiSUZyYW1lTmF2aWdhdG9yXCIpO1xuICB9XG4gIGFzeW5jIHByZXBhcmUoe1xuICAgIHNpbGVudFJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzID0gdGhpcy5fc2V0dGluZ3Muc2lsZW50UmVxdWVzdFRpbWVvdXRJblNlY29uZHNcbiAgfSkge1xuICAgIHJldHVybiBuZXcgSUZyYW1lV2luZG93KHsgc2lsZW50UmVxdWVzdFRpbWVvdXRJblNlY29uZHMgfSk7XG4gIH1cbiAgYXN5bmMgY2FsbGJhY2sodXJsKSB7XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShcImNhbGxiYWNrXCIpO1xuICAgIElGcmFtZVdpbmRvdy5ub3RpZnlQYXJlbnQodXJsLCB0aGlzLl9zZXR0aW5ncy5pZnJhbWVOb3RpZnlQYXJlbnRPcmlnaW4pO1xuICB9XG59O1xuXG4vLyBzcmMvbmF2aWdhdG9ycy9Qb3B1cFdpbmRvdy50c1xudmFyIGNoZWNrRm9yUG9wdXBDbG9zZWRJbnRlcnZhbCA9IDUwMDtcbnZhciBzZWNvbmQgPSAxZTM7XG52YXIgUG9wdXBXaW5kb3cgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0Q2hpbGRXaW5kb3cge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcG9wdXBXaW5kb3dUYXJnZXQgPSBEZWZhdWx0UG9wdXBUYXJnZXQsXG4gICAgcG9wdXBXaW5kb3dGZWF0dXJlcyA9IHt9XG4gIH0pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2xvZ2dlciA9IG5ldyBMb2dnZXIoXCJQb3B1cFdpbmRvd1wiKTtcbiAgICBjb25zdCBjZW50ZXJlZFBvcHVwID0gUG9wdXBVdGlscy5jZW50ZXIoeyAuLi5EZWZhdWx0UG9wdXBXaW5kb3dGZWF0dXJlcywgLi4ucG9wdXBXaW5kb3dGZWF0dXJlcyB9KTtcbiAgICB0aGlzLl93aW5kb3cgPSB3aW5kb3cub3Blbih2b2lkIDAsIHBvcHVwV2luZG93VGFyZ2V0LCBQb3B1cFV0aWxzLnNlcmlhbGl6ZShjZW50ZXJlZFBvcHVwKSk7XG4gICAgaWYgKHBvcHVwV2luZG93RmVhdHVyZXMuY2xvc2VQb3B1cFdpbmRvd0FmdGVySW5TZWNvbmRzICYmIHBvcHVwV2luZG93RmVhdHVyZXMuY2xvc2VQb3B1cFdpbmRvd0FmdGVySW5TZWNvbmRzID4gMCkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5fd2luZG93IHx8IHR5cGVvZiB0aGlzLl93aW5kb3cuY2xvc2VkICE9PSBcImJvb2xlYW5cIiB8fCB0aGlzLl93aW5kb3cuY2xvc2VkKSB7XG4gICAgICAgICAgdGhpcy5fYWJvcnQucmFpc2UobmV3IEVycm9yKFwiUG9wdXAgYmxvY2tlZCBieSB1c2VyXCIpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfSwgcG9wdXBXaW5kb3dGZWF0dXJlcy5jbG9zZVBvcHVwV2luZG93QWZ0ZXJJblNlY29uZHMgKiBzZWNvbmQpO1xuICAgIH1cbiAgfVxuICBhc3luYyBuYXZpZ2F0ZShwYXJhbXMpIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gdGhpcy5fd2luZG93KSA9PSBudWxsID8gdm9pZCAwIDogX2EuZm9jdXMoKTtcbiAgICBjb25zdCBwb3B1cENsb3NlZEludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl93aW5kb3cgfHwgdGhpcy5fd2luZG93LmNsb3NlZCkge1xuICAgICAgICB0aGlzLl9hYm9ydC5yYWlzZShuZXcgRXJyb3IoXCJQb3B1cCBjbG9zZWQgYnkgdXNlclwiKSk7XG4gICAgICB9XG4gICAgfSwgY2hlY2tGb3JQb3B1cENsb3NlZEludGVydmFsKTtcbiAgICB0aGlzLl9kaXNwb3NlSGFuZGxlcnMuYWRkKCgpID0+IGNsZWFySW50ZXJ2YWwocG9wdXBDbG9zZWRJbnRlcnZhbCkpO1xuICAgIHJldHVybiBhd2FpdCBzdXBlci5uYXZpZ2F0ZShwYXJhbXMpO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIGlmICh0aGlzLl93aW5kb3cpIHtcbiAgICAgIGlmICghdGhpcy5fd2luZG93LmNsb3NlZCkge1xuICAgICAgICB0aGlzLl93aW5kb3cuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5fYWJvcnQucmFpc2UobmV3IEVycm9yKFwiUG9wdXAgY2xvc2VkXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fd2luZG93ID0gbnVsbDtcbiAgfVxuICBzdGF0aWMgbm90aWZ5T3BlbmVyKHVybCwga2VlcE9wZW4pIHtcbiAgICBpZiAoIXdpbmRvdy5vcGVuZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHdpbmRvdy5vcGVuZXIuIENhbid0IGNvbXBsZXRlIG5vdGlmaWNhdGlvbi5cIik7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5fbm90aWZ5UGFyZW50KHdpbmRvdy5vcGVuZXIsIHVybCwga2VlcE9wZW4pO1xuICB9XG59O1xuXG4vLyBzcmMvbmF2aWdhdG9ycy9Qb3B1cE5hdmlnYXRvci50c1xudmFyIFBvcHVwTmF2aWdhdG9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihfc2V0dGluZ3MpIHtcbiAgICB0aGlzLl9zZXR0aW5ncyA9IF9zZXR0aW5ncztcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiUG9wdXBOYXZpZ2F0b3JcIik7XG4gIH1cbiAgYXN5bmMgcHJlcGFyZSh7XG4gICAgcG9wdXBXaW5kb3dGZWF0dXJlcyA9IHRoaXMuX3NldHRpbmdzLnBvcHVwV2luZG93RmVhdHVyZXMsXG4gICAgcG9wdXBXaW5kb3dUYXJnZXQgPSB0aGlzLl9zZXR0aW5ncy5wb3B1cFdpbmRvd1RhcmdldFxuICB9KSB7XG4gICAgcmV0dXJuIG5ldyBQb3B1cFdpbmRvdyh7IHBvcHVwV2luZG93RmVhdHVyZXMsIHBvcHVwV2luZG93VGFyZ2V0IH0pO1xuICB9XG4gIGFzeW5jIGNhbGxiYWNrKHVybCwgeyBrZWVwT3BlbiA9IGZhbHNlIH0pIHtcbiAgICB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiY2FsbGJhY2tcIik7XG4gICAgUG9wdXBXaW5kb3cubm90aWZ5T3BlbmVyKHVybCwga2VlcE9wZW4pO1xuICB9XG59O1xuXG4vLyBzcmMvbmF2aWdhdG9ycy9SZWRpcmVjdE5hdmlnYXRvci50c1xudmFyIFJlZGlyZWN0TmF2aWdhdG9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihfc2V0dGluZ3MpIHtcbiAgICB0aGlzLl9zZXR0aW5ncyA9IF9zZXR0aW5ncztcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiUmVkaXJlY3ROYXZpZ2F0b3JcIik7XG4gIH1cbiAgYXN5bmMgcHJlcGFyZSh7XG4gICAgcmVkaXJlY3RNZXRob2QgPSB0aGlzLl9zZXR0aW5ncy5yZWRpcmVjdE1ldGhvZCxcbiAgICByZWRpcmVjdFRhcmdldCA9IHRoaXMuX3NldHRpbmdzLnJlZGlyZWN0VGFyZ2V0XG4gIH0pIHtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInByZXBhcmVcIik7XG4gICAgbGV0IHRhcmdldFdpbmRvdyA9IHdpbmRvdy5zZWxmO1xuICAgIGlmIChyZWRpcmVjdFRhcmdldCA9PT0gXCJ0b3BcIikge1xuICAgICAgdGFyZ2V0V2luZG93ID0gKF9hID0gd2luZG93LnRvcCkgIT0gbnVsbCA/IF9hIDogd2luZG93LnNlbGY7XG4gICAgfVxuICAgIGNvbnN0IHJlZGlyZWN0ID0gdGFyZ2V0V2luZG93LmxvY2F0aW9uW3JlZGlyZWN0TWV0aG9kXS5iaW5kKHRhcmdldFdpbmRvdy5sb2NhdGlvbik7XG4gICAgbGV0IGFib3J0O1xuICAgIHJldHVybiB7XG4gICAgICBuYXZpZ2F0ZTogYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICB0aGlzLl9sb2dnZXIuY3JlYXRlKFwibmF2aWdhdGVcIik7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgYWJvcnQgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICByZWRpcmVjdChwYXJhbXMudXJsKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHByb21pc2U7XG4gICAgICB9LFxuICAgICAgY2xvc2U6ICgpID0+IHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShcImNsb3NlXCIpO1xuICAgICAgICBhYm9ydCA9PSBudWxsID8gdm9pZCAwIDogYWJvcnQobmV3IEVycm9yKFwiUmVkaXJlY3QgYWJvcnRlZFwiKSk7XG4gICAgICAgIHRhcmdldFdpbmRvdy5zdG9wKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBhc3luYyBjYWxsYmFjaygpIHtcbiAgICByZXR1cm47XG4gIH1cbn07XG5cbi8vIHNyYy9Vc2VyTWFuYWdlckV2ZW50cy50c1xudmFyIFVzZXJNYW5hZ2VyRXZlbnRzID0gY2xhc3MgZXh0ZW5kcyBBY2Nlc3NUb2tlbkV2ZW50cyB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgc3VwZXIoeyBleHBpcmluZ05vdGlmaWNhdGlvblRpbWVJblNlY29uZHM6IHNldHRpbmdzLmFjY2Vzc1Rva2VuRXhwaXJpbmdOb3RpZmljYXRpb25UaW1lSW5TZWNvbmRzIH0pO1xuICAgIHRoaXMuX2xvZ2dlciA9IG5ldyBMb2dnZXIoXCJVc2VyTWFuYWdlckV2ZW50c1wiKTtcbiAgICB0aGlzLl91c2VyTG9hZGVkID0gbmV3IEV2ZW50KFwiVXNlciBsb2FkZWRcIik7XG4gICAgdGhpcy5fdXNlclVubG9hZGVkID0gbmV3IEV2ZW50KFwiVXNlciB1bmxvYWRlZFwiKTtcbiAgICB0aGlzLl9zaWxlbnRSZW5ld0Vycm9yID0gbmV3IEV2ZW50KFwiU2lsZW50IHJlbmV3IGVycm9yXCIpO1xuICAgIHRoaXMuX3VzZXJTaWduZWRJbiA9IG5ldyBFdmVudChcIlVzZXIgc2lnbmVkIGluXCIpO1xuICAgIHRoaXMuX3VzZXJTaWduZWRPdXQgPSBuZXcgRXZlbnQoXCJVc2VyIHNpZ25lZCBvdXRcIik7XG4gICAgdGhpcy5fdXNlclNlc3Npb25DaGFuZ2VkID0gbmV3IEV2ZW50KFwiVXNlciBzZXNzaW9uIGNoYW5nZWRcIik7XG4gIH1cbiAgbG9hZCh1c2VyLCByYWlzZUV2ZW50ID0gdHJ1ZSkge1xuICAgIHN1cGVyLmxvYWQodXNlcik7XG4gICAgaWYgKHJhaXNlRXZlbnQpIHtcbiAgICAgIHRoaXMuX3VzZXJMb2FkZWQucmFpc2UodXNlcik7XG4gICAgfVxuICB9XG4gIHVubG9hZCgpIHtcbiAgICBzdXBlci51bmxvYWQoKTtcbiAgICB0aGlzLl91c2VyVW5sb2FkZWQucmFpc2UoKTtcbiAgfVxuICAvKipcbiAgICogQWRkIGNhbGxiYWNrOiBSYWlzZWQgd2hlbiBhIHVzZXIgc2Vzc2lvbiBoYXMgYmVlbiBlc3RhYmxpc2hlZCAob3IgcmUtZXN0YWJsaXNoZWQpLlxuICAgKi9cbiAgYWRkVXNlckxvYWRlZChjYikge1xuICAgIHJldHVybiB0aGlzLl91c2VyTG9hZGVkLmFkZEhhbmRsZXIoY2IpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgY2FsbGJhY2s6IFJhaXNlZCB3aGVuIGEgdXNlciBzZXNzaW9uIGhhcyBiZWVuIGVzdGFibGlzaGVkIChvciByZS1lc3RhYmxpc2hlZCkuXG4gICAqL1xuICByZW1vdmVVc2VyTG9hZGVkKGNiKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXJMb2FkZWQucmVtb3ZlSGFuZGxlcihjYik7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBjYWxsYmFjazogUmFpc2VkIHdoZW4gYSB1c2VyIHNlc3Npb24gaGFzIGJlZW4gdGVybWluYXRlZC5cbiAgICovXG4gIGFkZFVzZXJVbmxvYWRlZChjYikge1xuICAgIHJldHVybiB0aGlzLl91c2VyVW5sb2FkZWQuYWRkSGFuZGxlcihjYik7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBjYWxsYmFjazogUmFpc2VkIHdoZW4gYSB1c2VyIHNlc3Npb24gaGFzIGJlZW4gdGVybWluYXRlZC5cbiAgICovXG4gIHJlbW92ZVVzZXJVbmxvYWRlZChjYikge1xuICAgIHJldHVybiB0aGlzLl91c2VyVW5sb2FkZWQucmVtb3ZlSGFuZGxlcihjYik7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBjYWxsYmFjazogUmFpc2VkIHdoZW4gdGhlIGF1dG9tYXRpYyBzaWxlbnQgcmVuZXcgaGFzIGZhaWxlZC5cbiAgICovXG4gIGFkZFNpbGVudFJlbmV3RXJyb3IoY2IpIHtcbiAgICByZXR1cm4gdGhpcy5fc2lsZW50UmVuZXdFcnJvci5hZGRIYW5kbGVyKGNiKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGNhbGxiYWNrOiBSYWlzZWQgd2hlbiB0aGUgYXV0b21hdGljIHNpbGVudCByZW5ldyBoYXMgZmFpbGVkLlxuICAgKi9cbiAgcmVtb3ZlU2lsZW50UmVuZXdFcnJvcihjYikge1xuICAgIHJldHVybiB0aGlzLl9zaWxlbnRSZW5ld0Vycm9yLnJlbW92ZUhhbmRsZXIoY2IpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9yYWlzZVNpbGVudFJlbmV3RXJyb3IoZSkge1xuICAgIHRoaXMuX3NpbGVudFJlbmV3RXJyb3IucmFpc2UoZSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBjYWxsYmFjazogUmFpc2VkIHdoZW4gdGhlIHVzZXIgaXMgc2lnbmVkIGluICh3aGVuIGBtb25pdG9yU2Vzc2lvbmAgaXMgc2V0KS5cbiAgICogQHNlZSB7QGxpbmsgVXNlck1hbmFnZXJTZXR0aW5ncy5tb25pdG9yU2Vzc2lvbn1cbiAgICovXG4gIGFkZFVzZXJTaWduZWRJbihjYikge1xuICAgIHJldHVybiB0aGlzLl91c2VyU2lnbmVkSW4uYWRkSGFuZGxlcihjYik7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBjYWxsYmFjazogUmFpc2VkIHdoZW4gdGhlIHVzZXIgaXMgc2lnbmVkIGluICh3aGVuIGBtb25pdG9yU2Vzc2lvbmAgaXMgc2V0KS5cbiAgICovXG4gIHJlbW92ZVVzZXJTaWduZWRJbihjYikge1xuICAgIHRoaXMuX3VzZXJTaWduZWRJbi5yZW1vdmVIYW5kbGVyKGNiKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfcmFpc2VVc2VyU2lnbmVkSW4oKSB7XG4gICAgdGhpcy5fdXNlclNpZ25lZEluLnJhaXNlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBjYWxsYmFjazogUmFpc2VkIHdoZW4gdGhlIHVzZXIncyBzaWduLWluIHN0YXR1cyBhdCB0aGUgT1AgaGFzIGNoYW5nZWQgKHdoZW4gYG1vbml0b3JTZXNzaW9uYCBpcyBzZXQpLlxuICAgKiBAc2VlIHtAbGluayBVc2VyTWFuYWdlclNldHRpbmdzLm1vbml0b3JTZXNzaW9ufVxuICAgKi9cbiAgYWRkVXNlclNpZ25lZE91dChjYikge1xuICAgIHJldHVybiB0aGlzLl91c2VyU2lnbmVkT3V0LmFkZEhhbmRsZXIoY2IpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgY2FsbGJhY2s6IFJhaXNlZCB3aGVuIHRoZSB1c2VyJ3Mgc2lnbi1pbiBzdGF0dXMgYXQgdGhlIE9QIGhhcyBjaGFuZ2VkICh3aGVuIGBtb25pdG9yU2Vzc2lvbmAgaXMgc2V0KS5cbiAgICovXG4gIHJlbW92ZVVzZXJTaWduZWRPdXQoY2IpIHtcbiAgICB0aGlzLl91c2VyU2lnbmVkT3V0LnJlbW92ZUhhbmRsZXIoY2IpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9yYWlzZVVzZXJTaWduZWRPdXQoKSB7XG4gICAgdGhpcy5fdXNlclNpZ25lZE91dC5yYWlzZSgpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgY2FsbGJhY2s6IFJhaXNlZCB3aGVuIHRoZSB1c2VyIHNlc3Npb24gY2hhbmdlZCAod2hlbiBgbW9uaXRvclNlc3Npb25gIGlzIHNldCkuXG4gICAqIEBzZWUge0BsaW5rIFVzZXJNYW5hZ2VyU2V0dGluZ3MubW9uaXRvclNlc3Npb259XG4gICAqL1xuICBhZGRVc2VyU2Vzc2lvbkNoYW5nZWQoY2IpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlclNlc3Npb25DaGFuZ2VkLmFkZEhhbmRsZXIoY2IpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgY2FsbGJhY2s6IFJhaXNlZCB3aGVuIHRoZSB1c2VyIHNlc3Npb24gY2hhbmdlZCAod2hlbiBgbW9uaXRvclNlc3Npb25gIGlzIHNldCkuXG4gICAqL1xuICByZW1vdmVVc2VyU2Vzc2lvbkNoYW5nZWQoY2IpIHtcbiAgICB0aGlzLl91c2VyU2Vzc2lvbkNoYW5nZWQucmVtb3ZlSGFuZGxlcihjYik7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3JhaXNlVXNlclNlc3Npb25DaGFuZ2VkKCkge1xuICAgIHRoaXMuX3VzZXJTZXNzaW9uQ2hhbmdlZC5yYWlzZSgpO1xuICB9XG59O1xuXG4vLyBzcmMvU2lsZW50UmVuZXdTZXJ2aWNlLnRzXG52YXIgU2lsZW50UmVuZXdTZXJ2aWNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihfdXNlck1hbmFnZXIpIHtcbiAgICB0aGlzLl91c2VyTWFuYWdlciA9IF91c2VyTWFuYWdlcjtcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiU2lsZW50UmVuZXdTZXJ2aWNlXCIpO1xuICAgIHRoaXMuX2lzU3RhcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JldHJ5VGltZXIgPSBuZXcgVGltZXIoXCJSZXRyeSBTaWxlbnQgUmVuZXdcIik7XG4gICAgdGhpcy5fdG9rZW5FeHBpcmluZyA9IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiX3Rva2VuRXhwaXJpbmdcIik7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLl91c2VyTWFuYWdlci5zaWduaW5TaWxlbnQoKTtcbiAgICAgICAgbG9nZ2VyMi5kZWJ1ZyhcInNpbGVudCB0b2tlbiByZW5ld2FsIHN1Y2Nlc3NmdWxcIik7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yVGltZW91dCkge1xuICAgICAgICAgIGxvZ2dlcjIud2FybihcIkVycm9yVGltZW91dCBmcm9tIHNpZ25pblNpbGVudDpcIiwgZXJyLCBcInJldHJ5IGluIDVzXCIpO1xuICAgICAgICAgIHRoaXMuX3JldHJ5VGltZXIuaW5pdCg1KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyMi5lcnJvcihcIkVycm9yIGZyb20gc2lnbmluU2lsZW50OlwiLCBlcnIpO1xuICAgICAgICB0aGlzLl91c2VyTWFuYWdlci5ldmVudHMuX3JhaXNlU2lsZW50UmVuZXdFcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgYXN5bmMgc3RhcnQoKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJzdGFydFwiKTtcbiAgICBpZiAoIXRoaXMuX2lzU3RhcnRlZCkge1xuICAgICAgdGhpcy5faXNTdGFydGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3VzZXJNYW5hZ2VyLmV2ZW50cy5hZGRBY2Nlc3NUb2tlbkV4cGlyaW5nKHRoaXMuX3Rva2VuRXhwaXJpbmcpO1xuICAgICAgdGhpcy5fcmV0cnlUaW1lci5hZGRIYW5kbGVyKHRoaXMuX3Rva2VuRXhwaXJpbmcpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5fdXNlck1hbmFnZXIuZ2V0VXNlcigpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ2dlcjIuZXJyb3IoXCJnZXRVc2VyIGVycm9yXCIsIGVycik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuX2lzU3RhcnRlZCkge1xuICAgICAgdGhpcy5fcmV0cnlUaW1lci5jYW5jZWwoKTtcbiAgICAgIHRoaXMuX3JldHJ5VGltZXIucmVtb3ZlSGFuZGxlcih0aGlzLl90b2tlbkV4cGlyaW5nKTtcbiAgICAgIHRoaXMuX3VzZXJNYW5hZ2VyLmV2ZW50cy5yZW1vdmVBY2Nlc3NUb2tlbkV4cGlyaW5nKHRoaXMuX3Rva2VuRXhwaXJpbmcpO1xuICAgICAgdGhpcy5faXNTdGFydGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvUmVmcmVzaFN0YXRlLnRzXG52YXIgUmVmcmVzaFN0YXRlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihhcmdzLCByZXNvdXJjZSkge1xuICAgIHRoaXMucmVmcmVzaF90b2tlbiA9IGFyZ3MucmVmcmVzaF90b2tlbjtcbiAgICB0aGlzLmlkX3Rva2VuID0gYXJncy5pZF90b2tlbjtcbiAgICB0aGlzLnNlc3Npb25fc3RhdGUgPSBhcmdzLnNlc3Npb25fc3RhdGU7XG4gICAgdGhpcy5zY29wZSA9IGFyZ3Muc2NvcGU7XG4gICAgdGhpcy5wcm9maWxlID0gYXJncy5wcm9maWxlO1xuICAgIHRoaXMucmVzb3VyY2UgPSByZXNvdXJjZTtcbiAgICB0aGlzLmRhdGEgPSBhcmdzLnN0YXRlO1xuICB9XG59O1xuXG4vLyBzcmMvVXNlck1hbmFnZXIudHNcbnZhciBVc2VyTWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MsIHJlZGlyZWN0TmF2aWdhdG9yLCBwb3B1cE5hdmlnYXRvciwgaWZyYW1lTmF2aWdhdG9yKSB7XG4gICAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIlVzZXJNYW5hZ2VyXCIpO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBuZXcgVXNlck1hbmFnZXJTZXR0aW5nc1N0b3JlKHNldHRpbmdzKTtcbiAgICB0aGlzLl9jbGllbnQgPSBuZXcgT2lkY0NsaWVudChzZXR0aW5ncyk7XG4gICAgdGhpcy5fcmVkaXJlY3ROYXZpZ2F0b3IgPSByZWRpcmVjdE5hdmlnYXRvciAhPSBudWxsID8gcmVkaXJlY3ROYXZpZ2F0b3IgOiBuZXcgUmVkaXJlY3ROYXZpZ2F0b3IodGhpcy5zZXR0aW5ncyk7XG4gICAgdGhpcy5fcG9wdXBOYXZpZ2F0b3IgPSBwb3B1cE5hdmlnYXRvciAhPSBudWxsID8gcG9wdXBOYXZpZ2F0b3IgOiBuZXcgUG9wdXBOYXZpZ2F0b3IodGhpcy5zZXR0aW5ncyk7XG4gICAgdGhpcy5faWZyYW1lTmF2aWdhdG9yID0gaWZyYW1lTmF2aWdhdG9yICE9IG51bGwgPyBpZnJhbWVOYXZpZ2F0b3IgOiBuZXcgSUZyYW1lTmF2aWdhdG9yKHRoaXMuc2V0dGluZ3MpO1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBVc2VyTWFuYWdlckV2ZW50cyh0aGlzLnNldHRpbmdzKTtcbiAgICB0aGlzLl9zaWxlbnRSZW5ld1NlcnZpY2UgPSBuZXcgU2lsZW50UmVuZXdTZXJ2aWNlKHRoaXMpO1xuICAgIGlmICh0aGlzLnNldHRpbmdzLmF1dG9tYXRpY1NpbGVudFJlbmV3KSB7XG4gICAgICB0aGlzLnN0YXJ0U2lsZW50UmVuZXcoKTtcbiAgICB9XG4gICAgdGhpcy5fc2Vzc2lvbk1vbml0b3IgPSBudWxsO1xuICAgIGlmICh0aGlzLnNldHRpbmdzLm1vbml0b3JTZXNzaW9uKSB7XG4gICAgICB0aGlzLl9zZXNzaW9uTW9uaXRvciA9IG5ldyBTZXNzaW9uTW9uaXRvcih0aGlzKTtcbiAgICB9XG4gIH1cbiAgLyoqIFJldHVybnMgYW4gb2JqZWN0IHVzZWQgdG8gcmVnaXN0ZXIgZm9yIGV2ZW50cyByYWlzZWQgYnkgdGhlIGBVc2VyTWFuYWdlcmAuICovXG4gIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V2ZW50cztcbiAgfVxuICAvKiogUmV0dXJucyBhbiBvYmplY3QgdXNlZCB0byBhY2Nlc3MgdGhlIG1ldGFkYXRhIGNvbmZpZ3VyYXRpb24gb2YgdGhlIE9JREMgcHJvdmlkZXIuICovXG4gIGdldCBtZXRhZGF0YVNlcnZpY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5tZXRhZGF0YVNlcnZpY2U7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgcHJvbWlzZSB0byBsb2FkIHRoZSBgVXNlcmAgb2JqZWN0IGZvciB0aGUgY3VycmVudGx5IGF1dGhlbnRpY2F0ZWQgdXNlci5cbiAgICovXG4gIGFzeW5jIGdldFVzZXIoKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJnZXRVc2VyXCIpO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLl9sb2FkVXNlcigpO1xuICAgIGlmICh1c2VyKSB7XG4gICAgICBsb2dnZXIyLmluZm8oXCJ1c2VyIGxvYWRlZFwiKTtcbiAgICAgIHRoaXMuX2V2ZW50cy5sb2FkKHVzZXIsIGZhbHNlKTtcbiAgICAgIHJldHVybiB1c2VyO1xuICAgIH1cbiAgICBsb2dnZXIyLmluZm8oXCJ1c2VyIG5vdCBmb3VuZCBpbiBzdG9yYWdlXCIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHByb21pc2UgdG8gcmVtb3ZlIGZyb20gYW55IHN0b3JhZ2UgdGhlIGN1cnJlbnRseSBhdXRoZW50aWNhdGVkIHVzZXIuXG4gICAqL1xuICBhc3luYyByZW1vdmVVc2VyKCkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwicmVtb3ZlVXNlclwiKTtcbiAgICBhd2FpdCB0aGlzLnN0b3JlVXNlcihudWxsKTtcbiAgICBsb2dnZXIyLmluZm8oXCJ1c2VyIHJlbW92ZWQgZnJvbSBzdG9yYWdlXCIpO1xuICAgIHRoaXMuX2V2ZW50cy51bmxvYWQoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBwcm9taXNlIHRvIHRyaWdnZXIgYSByZWRpcmVjdCBvZiB0aGUgY3VycmVudCB3aW5kb3cgdG8gdGhlIGF1dGhvcml6YXRpb24gZW5kcG9pbnQuXG4gICAqL1xuICBhc3luYyBzaWduaW5SZWRpcmVjdChhcmdzID0ge30pIHtcbiAgICB0aGlzLl9sb2dnZXIuY3JlYXRlKFwic2lnbmluUmVkaXJlY3RcIik7XG4gICAgY29uc3Qge1xuICAgICAgcmVkaXJlY3RNZXRob2QsXG4gICAgICAuLi5yZXF1ZXN0QXJnc1xuICAgIH0gPSBhcmdzO1xuICAgIGNvbnN0IGhhbmRsZSA9IGF3YWl0IHRoaXMuX3JlZGlyZWN0TmF2aWdhdG9yLnByZXBhcmUoeyByZWRpcmVjdE1ldGhvZCB9KTtcbiAgICBhd2FpdCB0aGlzLl9zaWduaW5TdGFydCh7XG4gICAgICByZXF1ZXN0X3R5cGU6IFwic2k6clwiLFxuICAgICAgLi4ucmVxdWVzdEFyZ3NcbiAgICB9LCBoYW5kbGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHByb21pc2UgdG8gcHJvY2VzcyByZXNwb25zZSBmcm9tIHRoZSBhdXRob3JpemF0aW9uIGVuZHBvaW50LiBUaGUgcmVzdWx0IG9mIHRoZSBwcm9taXNlIGlzIHRoZSBhdXRoZW50aWNhdGVkIGBVc2VyYC5cbiAgICovXG4gIGFzeW5jIHNpZ25pblJlZGlyZWN0Q2FsbGJhY2sodXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWYpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInNpZ25pblJlZGlyZWN0Q2FsbGJhY2tcIik7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMuX3NpZ25pbkVuZCh1cmwpO1xuICAgIGlmICh1c2VyLnByb2ZpbGUgJiYgdXNlci5wcm9maWxlLnN1Yikge1xuICAgICAgbG9nZ2VyMi5pbmZvKFwic3VjY2Vzcywgc2lnbmVkIGluIHN1YmplY3RcIiwgdXNlci5wcm9maWxlLnN1Yik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlcjIuaW5mbyhcIm5vIHN1YmplY3RcIik7XG4gICAgfVxuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHByb21pc2UgdG8gcHJvY2VzcyB0aGUgc2lnbmluIHdpdGggdXNlci9wYXNzd29yZC4gVGhlIHJlc3VsdCBvZiB0aGUgcHJvbWlzZSBpcyB0aGUgYXV0aGVudGljYXRlZCBgVXNlcmAuXG4gICAqXG4gICAqIFRocm93cyBhbiBFcnJvclJlc3BvbnNlIGluIGNhc2Ugb2Ygd3JvbmcgYXV0aGVudGljYXRpb24uXG4gICAqL1xuICBhc3luYyBzaWduaW5SZXNvdXJjZU93bmVyQ3JlZGVudGlhbHMoe1xuICAgIHVzZXJuYW1lLFxuICAgIHBhc3N3b3JkLFxuICAgIHNraXBVc2VySW5mbyA9IGZhbHNlXG4gIH0pIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInNpZ25pblJlc291cmNlT3duZXJDcmVkZW50aWFsXCIpO1xuICAgIGNvbnN0IHNpZ25pblJlc3BvbnNlID0gYXdhaXQgdGhpcy5fY2xpZW50LnByb2Nlc3NSZXNvdXJjZU93bmVyUGFzc3dvcmRDcmVkZW50aWFscyh7IHVzZXJuYW1lLCBwYXNzd29yZCwgc2tpcFVzZXJJbmZvLCBleHRyYVRva2VuUGFyYW1zOiB0aGlzLnNldHRpbmdzLmV4dHJhVG9rZW5QYXJhbXMgfSk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcImdvdCBzaWduaW4gcmVzcG9uc2VcIik7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMuX2J1aWxkVXNlcihzaWduaW5SZXNwb25zZSk7XG4gICAgaWYgKHVzZXIucHJvZmlsZSAmJiB1c2VyLnByb2ZpbGUuc3ViKSB7XG4gICAgICBsb2dnZXIyLmluZm8oXCJzdWNjZXNzLCBzaWduZWQgaW4gc3ViamVjdFwiLCB1c2VyLnByb2ZpbGUuc3ViKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyMi5pbmZvKFwibm8gc3ViamVjdFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZXI7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgcHJvbWlzZSB0byB0cmlnZ2VyIGEgcmVxdWVzdCAodmlhIGEgcG9wdXAgd2luZG93KSB0byB0aGUgYXV0aG9yaXphdGlvbiBlbmRwb2ludC4gVGhlIHJlc3VsdCBvZiB0aGUgcHJvbWlzZSBpcyB0aGUgYXV0aGVudGljYXRlZCBgVXNlcmAuXG4gICAqL1xuICBhc3luYyBzaWduaW5Qb3B1cChhcmdzID0ge30pIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInNpZ25pblBvcHVwXCIpO1xuICAgIGNvbnN0IHtcbiAgICAgIHBvcHVwV2luZG93RmVhdHVyZXMsXG4gICAgICBwb3B1cFdpbmRvd1RhcmdldCxcbiAgICAgIC4uLnJlcXVlc3RBcmdzXG4gICAgfSA9IGFyZ3M7XG4gICAgY29uc3QgdXJsID0gdGhpcy5zZXR0aW5ncy5wb3B1cF9yZWRpcmVjdF91cmk7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiTm8gcG9wdXBfcmVkaXJlY3RfdXJpIGNvbmZpZ3VyZWRcIikpO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGUgPSBhd2FpdCB0aGlzLl9wb3B1cE5hdmlnYXRvci5wcmVwYXJlKHsgcG9wdXBXaW5kb3dGZWF0dXJlcywgcG9wdXBXaW5kb3dUYXJnZXQgfSk7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMuX3NpZ25pbih7XG4gICAgICByZXF1ZXN0X3R5cGU6IFwic2k6cFwiLFxuICAgICAgcmVkaXJlY3RfdXJpOiB1cmwsXG4gICAgICBkaXNwbGF5OiBcInBvcHVwXCIsXG4gICAgICAuLi5yZXF1ZXN0QXJnc1xuICAgIH0sIGhhbmRsZSk7XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIGlmICh1c2VyLnByb2ZpbGUgJiYgdXNlci5wcm9maWxlLnN1Yikge1xuICAgICAgICBsb2dnZXIyLmluZm8oXCJzdWNjZXNzLCBzaWduZWQgaW4gc3ViamVjdFwiLCB1c2VyLnByb2ZpbGUuc3ViKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlcjIuaW5mbyhcIm5vIHN1YmplY3RcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHByb21pc2UgdG8gbm90aWZ5IHRoZSBvcGVuaW5nIHdpbmRvdyBvZiByZXNwb25zZSBmcm9tIHRoZSBhdXRob3JpemF0aW9uIGVuZHBvaW50LlxuICAgKi9cbiAgYXN5bmMgc2lnbmluUG9wdXBDYWxsYmFjayh1cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZiwga2VlcE9wZW4gPSBmYWxzZSkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwic2lnbmluUG9wdXBDYWxsYmFja1wiKTtcbiAgICBhd2FpdCB0aGlzLl9wb3B1cE5hdmlnYXRvci5jYWxsYmFjayh1cmwsIHsga2VlcE9wZW4gfSk7XG4gICAgbG9nZ2VyMi5pbmZvKFwic3VjY2Vzc1wiKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBwcm9taXNlIHRvIHRyaWdnZXIgYSBzaWxlbnQgcmVxdWVzdCAodmlhIGFuIGlmcmFtZSkgdG8gdGhlIGF1dGhvcml6YXRpb24gZW5kcG9pbnQuXG4gICAqIFRoZSByZXN1bHQgb2YgdGhlIHByb21pc2UgaXMgdGhlIGF1dGhlbnRpY2F0ZWQgYFVzZXJgLlxuICAgKi9cbiAgYXN5bmMgc2lnbmluU2lsZW50KGFyZ3MgPSB7fSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInNpZ25pblNpbGVudFwiKTtcbiAgICBjb25zdCB7XG4gICAgICBzaWxlbnRSZXF1ZXN0VGltZW91dEluU2Vjb25kcyxcbiAgICAgIHJlc291cmNlLFxuICAgICAgLi4ucmVxdWVzdEFyZ3NcbiAgICB9ID0gYXJncztcbiAgICBsZXQgdXNlciA9IGF3YWl0IHRoaXMuX2xvYWRVc2VyKCk7XG4gICAgaWYgKHVzZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHVzZXIucmVmcmVzaF90b2tlbikge1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcInVzaW5nIHJlZnJlc2ggdG9rZW5cIik7XG4gICAgICBjb25zdCBzdGF0ZSA9IG5ldyBSZWZyZXNoU3RhdGUodXNlciwgcmVzb3VyY2UpO1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVJlZnJlc2hUb2tlbihzdGF0ZSk7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IHRoaXMuc2V0dGluZ3Muc2lsZW50X3JlZGlyZWN0X3VyaTtcbiAgICBpZiAoIXVybCkge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJObyBzaWxlbnRfcmVkaXJlY3RfdXJpIGNvbmZpZ3VyZWRcIikpO1xuICAgIH1cbiAgICBsZXQgdmVyaWZ5U3ViO1xuICAgIGlmICh1c2VyICYmIHRoaXMuc2V0dGluZ3MudmFsaWRhdGVTdWJPblNpbGVudFJlbmV3KSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwic3ViamVjdCBwcmlvciB0byBzaWxlbnQgcmVuZXc6XCIsIHVzZXIucHJvZmlsZS5zdWIpO1xuICAgICAgdmVyaWZ5U3ViID0gdXNlci5wcm9maWxlLnN1YjtcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlID0gYXdhaXQgdGhpcy5faWZyYW1lTmF2aWdhdG9yLnByZXBhcmUoeyBzaWxlbnRSZXF1ZXN0VGltZW91dEluU2Vjb25kcyB9KTtcbiAgICB1c2VyID0gYXdhaXQgdGhpcy5fc2lnbmluKHtcbiAgICAgIHJlcXVlc3RfdHlwZTogXCJzaTpzXCIsXG4gICAgICByZWRpcmVjdF91cmk6IHVybCxcbiAgICAgIHByb21wdDogXCJub25lXCIsXG4gICAgICBpZF90b2tlbl9oaW50OiB0aGlzLnNldHRpbmdzLmluY2x1ZGVJZFRva2VuSW5TaWxlbnRSZW5ldyA/IHVzZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHVzZXIuaWRfdG9rZW4gOiB2b2lkIDAsXG4gICAgICAuLi5yZXF1ZXN0QXJnc1xuICAgIH0sIGhhbmRsZSwgdmVyaWZ5U3ViKTtcbiAgICBpZiAodXNlcikge1xuICAgICAgaWYgKChfYSA9IHVzZXIucHJvZmlsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnN1Yikge1xuICAgICAgICBsb2dnZXIyLmluZm8oXCJzdWNjZXNzLCBzaWduZWQgaW4gc3ViamVjdFwiLCB1c2VyLnByb2ZpbGUuc3ViKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlcjIuaW5mbyhcIm5vIHN1YmplY3RcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIGFzeW5jIF91c2VSZWZyZXNoVG9rZW4oc3RhdGUpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2NsaWVudC51c2VSZWZyZXNoVG9rZW4oe1xuICAgICAgc3RhdGUsXG4gICAgICB0aW1lb3V0SW5TZWNvbmRzOiB0aGlzLnNldHRpbmdzLnNpbGVudFJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzXG4gICAgfSk7XG4gICAgY29uc3QgdXNlciA9IG5ldyBVc2VyKHsgLi4uc3RhdGUsIC4uLnJlc3BvbnNlIH0pO1xuICAgIGF3YWl0IHRoaXMuc3RvcmVVc2VyKHVzZXIpO1xuICAgIHRoaXMuX2V2ZW50cy5sb2FkKHVzZXIpO1xuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHByb21pc2UgdG8gbm90aWZ5IHRoZSBwYXJlbnQgd2luZG93IG9mIHJlc3BvbnNlIGZyb20gdGhlIGF1dGhvcml6YXRpb24gZW5kcG9pbnQuXG4gICAqL1xuICBhc3luYyBzaWduaW5TaWxlbnRDYWxsYmFjayh1cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZikge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwic2lnbmluU2lsZW50Q2FsbGJhY2tcIik7XG4gICAgYXdhaXQgdGhpcy5faWZyYW1lTmF2aWdhdG9yLmNhbGxiYWNrKHVybCk7XG4gICAgbG9nZ2VyMi5pbmZvKFwic3VjY2Vzc1wiKTtcbiAgfVxuICBhc3luYyBzaWduaW5DYWxsYmFjayh1cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZikge1xuICAgIGNvbnN0IHsgc3RhdGUgfSA9IGF3YWl0IHRoaXMuX2NsaWVudC5yZWFkU2lnbmluUmVzcG9uc2VTdGF0ZSh1cmwpO1xuICAgIHN3aXRjaCAoc3RhdGUucmVxdWVzdF90eXBlKSB7XG4gICAgICBjYXNlIFwic2k6clwiOlxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zaWduaW5SZWRpcmVjdENhbGxiYWNrKHVybCk7XG4gICAgICBjYXNlIFwic2k6cFwiOlxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zaWduaW5Qb3B1cENhbGxiYWNrKHVybCk7XG4gICAgICBjYXNlIFwic2k6c1wiOlxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zaWduaW5TaWxlbnRDYWxsYmFjayh1cmwpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCByZXNwb25zZV90eXBlIGluIHN0YXRlXCIpO1xuICAgIH1cbiAgfVxuICBhc3luYyBzaWdub3V0Q2FsbGJhY2sodXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWYsIGtlZXBPcGVuID0gZmFsc2UpIHtcbiAgICBjb25zdCB7IHN0YXRlIH0gPSBhd2FpdCB0aGlzLl9jbGllbnQucmVhZFNpZ25vdXRSZXNwb25zZVN0YXRlKHVybCk7XG4gICAgaWYgKCFzdGF0ZSkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgc3dpdGNoIChzdGF0ZS5yZXF1ZXN0X3R5cGUpIHtcbiAgICAgIGNhc2UgXCJzbzpyXCI6XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNpZ25vdXRSZWRpcmVjdENhbGxiYWNrKHVybCk7XG4gICAgICBjYXNlIFwic286cFwiOlxuICAgICAgICBhd2FpdCB0aGlzLnNpZ25vdXRQb3B1cENhbGxiYWNrKHVybCwga2VlcE9wZW4pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzbzpzXCI6XG4gICAgICAgIGF3YWl0IHRoaXMuc2lnbm91dFNpbGVudENhbGxiYWNrKHVybCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCByZXNwb25zZV90eXBlIGluIHN0YXRlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHByb21pc2UgdG8gcXVlcnkgT1AgZm9yIHVzZXIncyBjdXJyZW50IHNpZ25pbiBzdGF0dXMuIFJldHVybnMgb2JqZWN0IHdpdGggc2Vzc2lvbl9zdGF0ZSBhbmQgc3ViamVjdCBpZGVudGlmaWVyLlxuICAgKi9cbiAgYXN5bmMgcXVlcnlTZXNzaW9uU3RhdHVzKGFyZ3MgPSB7fSkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwicXVlcnlTZXNzaW9uU3RhdHVzXCIpO1xuICAgIGNvbnN0IHtcbiAgICAgIHNpbGVudFJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzLFxuICAgICAgLi4ucmVxdWVzdEFyZ3NcbiAgICB9ID0gYXJncztcbiAgICBjb25zdCB1cmwgPSB0aGlzLnNldHRpbmdzLnNpbGVudF9yZWRpcmVjdF91cmk7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiTm8gc2lsZW50X3JlZGlyZWN0X3VyaSBjb25maWd1cmVkXCIpKTtcbiAgICB9XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMuX2xvYWRVc2VyKCk7XG4gICAgY29uc3QgaGFuZGxlID0gYXdhaXQgdGhpcy5faWZyYW1lTmF2aWdhdG9yLnByZXBhcmUoeyBzaWxlbnRSZXF1ZXN0VGltZW91dEluU2Vjb25kcyB9KTtcbiAgICBjb25zdCBuYXZSZXNwb25zZSA9IGF3YWl0IHRoaXMuX3NpZ25pblN0YXJ0KHtcbiAgICAgIHJlcXVlc3RfdHlwZTogXCJzaTpzXCIsXG4gICAgICAvLyB0aGlzIGFjdHMgbGlrZSBhIHNpZ25pbiBzaWxlbnRcbiAgICAgIHJlZGlyZWN0X3VyaTogdXJsLFxuICAgICAgcHJvbXB0OiBcIm5vbmVcIixcbiAgICAgIGlkX3Rva2VuX2hpbnQ6IHRoaXMuc2V0dGluZ3MuaW5jbHVkZUlkVG9rZW5JblNpbGVudFJlbmV3ID8gdXNlciA9PSBudWxsID8gdm9pZCAwIDogdXNlci5pZF90b2tlbiA6IHZvaWQgMCxcbiAgICAgIHJlc3BvbnNlX3R5cGU6IHRoaXMuc2V0dGluZ3MucXVlcnlfc3RhdHVzX3Jlc3BvbnNlX3R5cGUsXG4gICAgICBzY29wZTogXCJvcGVuaWRcIixcbiAgICAgIHNraXBVc2VySW5mbzogdHJ1ZSxcbiAgICAgIC4uLnJlcXVlc3RBcmdzXG4gICAgfSwgaGFuZGxlKTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2lnbmluUmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9jbGllbnQucHJvY2Vzc1NpZ25pblJlc3BvbnNlKG5hdlJlc3BvbnNlLnVybCk7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwiZ290IHNpZ25pbiByZXNwb25zZVwiKTtcbiAgICAgIGlmIChzaWduaW5SZXNwb25zZS5zZXNzaW9uX3N0YXRlICYmIHNpZ25pblJlc3BvbnNlLnByb2ZpbGUuc3ViKSB7XG4gICAgICAgIGxvZ2dlcjIuaW5mbyhcInN1Y2Nlc3MgZm9yIHN1YmplY3RcIiwgc2lnbmluUmVzcG9uc2UucHJvZmlsZS5zdWIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNlc3Npb25fc3RhdGU6IHNpZ25pblJlc3BvbnNlLnNlc3Npb25fc3RhdGUsXG4gICAgICAgICAgc3ViOiBzaWduaW5SZXNwb25zZS5wcm9maWxlLnN1YixcbiAgICAgICAgICBzaWQ6IHNpZ25pblJlc3BvbnNlLnByb2ZpbGUuc2lkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBsb2dnZXIyLmluZm8oXCJzdWNjZXNzLCB1c2VyIG5vdCBhdXRoZW50aWNhdGVkXCIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5tb25pdG9yQW5vbnltb3VzU2Vzc2lvbiAmJiBlcnIgaW5zdGFuY2VvZiBFcnJvclJlc3BvbnNlKSB7XG4gICAgICAgIHN3aXRjaCAoZXJyLmVycm9yKSB7XG4gICAgICAgICAgY2FzZSBcImxvZ2luX3JlcXVpcmVkXCI6XG4gICAgICAgICAgY2FzZSBcImNvbnNlbnRfcmVxdWlyZWRcIjpcbiAgICAgICAgICBjYXNlIFwiaW50ZXJhY3Rpb25fcmVxdWlyZWRcIjpcbiAgICAgICAgICBjYXNlIFwiYWNjb3VudF9zZWxlY3Rpb25fcmVxdWlyZWRcIjpcbiAgICAgICAgICAgIGxvZ2dlcjIuaW5mbyhcInN1Y2Nlc3MgZm9yIGFub255bW91cyB1c2VyXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgc2Vzc2lvbl9zdGF0ZTogZXJyLnNlc3Npb25fc3RhdGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgX3NpZ25pbihhcmdzLCBoYW5kbGUsIHZlcmlmeVN1Yikge1xuICAgIGNvbnN0IG5hdlJlc3BvbnNlID0gYXdhaXQgdGhpcy5fc2lnbmluU3RhcnQoYXJncywgaGFuZGxlKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fc2lnbmluRW5kKG5hdlJlc3BvbnNlLnVybCwgdmVyaWZ5U3ViKTtcbiAgfVxuICBhc3luYyBfc2lnbmluU3RhcnQoYXJncywgaGFuZGxlKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJfc2lnbmluU3RhcnRcIik7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNpZ25pblJlcXVlc3QgPSBhd2FpdCB0aGlzLl9jbGllbnQuY3JlYXRlU2lnbmluUmVxdWVzdChhcmdzKTtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJnb3Qgc2lnbmluIHJlcXVlc3RcIik7XG4gICAgICByZXR1cm4gYXdhaXQgaGFuZGxlLm5hdmlnYXRlKHtcbiAgICAgICAgdXJsOiBzaWduaW5SZXF1ZXN0LnVybCxcbiAgICAgICAgc3RhdGU6IHNpZ25pblJlcXVlc3Quc3RhdGUuaWQsXG4gICAgICAgIHJlc3BvbnNlX21vZGU6IHNpZ25pblJlcXVlc3Quc3RhdGUucmVzcG9uc2VfbW9kZSxcbiAgICAgICAgc2NyaXB0T3JpZ2luOiB0aGlzLnNldHRpbmdzLmlmcmFtZVNjcmlwdE9yaWdpblxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwiZXJyb3IgYWZ0ZXIgcHJlcGFyaW5nIG5hdmlnYXRvciwgY2xvc2luZyBuYXZpZ2F0b3Igd2luZG93XCIpO1xuICAgICAgaGFuZGxlLmNsb3NlKCk7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG4gIGFzeW5jIF9zaWduaW5FbmQodXJsLCB2ZXJpZnlTdWIpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIl9zaWduaW5FbmRcIik7XG4gICAgY29uc3Qgc2lnbmluUmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9jbGllbnQucHJvY2Vzc1NpZ25pblJlc3BvbnNlKHVybCk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcImdvdCBzaWduaW4gcmVzcG9uc2VcIik7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMuX2J1aWxkVXNlcihzaWduaW5SZXNwb25zZSwgdmVyaWZ5U3ViKTtcbiAgICByZXR1cm4gdXNlcjtcbiAgfVxuICBhc3luYyBfYnVpbGRVc2VyKHNpZ25pblJlc3BvbnNlLCB2ZXJpZnlTdWIpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIl9idWlsZFVzZXJcIik7XG4gICAgY29uc3QgdXNlciA9IG5ldyBVc2VyKHNpZ25pblJlc3BvbnNlKTtcbiAgICBpZiAodmVyaWZ5U3ViKSB7XG4gICAgICBpZiAodmVyaWZ5U3ViICE9PSB1c2VyLnByb2ZpbGUuc3ViKSB7XG4gICAgICAgIGxvZ2dlcjIuZGVidWcoXCJjdXJyZW50IHVzZXIgZG9lcyBub3QgbWF0Y2ggdXNlciByZXR1cm5lZCBmcm9tIHNpZ25pbi4gc3ViIGZyb20gc2lnbmluOlwiLCB1c2VyLnByb2ZpbGUuc3ViKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yUmVzcG9uc2UoeyAuLi5zaWduaW5SZXNwb25zZSwgZXJyb3I6IFwibG9naW5fcmVxdWlyZWRcIiB9KTtcbiAgICAgIH1cbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJjdXJyZW50IHVzZXIgbWF0Y2hlcyB1c2VyIHJldHVybmVkIGZyb20gc2lnbmluXCIpO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLnN0b3JlVXNlcih1c2VyKTtcbiAgICBsb2dnZXIyLmRlYnVnKFwidXNlciBzdG9yZWRcIik7XG4gICAgdGhpcy5fZXZlbnRzLmxvYWQodXNlcik7XG4gICAgcmV0dXJuIHVzZXI7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgcHJvbWlzZSB0byB0cmlnZ2VyIGEgcmVkaXJlY3Qgb2YgdGhlIGN1cnJlbnQgd2luZG93IHRvIHRoZSBlbmQgc2Vzc2lvbiBlbmRwb2ludC5cbiAgICovXG4gIGFzeW5jIHNpZ25vdXRSZWRpcmVjdChhcmdzID0ge30pIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInNpZ25vdXRSZWRpcmVjdFwiKTtcbiAgICBjb25zdCB7XG4gICAgICByZWRpcmVjdE1ldGhvZCxcbiAgICAgIC4uLnJlcXVlc3RBcmdzXG4gICAgfSA9IGFyZ3M7XG4gICAgY29uc3QgaGFuZGxlID0gYXdhaXQgdGhpcy5fcmVkaXJlY3ROYXZpZ2F0b3IucHJlcGFyZSh7IHJlZGlyZWN0TWV0aG9kIH0pO1xuICAgIGF3YWl0IHRoaXMuX3NpZ25vdXRTdGFydCh7XG4gICAgICByZXF1ZXN0X3R5cGU6IFwic286clwiLFxuICAgICAgcG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpOiB0aGlzLnNldHRpbmdzLnBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSxcbiAgICAgIC4uLnJlcXVlc3RBcmdzXG4gICAgfSwgaGFuZGxlKTtcbiAgICBsb2dnZXIyLmluZm8oXCJzdWNjZXNzXCIpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHByb21pc2UgdG8gcHJvY2VzcyByZXNwb25zZSBmcm9tIHRoZSBlbmQgc2Vzc2lvbiBlbmRwb2ludC5cbiAgICovXG4gIGFzeW5jIHNpZ25vdXRSZWRpcmVjdENhbGxiYWNrKHVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJzaWdub3V0UmVkaXJlY3RDYWxsYmFja1wiKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX3NpZ25vdXRFbmQodXJsKTtcbiAgICBsb2dnZXIyLmluZm8oXCJzdWNjZXNzXCIpO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBwcm9taXNlIHRvIHRyaWdnZXIgYSByZWRpcmVjdCBvZiBhIHBvcHVwIHdpbmRvdyB3aW5kb3cgdG8gdGhlIGVuZCBzZXNzaW9uIGVuZHBvaW50LlxuICAgKi9cbiAgYXN5bmMgc2lnbm91dFBvcHVwKGFyZ3MgPSB7fSkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwic2lnbm91dFBvcHVwXCIpO1xuICAgIGNvbnN0IHtcbiAgICAgIHBvcHVwV2luZG93RmVhdHVyZXMsXG4gICAgICBwb3B1cFdpbmRvd1RhcmdldCxcbiAgICAgIC4uLnJlcXVlc3RBcmdzXG4gICAgfSA9IGFyZ3M7XG4gICAgY29uc3QgdXJsID0gdGhpcy5zZXR0aW5ncy5wb3B1cF9wb3N0X2xvZ291dF9yZWRpcmVjdF91cmk7XG4gICAgY29uc3QgaGFuZGxlID0gYXdhaXQgdGhpcy5fcG9wdXBOYXZpZ2F0b3IucHJlcGFyZSh7IHBvcHVwV2luZG93RmVhdHVyZXMsIHBvcHVwV2luZG93VGFyZ2V0IH0pO1xuICAgIGF3YWl0IHRoaXMuX3NpZ25vdXQoe1xuICAgICAgcmVxdWVzdF90eXBlOiBcInNvOnBcIixcbiAgICAgIHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaTogdXJsLFxuICAgICAgLy8gd2UncmUgcHV0dGluZyBhIGR1bW15IGVudHJ5IGluIGhlcmUgYmVjYXVzZSB3ZVxuICAgICAgLy8gbmVlZCBhIHVuaXF1ZSBpZCBmcm9tIHRoZSBzdGF0ZSBmb3Igbm90aWZpY2F0aW9uXG4gICAgICAvLyB0byB0aGUgcGFyZW50IHdpbmRvdywgd2hpY2ggaXMgbmVjZXNzYXJ5IGlmIHdlXG4gICAgICAvLyBwbGFuIHRvIHJldHVybiBiYWNrIHRvIHRoZSBjbGllbnQgYWZ0ZXIgc2lnbm91dFxuICAgICAgLy8gYW5kIHNvIHdlIGNhbiBjbG9zZSB0aGUgcG9wdXAgYWZ0ZXIgc2lnbm91dFxuICAgICAgc3RhdGU6IHVybCA9PSBudWxsID8gdm9pZCAwIDoge30sXG4gICAgICAuLi5yZXF1ZXN0QXJnc1xuICAgIH0sIGhhbmRsZSk7XG4gICAgbG9nZ2VyMi5pbmZvKFwic3VjY2Vzc1wiKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBwcm9taXNlIHRvIHByb2Nlc3MgcmVzcG9uc2UgZnJvbSB0aGUgZW5kIHNlc3Npb24gZW5kcG9pbnQgZnJvbSBhIHBvcHVwIHdpbmRvdy5cbiAgICovXG4gIGFzeW5jIHNpZ25vdXRQb3B1cENhbGxiYWNrKHVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLCBrZWVwT3BlbiA9IGZhbHNlKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJzaWdub3V0UG9wdXBDYWxsYmFja1wiKTtcbiAgICBhd2FpdCB0aGlzLl9wb3B1cE5hdmlnYXRvci5jYWxsYmFjayh1cmwsIHsga2VlcE9wZW4gfSk7XG4gICAgbG9nZ2VyMi5pbmZvKFwic3VjY2Vzc1wiKTtcbiAgfVxuICBhc3luYyBfc2lnbm91dChhcmdzLCBoYW5kbGUpIHtcbiAgICBjb25zdCBuYXZSZXNwb25zZSA9IGF3YWl0IHRoaXMuX3NpZ25vdXRTdGFydChhcmdzLCBoYW5kbGUpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl9zaWdub3V0RW5kKG5hdlJlc3BvbnNlLnVybCk7XG4gIH1cbiAgYXN5bmMgX3NpZ25vdXRTdGFydChhcmdzID0ge30sIGhhbmRsZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIl9zaWdub3V0U3RhcnRcIik7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLl9sb2FkVXNlcigpO1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcImxvYWRlZCBjdXJyZW50IHVzZXIgZnJvbSBzdG9yYWdlXCIpO1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MucmV2b2tlVG9rZW5zT25TaWdub3V0KSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3Jldm9rZUludGVybmFsKHVzZXIpO1xuICAgICAgfVxuICAgICAgY29uc3QgaWRfdG9rZW4gPSBhcmdzLmlkX3Rva2VuX2hpbnQgfHwgdXNlciAmJiB1c2VyLmlkX3Rva2VuO1xuICAgICAgaWYgKGlkX3Rva2VuKSB7XG4gICAgICAgIGxvZ2dlcjIuZGVidWcoXCJzZXR0aW5nIGlkX3Rva2VuX2hpbnQgaW4gc2lnbm91dCByZXF1ZXN0XCIpO1xuICAgICAgICBhcmdzLmlkX3Rva2VuX2hpbnQgPSBpZF90b2tlbjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMucmVtb3ZlVXNlcigpO1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcInVzZXIgcmVtb3ZlZCwgY3JlYXRpbmcgc2lnbm91dCByZXF1ZXN0XCIpO1xuICAgICAgY29uc3Qgc2lnbm91dFJlcXVlc3QgPSBhd2FpdCB0aGlzLl9jbGllbnQuY3JlYXRlU2lnbm91dFJlcXVlc3QoYXJncyk7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwiZ290IHNpZ25vdXQgcmVxdWVzdFwiKTtcbiAgICAgIHJldHVybiBhd2FpdCBoYW5kbGUubmF2aWdhdGUoe1xuICAgICAgICB1cmw6IHNpZ25vdXRSZXF1ZXN0LnVybCxcbiAgICAgICAgc3RhdGU6IChfYSA9IHNpZ25vdXRSZXF1ZXN0LnN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaWQsXG4gICAgICAgIHNjcmlwdE9yaWdpbjogdGhpcy5zZXR0aW5ncy5pZnJhbWVTY3JpcHRPcmlnaW5cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcImVycm9yIGFmdGVyIHByZXBhcmluZyBuYXZpZ2F0b3IsIGNsb3NpbmcgbmF2aWdhdG9yIHdpbmRvd1wiKTtcbiAgICAgIGhhbmRsZS5jbG9zZSgpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuICBhc3luYyBfc2lnbm91dEVuZCh1cmwpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIl9zaWdub3V0RW5kXCIpO1xuICAgIGNvbnN0IHNpZ25vdXRSZXNwb25zZSA9IGF3YWl0IHRoaXMuX2NsaWVudC5wcm9jZXNzU2lnbm91dFJlc3BvbnNlKHVybCk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcImdvdCBzaWdub3V0IHJlc3BvbnNlXCIpO1xuICAgIHJldHVybiBzaWdub3V0UmVzcG9uc2U7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgcHJvbWlzZSB0byB0cmlnZ2VyIGEgc2lsZW50IHJlcXVlc3QgKHZpYSBhbiBpZnJhbWUpIHRvIHRoZSBlbmQgc2Vzc2lvbiBlbmRwb2ludC5cbiAgICovXG4gIGFzeW5jIHNpZ25vdXRTaWxlbnQoYXJncyA9IHt9KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwic2lnbm91dFNpbGVudFwiKTtcbiAgICBjb25zdCB7XG4gICAgICBzaWxlbnRSZXF1ZXN0VGltZW91dEluU2Vjb25kcyxcbiAgICAgIC4uLnJlcXVlc3RBcmdzXG4gICAgfSA9IGFyZ3M7XG4gICAgY29uc3QgaWRfdG9rZW5faGludCA9IHRoaXMuc2V0dGluZ3MuaW5jbHVkZUlkVG9rZW5JblNpbGVudFNpZ25vdXQgPyAoX2EgPSBhd2FpdCB0aGlzLl9sb2FkVXNlcigpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaWRfdG9rZW4gOiB2b2lkIDA7XG4gICAgY29uc3QgdXJsID0gdGhpcy5zZXR0aW5ncy5wb3B1cF9wb3N0X2xvZ291dF9yZWRpcmVjdF91cmk7XG4gICAgY29uc3QgaGFuZGxlID0gYXdhaXQgdGhpcy5faWZyYW1lTmF2aWdhdG9yLnByZXBhcmUoeyBzaWxlbnRSZXF1ZXN0VGltZW91dEluU2Vjb25kcyB9KTtcbiAgICBhd2FpdCB0aGlzLl9zaWdub3V0KHtcbiAgICAgIHJlcXVlc3RfdHlwZTogXCJzbzpzXCIsXG4gICAgICBwb3N0X2xvZ291dF9yZWRpcmVjdF91cmk6IHVybCxcbiAgICAgIGlkX3Rva2VuX2hpbnQsXG4gICAgICAuLi5yZXF1ZXN0QXJnc1xuICAgIH0sIGhhbmRsZSk7XG4gICAgbG9nZ2VyMi5pbmZvKFwic3VjY2Vzc1wiKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBwcm9taXNlIHRvIG5vdGlmeSB0aGUgcGFyZW50IHdpbmRvdyBvZiByZXNwb25zZSBmcm9tIHRoZSBlbmQgc2Vzc2lvbiBlbmRwb2ludC5cbiAgICovXG4gIGFzeW5jIHNpZ25vdXRTaWxlbnRDYWxsYmFjayh1cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZikge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwic2lnbm91dFNpbGVudENhbGxiYWNrXCIpO1xuICAgIGF3YWl0IHRoaXMuX2lmcmFtZU5hdmlnYXRvci5jYWxsYmFjayh1cmwpO1xuICAgIGxvZ2dlcjIuaW5mbyhcInN1Y2Nlc3NcIik7XG4gIH1cbiAgYXN5bmMgcmV2b2tlVG9rZW5zKHR5cGVzKSB7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMuX2xvYWRVc2VyKCk7XG4gICAgYXdhaXQgdGhpcy5fcmV2b2tlSW50ZXJuYWwodXNlciwgdHlwZXMpO1xuICB9XG4gIGFzeW5jIF9yZXZva2VJbnRlcm5hbCh1c2VyLCB0eXBlcyA9IHRoaXMuc2V0dGluZ3MucmV2b2tlVG9rZW5UeXBlcykge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiX3Jldm9rZUludGVybmFsXCIpO1xuICAgIGlmICghdXNlcilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0eXBlc1ByZXNlbnQgPSB0eXBlcy5maWx0ZXIoKHR5cGUpID0+IHR5cGVvZiB1c2VyW3R5cGVdID09PSBcInN0cmluZ1wiKTtcbiAgICBpZiAoIXR5cGVzUHJlc2VudC5sZW5ndGgpIHtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJubyBuZWVkIHRvIHJldm9rZSBkdWUgdG8gbm8gdG9rZW4ocylcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgdHlwZSBvZiB0eXBlc1ByZXNlbnQpIHtcbiAgICAgIGF3YWl0IHRoaXMuX2NsaWVudC5yZXZva2VUb2tlbihcbiAgICAgICAgdXNlclt0eXBlXSxcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIHR5cGVcbiAgICAgICk7XG4gICAgICBsb2dnZXIyLmluZm8oYCR7dHlwZX0gcmV2b2tlZCBzdWNjZXNzZnVsbHlgKTtcbiAgICAgIGlmICh0eXBlICE9PSBcImFjY2Vzc190b2tlblwiKSB7XG4gICAgICAgIHVzZXJbdHlwZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBhd2FpdCB0aGlzLnN0b3JlVXNlcih1c2VyKTtcbiAgICBsb2dnZXIyLmRlYnVnKFwidXNlciBzdG9yZWRcIik7XG4gICAgdGhpcy5fZXZlbnRzLmxvYWQodXNlcik7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgc2lsZW50IHJlbmV3IGZvciB0aGUgYFVzZXJNYW5hZ2VyYC5cbiAgICovXG4gIHN0YXJ0U2lsZW50UmVuZXcoKSB7XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInN0YXJ0U2lsZW50UmVuZXdcIik7XG4gICAgdm9pZCB0aGlzLl9zaWxlbnRSZW5ld1NlcnZpY2Uuc3RhcnQoKTtcbiAgfVxuICAvKipcbiAgICogRGlzYWJsZXMgc2lsZW50IHJlbmV3IGZvciB0aGUgYFVzZXJNYW5hZ2VyYC5cbiAgICovXG4gIHN0b3BTaWxlbnRSZW5ldygpIHtcbiAgICB0aGlzLl9zaWxlbnRSZW5ld1NlcnZpY2Uuc3RvcCgpO1xuICB9XG4gIGdldCBfdXNlclN0b3JlS2V5KCkge1xuICAgIHJldHVybiBgdXNlcjoke3RoaXMuc2V0dGluZ3MuYXV0aG9yaXR5fToke3RoaXMuc2V0dGluZ3MuY2xpZW50X2lkfWA7XG4gIH1cbiAgYXN5bmMgX2xvYWRVc2VyKCkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiX2xvYWRVc2VyXCIpO1xuICAgIGNvbnN0IHN0b3JhZ2VTdHJpbmcgPSBhd2FpdCB0aGlzLnNldHRpbmdzLnVzZXJTdG9yZS5nZXQodGhpcy5fdXNlclN0b3JlS2V5KTtcbiAgICBpZiAoc3RvcmFnZVN0cmluZykge1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcInVzZXIgc3RvcmFnZVN0cmluZyBsb2FkZWRcIik7XG4gICAgICByZXR1cm4gVXNlci5mcm9tU3RvcmFnZVN0cmluZyhzdG9yYWdlU3RyaW5nKTtcbiAgICB9XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcIm5vIHVzZXIgc3RvcmFnZVN0cmluZ1wiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBhc3luYyBzdG9yZVVzZXIodXNlcikge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwic3RvcmVVc2VyXCIpO1xuICAgIGlmICh1c2VyKSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwic3RvcmluZyB1c2VyXCIpO1xuICAgICAgY29uc3Qgc3RvcmFnZVN0cmluZyA9IHVzZXIudG9TdG9yYWdlU3RyaW5nKCk7XG4gICAgICBhd2FpdCB0aGlzLnNldHRpbmdzLnVzZXJTdG9yZS5zZXQodGhpcy5fdXNlclN0b3JlS2V5LCBzdG9yYWdlU3RyaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwicmVtb3ZpbmcgdXNlclwiKTtcbiAgICAgIGF3YWl0IHRoaXMuc2V0dGluZ3MudXNlclN0b3JlLnJlbW92ZSh0aGlzLl91c2VyU3RvcmVLZXkpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBzdGFsZSBzdGF0ZSBlbnRyaWVzIGluIHN0b3JhZ2UgZm9yIGluY29tcGxldGUgYXV0aG9yaXplIHJlcXVlc3RzLlxuICAgKi9cbiAgYXN5bmMgY2xlYXJTdGFsZVN0YXRlKCkge1xuICAgIGF3YWl0IHRoaXMuX2NsaWVudC5jbGVhclN0YWxlU3RhdGUoKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZS5qc29uXG52YXIgdmVyc2lvbiA9IFwiMi40LjFcIjtcblxuLy8gc3JjL1ZlcnNpb24udHNcbnZhciBWZXJzaW9uID0gdmVyc2lvbjtcbmV4cG9ydCB7XG4gIEFjY2Vzc1Rva2VuRXZlbnRzLFxuICBDaGVja1Nlc3Npb25JRnJhbWUsXG4gIEVycm9yUmVzcG9uc2UsXG4gIEVycm9yVGltZW91dCxcbiAgSW5NZW1vcnlXZWJTdG9yYWdlLFxuICBMb2csXG4gIExvZ2dlcixcbiAgTWV0YWRhdGFTZXJ2aWNlLFxuICBPaWRjQ2xpZW50LFxuICBPaWRjQ2xpZW50U2V0dGluZ3NTdG9yZSxcbiAgU2Vzc2lvbk1vbml0b3IsXG4gIFNpZ25pblJlc3BvbnNlLFxuICBTaWduaW5TdGF0ZSxcbiAgU2lnbm91dFJlc3BvbnNlLFxuICBTdGF0ZSxcbiAgVXNlcixcbiAgVXNlck1hbmFnZXIsXG4gIFVzZXJNYW5hZ2VyU2V0dGluZ3NTdG9yZSxcbiAgVmVyc2lvbixcbiAgV2ViU3RvcmFnZVN0YXRlU3RvcmVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vaWRjLWNsaWVudC10cy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/oidc-client-ts/dist/esm/oidc-client-ts.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-oidc-context/dist/esm/react-oidc-context.js":
/*!************************************************************************!*\
  !*** ./node_modules/react-oidc-context/dist/esm/react-oidc-context.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthContext: () => (/* binding */ AuthContext),\n/* harmony export */   AuthProvider: () => (/* binding */ AuthProvider),\n/* harmony export */   hasAuthParams: () => (/* binding */ hasAuthParams),\n/* harmony export */   useAuth: () => (/* binding */ useAuth),\n/* harmony export */   withAuth: () => (/* binding */ withAuth),\n/* harmony export */   withAuthenticationRequired: () => (/* binding */ withAuthenticationRequired)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var oidc_client_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! oidc-client-ts */ \"(app-pages-browser)/./node_modules/oidc-client-ts/dist/esm/oidc-client-ts.js\");\n// src/AuthContext.ts\n\nvar AuthContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);\nAuthContext.displayName = \"AuthContext\";\n\n// src/AuthProvider.tsx\n\n\n\n// src/AuthState.ts\nvar initialAuthState = {\n  isLoading: true,\n  isAuthenticated: false\n};\n\n// src/reducer.ts\nvar reducer = (state, action) => {\n  switch (action.type) {\n    case \"INITIALISED\":\n    case \"USER_LOADED\":\n      return {\n        ...state,\n        user: action.user,\n        isLoading: false,\n        isAuthenticated: action.user ? !action.user.expired : false,\n        error: void 0\n      };\n    case \"USER_SIGNED_OUT\":\n    case \"USER_UNLOADED\":\n      return {\n        ...state,\n        user: void 0,\n        isAuthenticated: false\n      };\n    case \"NAVIGATOR_INIT\":\n      return {\n        ...state,\n        isLoading: true,\n        activeNavigator: action.method\n      };\n    case \"NAVIGATOR_CLOSE\":\n      return {\n        ...state,\n        isLoading: false,\n        activeNavigator: void 0\n      };\n    case \"ERROR\":\n      return {\n        ...state,\n        isLoading: false,\n        error: action.error\n      };\n    default:\n      return {\n        ...state,\n        isLoading: false,\n        error: new Error(`unknown type ${action[\"type\"]}`)\n      };\n  }\n};\n\n// src/utils.ts\nvar hasAuthParams = (location = window.location) => {\n  let searchParams = new URLSearchParams(location.search);\n  if ((searchParams.get(\"code\") || searchParams.get(\"error\")) && searchParams.get(\"state\")) {\n    return true;\n  }\n  searchParams = new URLSearchParams(location.hash.replace(\"#\", \"?\"));\n  if ((searchParams.get(\"code\") || searchParams.get(\"error\")) && searchParams.get(\"state\")) {\n    return true;\n  }\n  return false;\n};\nvar normalizeErrorFn = (fallbackMessage) => (error) => {\n  if (error instanceof Error) {\n    return error;\n  }\n  return new Error(fallbackMessage);\n};\nvar loginError = normalizeErrorFn(\"Login failed\");\nvar signoutError = normalizeErrorFn(\"Sign-out failed\");\n\n// src/AuthProvider.tsx\nvar userManagerContextKeys = [\n  \"clearStaleState\",\n  \"querySessionStatus\",\n  \"revokeTokens\",\n  \"startSilentRenew\",\n  \"stopSilentRenew\"\n];\nvar navigatorKeys = [\n  \"signinPopup\",\n  \"signinSilent\",\n  \"signinRedirect\",\n  \"signinResourceOwnerCredentials\",\n  \"signoutPopup\",\n  \"signoutRedirect\",\n  \"signoutSilent\"\n];\nvar unsupportedEnvironment = (fnName) => () => {\n  throw new Error(\n    `UserManager#${fnName} was called from an unsupported context. If this is a server-rendered page, defer this call with useEffect() or pass a custom UserManager implementation.`\n  );\n};\nvar defaultUserManagerImpl = typeof window === \"undefined\" ? null : oidc_client_ts__WEBPACK_IMPORTED_MODULE_1__.UserManager;\nvar AuthProvider = (props) => {\n  const {\n    children,\n    onSigninCallback,\n    skipSigninCallback,\n    matchSignoutCallback,\n    onSignoutCallback,\n    onRemoveUser,\n    onSignoutRedirect,\n    onSignoutPopup,\n    implementation: UserManagerImpl = defaultUserManagerImpl,\n    userManager: userManagerProp,\n    ...userManagerSettings\n  } = props;\n  const [userManager] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => {\n    return userManagerProp != null ? userManagerProp : UserManagerImpl ? new UserManagerImpl(userManagerSettings) : { settings: userManagerSettings };\n  });\n  const [state, dispatch] = react__WEBPACK_IMPORTED_MODULE_0__.useReducer(reducer, initialAuthState);\n  const userManagerContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => Object.assign(\n      {\n        settings: userManager.settings,\n        events: userManager.events\n      },\n      Object.fromEntries(\n        userManagerContextKeys.map((key) => {\n          var _a, _b;\n          return [\n            key,\n            (_b = (_a = userManager[key]) == null ? void 0 : _a.bind(userManager)) != null ? _b : unsupportedEnvironment(key)\n          ];\n        })\n      ),\n      Object.fromEntries(\n        navigatorKeys.map((key) => [\n          key,\n          userManager[key] ? async (args) => {\n            dispatch({\n              type: \"NAVIGATOR_INIT\",\n              method: key\n            });\n            try {\n              return await userManager[key](args);\n            } catch (error) {\n              dispatch({ type: \"ERROR\", error });\n              return null;\n            } finally {\n              dispatch({ type: \"NAVIGATOR_CLOSE\" });\n            }\n          } : unsupportedEnvironment(key)\n        ])\n      )\n    ),\n    [userManager]\n  );\n  const didInitialize = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!userManager || didInitialize.current) {\n      return;\n    }\n    didInitialize.current = true;\n    void (async () => {\n      let user = null;\n      try {\n        if (hasAuthParams() && !skipSigninCallback) {\n          user = await userManager.signinCallback();\n          onSigninCallback && await onSigninCallback(user);\n        }\n        user = !user ? await userManager.getUser() : user;\n        dispatch({ type: \"INITIALISED\", user });\n      } catch (error) {\n        dispatch({ type: \"ERROR\", error: loginError(error) });\n      }\n      try {\n        if (matchSignoutCallback && matchSignoutCallback(userManager.settings)) {\n          const resp = await userManager.signoutCallback();\n          onSignoutCallback && await onSignoutCallback(resp);\n        }\n      } catch (error) {\n        dispatch({ type: \"ERROR\", error: signoutError(error) });\n      }\n    })();\n  }, [userManager, skipSigninCallback, onSigninCallback, onSignoutCallback, matchSignoutCallback]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!userManager)\n      return void 0;\n    const handleUserLoaded = (user) => {\n      dispatch({ type: \"USER_LOADED\", user });\n    };\n    userManager.events.addUserLoaded(handleUserLoaded);\n    const handleUserUnloaded = () => {\n      dispatch({ type: \"USER_UNLOADED\" });\n    };\n    userManager.events.addUserUnloaded(handleUserUnloaded);\n    const handleUserSignedOut = () => {\n      dispatch({ type: \"USER_SIGNED_OUT\" });\n    };\n    userManager.events.addUserSignedOut(handleUserSignedOut);\n    const handleSilentRenewError = (error) => {\n      dispatch({ type: \"ERROR\", error });\n    };\n    userManager.events.addSilentRenewError(handleSilentRenewError);\n    return () => {\n      userManager.events.removeUserLoaded(handleUserLoaded);\n      userManager.events.removeUserUnloaded(handleUserUnloaded);\n      userManager.events.removeUserSignedOut(handleUserSignedOut);\n      userManager.events.removeSilentRenewError(handleSilentRenewError);\n    };\n  }, [userManager]);\n  const removeUser = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    userManager ? () => userManager.removeUser().then(onRemoveUser) : unsupportedEnvironment(\"removeUser\"),\n    [userManager, onRemoveUser]\n  );\n  const signoutRedirect = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (args) => userManagerContext.signoutRedirect(args).then(onSignoutRedirect),\n    [userManagerContext.signoutRedirect, onSignoutRedirect]\n  );\n  const signoutPopup = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (args) => userManagerContext.signoutPopup(args).then(onSignoutPopup),\n    [userManagerContext.signoutPopup, onSignoutPopup]\n  );\n  const signoutSilent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (args) => userManagerContext.signoutSilent(args),\n    [userManagerContext.signoutSilent]\n  );\n  const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    return {\n      ...state,\n      ...userManagerContext,\n      removeUser,\n      signoutRedirect,\n      signoutPopup,\n      signoutSilent\n    };\n  }, [state, userManagerContext, removeUser]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AuthContext.Provider, { value: contextValue }, children);\n};\n\n// src/useAuth.ts\n\nvar useAuth = () => {\n  const context = react__WEBPACK_IMPORTED_MODULE_0__.useContext(AuthContext);\n  if (!context) {\n    console.warn(\"AuthProvider context is undefined, please verify you are calling useAuth() as child of a <AuthProvider> component.\");\n  }\n  return context;\n};\n\n// src/withAuth.tsx\n\nfunction withAuth(Component) {\n  const displayName = `withAuth(${Component.displayName || Component.name})`;\n  const C = (props) => {\n    const auth = useAuth();\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, { ...props, auth });\n  };\n  C.displayName = displayName;\n  return C;\n}\n\n// src/withAuthenticationRequired.tsx\n\nvar withAuthenticationRequired = (Component, options = {}) => {\n  const { OnRedirecting = () => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null), onBeforeSignin, signinRedirectArgs } = options;\n  const displayName = `withAuthenticationRequired(${Component.displayName || Component.name})`;\n  const C = (props) => {\n    const auth = useAuth();\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n      if (hasAuthParams() || auth.isLoading || auth.activeNavigator || auth.isAuthenticated) {\n        return;\n      }\n      void (async () => {\n        onBeforeSignin && await onBeforeSignin();\n        await auth.signinRedirect(signinRedirectArgs);\n      })();\n    }, [auth.isLoading, auth.isAuthenticated, auth]);\n    return auth.isAuthenticated ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, { ...props }) : OnRedirecting();\n  };\n  C.displayName = displayName;\n  return C;\n};\n\n//# sourceMappingURL=react-oidc-context.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1vaWRjLWNvbnRleHQvZGlzdC9lc20vcmVhY3Qtb2lkYy1jb250ZXh0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDMEI7QUFDMUIsa0JBQWtCLGdEQUFtQjtBQUNyQzs7QUFFQTtBQUMyQjtBQUNrQjs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGVBQWU7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0Esb0VBQW9FLHVEQUFXO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHdCQUF3QiwyQ0FBZTtBQUN2QyxzSEFBc0g7QUFDdEgsR0FBRztBQUNILDRCQUE0Qiw2Q0FBaUI7QUFDN0MsNkJBQTZCLDBDQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWM7QUFDZCx5QkFBeUIsc0JBQXNCO0FBQy9DO0FBQ0EsY0FBYztBQUNkLHlCQUF5Qix5QkFBeUI7QUFDbEQ7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5Q0FBYTtBQUNyQyxFQUFFLDRDQUFnQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDLFFBQVE7QUFDUixtQkFBbUIseUNBQXlDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixtQkFBbUIsMkNBQTJDO0FBQzlEO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxFQUFFLDRDQUFnQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gscUJBQXFCLDhDQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOENBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4Q0FBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhDQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMENBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx5QkFBeUIsZ0RBQW9CLHlCQUF5QixxQkFBcUI7QUFDM0Y7O0FBRUE7QUFDMkI7QUFDM0I7QUFDQSxrQkFBa0IsNkNBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDMkI7QUFDM0I7QUFDQSxrQ0FBa0Msd0NBQXdDO0FBQzFFO0FBQ0E7QUFDQSwyQkFBMkIsZ0RBQW9CLGNBQWMsZ0JBQWdCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzJCO0FBQzNCLHlEQUF5RDtBQUN6RCxVQUFVLHNDQUFzQyxnREFBb0IsQ0FBQywyQ0FBZSw4Q0FBOEM7QUFDbEksb0RBQW9ELHdDQUF3QztBQUM1RjtBQUNBO0FBQ0EsSUFBSSw0Q0FBZ0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxrREFBa0QsZ0RBQW9CLGNBQWMsVUFBVTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQVFFO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxUV0UgR0tFXFx0b3Vyd2l0aGVhc2UtZ2tlLWhhY2thdGhvblxcZnJvbnRlbmRcXG15LWFwcFxcbm9kZV9tb2R1bGVzXFxyZWFjdC1vaWRjLWNvbnRleHRcXGRpc3RcXGVzbVxccmVhY3Qtb2lkYy1jb250ZXh0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9BdXRoQ29udGV4dC50c1xuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xudmFyIEF1dGhDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh2b2lkIDApO1xuQXV0aENvbnRleHQuZGlzcGxheU5hbWUgPSBcIkF1dGhDb250ZXh0XCI7XG5cbi8vIHNyYy9BdXRoUHJvdmlkZXIudHN4XG5pbXBvcnQgUmVhY3QyIGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgVXNlck1hbmFnZXIgfSBmcm9tIFwib2lkYy1jbGllbnQtdHNcIjtcblxuLy8gc3JjL0F1dGhTdGF0ZS50c1xudmFyIGluaXRpYWxBdXRoU3RhdGUgPSB7XG4gIGlzTG9hZGluZzogdHJ1ZSxcbiAgaXNBdXRoZW50aWNhdGVkOiBmYWxzZVxufTtcblxuLy8gc3JjL3JlZHVjZXIudHNcbnZhciByZWR1Y2VyID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgXCJJTklUSUFMSVNFRFwiOlxuICAgIGNhc2UgXCJVU0VSX0xPQURFRFwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIHVzZXI6IGFjdGlvbi51c2VyLFxuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICBpc0F1dGhlbnRpY2F0ZWQ6IGFjdGlvbi51c2VyID8gIWFjdGlvbi51c2VyLmV4cGlyZWQgOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IHZvaWQgMFxuICAgICAgfTtcbiAgICBjYXNlIFwiVVNFUl9TSUdORURfT1VUXCI6XG4gICAgY2FzZSBcIlVTRVJfVU5MT0FERURcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICB1c2VyOiB2b2lkIDAsXG4gICAgICAgIGlzQXV0aGVudGljYXRlZDogZmFsc2VcbiAgICAgIH07XG4gICAgY2FzZSBcIk5BVklHQVRPUl9JTklUXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgaXNMb2FkaW5nOiB0cnVlLFxuICAgICAgICBhY3RpdmVOYXZpZ2F0b3I6IGFjdGlvbi5tZXRob2RcbiAgICAgIH07XG4gICAgY2FzZSBcIk5BVklHQVRPUl9DTE9TRVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgIGFjdGl2ZU5hdmlnYXRvcjogdm9pZCAwXG4gICAgICB9O1xuICAgIGNhc2UgXCJFUlJPUlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgIGVycm9yOiBhY3Rpb24uZXJyb3JcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICBlcnJvcjogbmV3IEVycm9yKGB1bmtub3duIHR5cGUgJHthY3Rpb25bXCJ0eXBlXCJdfWApXG4gICAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMudHNcbnZhciBoYXNBdXRoUGFyYW1zID0gKGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uKSA9PiB7XG4gIGxldCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKGxvY2F0aW9uLnNlYXJjaCk7XG4gIGlmICgoc2VhcmNoUGFyYW1zLmdldChcImNvZGVcIikgfHwgc2VhcmNoUGFyYW1zLmdldChcImVycm9yXCIpKSAmJiBzZWFyY2hQYXJhbXMuZ2V0KFwic3RhdGVcIikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKGxvY2F0aW9uLmhhc2gucmVwbGFjZShcIiNcIiwgXCI/XCIpKTtcbiAgaWYgKChzZWFyY2hQYXJhbXMuZ2V0KFwiY29kZVwiKSB8fCBzZWFyY2hQYXJhbXMuZ2V0KFwiZXJyb3JcIikpICYmIHNlYXJjaFBhcmFtcy5nZXQoXCJzdGF0ZVwiKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG52YXIgbm9ybWFsaXplRXJyb3JGbiA9IChmYWxsYmFja01lc3NhZ2UpID0+IChlcnJvcikgPT4ge1xuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICByZXR1cm4gbmV3IEVycm9yKGZhbGxiYWNrTWVzc2FnZSk7XG59O1xudmFyIGxvZ2luRXJyb3IgPSBub3JtYWxpemVFcnJvckZuKFwiTG9naW4gZmFpbGVkXCIpO1xudmFyIHNpZ25vdXRFcnJvciA9IG5vcm1hbGl6ZUVycm9yRm4oXCJTaWduLW91dCBmYWlsZWRcIik7XG5cbi8vIHNyYy9BdXRoUHJvdmlkZXIudHN4XG52YXIgdXNlck1hbmFnZXJDb250ZXh0S2V5cyA9IFtcbiAgXCJjbGVhclN0YWxlU3RhdGVcIixcbiAgXCJxdWVyeVNlc3Npb25TdGF0dXNcIixcbiAgXCJyZXZva2VUb2tlbnNcIixcbiAgXCJzdGFydFNpbGVudFJlbmV3XCIsXG4gIFwic3RvcFNpbGVudFJlbmV3XCJcbl07XG52YXIgbmF2aWdhdG9yS2V5cyA9IFtcbiAgXCJzaWduaW5Qb3B1cFwiLFxuICBcInNpZ25pblNpbGVudFwiLFxuICBcInNpZ25pblJlZGlyZWN0XCIsXG4gIFwic2lnbmluUmVzb3VyY2VPd25lckNyZWRlbnRpYWxzXCIsXG4gIFwic2lnbm91dFBvcHVwXCIsXG4gIFwic2lnbm91dFJlZGlyZWN0XCIsXG4gIFwic2lnbm91dFNpbGVudFwiXG5dO1xudmFyIHVuc3VwcG9ydGVkRW52aXJvbm1lbnQgPSAoZm5OYW1lKSA9PiAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICBgVXNlck1hbmFnZXIjJHtmbk5hbWV9IHdhcyBjYWxsZWQgZnJvbSBhbiB1bnN1cHBvcnRlZCBjb250ZXh0LiBJZiB0aGlzIGlzIGEgc2VydmVyLXJlbmRlcmVkIHBhZ2UsIGRlZmVyIHRoaXMgY2FsbCB3aXRoIHVzZUVmZmVjdCgpIG9yIHBhc3MgYSBjdXN0b20gVXNlck1hbmFnZXIgaW1wbGVtZW50YXRpb24uYFxuICApO1xufTtcbnZhciBkZWZhdWx0VXNlck1hbmFnZXJJbXBsID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IG51bGwgOiBVc2VyTWFuYWdlcjtcbnZhciBBdXRoUHJvdmlkZXIgPSAocHJvcHMpID0+IHtcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuLFxuICAgIG9uU2lnbmluQ2FsbGJhY2ssXG4gICAgc2tpcFNpZ25pbkNhbGxiYWNrLFxuICAgIG1hdGNoU2lnbm91dENhbGxiYWNrLFxuICAgIG9uU2lnbm91dENhbGxiYWNrLFxuICAgIG9uUmVtb3ZlVXNlcixcbiAgICBvblNpZ25vdXRSZWRpcmVjdCxcbiAgICBvblNpZ25vdXRQb3B1cCxcbiAgICBpbXBsZW1lbnRhdGlvbjogVXNlck1hbmFnZXJJbXBsID0gZGVmYXVsdFVzZXJNYW5hZ2VySW1wbCxcbiAgICB1c2VyTWFuYWdlcjogdXNlck1hbmFnZXJQcm9wLFxuICAgIC4uLnVzZXJNYW5hZ2VyU2V0dGluZ3NcbiAgfSA9IHByb3BzO1xuICBjb25zdCBbdXNlck1hbmFnZXJdID0gUmVhY3QyLnVzZVN0YXRlKCgpID0+IHtcbiAgICByZXR1cm4gdXNlck1hbmFnZXJQcm9wICE9IG51bGwgPyB1c2VyTWFuYWdlclByb3AgOiBVc2VyTWFuYWdlckltcGwgPyBuZXcgVXNlck1hbmFnZXJJbXBsKHVzZXJNYW5hZ2VyU2V0dGluZ3MpIDogeyBzZXR0aW5nczogdXNlck1hbmFnZXJTZXR0aW5ncyB9O1xuICB9KTtcbiAgY29uc3QgW3N0YXRlLCBkaXNwYXRjaF0gPSBSZWFjdDIudXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXV0aFN0YXRlKTtcbiAgY29uc3QgdXNlck1hbmFnZXJDb250ZXh0ID0gUmVhY3QyLnVzZU1lbW8oXG4gICAgKCkgPT4gT2JqZWN0LmFzc2lnbihcbiAgICAgIHtcbiAgICAgICAgc2V0dGluZ3M6IHVzZXJNYW5hZ2VyLnNldHRpbmdzLFxuICAgICAgICBldmVudHM6IHVzZXJNYW5hZ2VyLmV2ZW50c1xuICAgICAgfSxcbiAgICAgIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgdXNlck1hbmFnZXJDb250ZXh0S2V5cy5tYXAoKGtleSkgPT4ge1xuICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHVzZXJNYW5hZ2VyW2tleV0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5iaW5kKHVzZXJNYW5hZ2VyKSkgIT0gbnVsbCA/IF9iIDogdW5zdXBwb3J0ZWRFbnZpcm9ubWVudChrZXkpXG4gICAgICAgICAgXTtcbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIG5hdmlnYXRvcktleXMubWFwKChrZXkpID0+IFtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgdXNlck1hbmFnZXJba2V5XSA/IGFzeW5jIChhcmdzKSA9PiB7XG4gICAgICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiTkFWSUdBVE9SX0lOSVRcIixcbiAgICAgICAgICAgICAgbWV0aG9kOiBrZXlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHVzZXJNYW5hZ2VyW2tleV0oYXJncyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBkaXNwYXRjaCh7IHR5cGU6IFwiRVJST1JcIiwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgZGlzcGF0Y2goeyB0eXBlOiBcIk5BVklHQVRPUl9DTE9TRVwiIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gOiB1bnN1cHBvcnRlZEVudmlyb25tZW50KGtleSlcbiAgICAgICAgXSlcbiAgICAgIClcbiAgICApLFxuICAgIFt1c2VyTWFuYWdlcl1cbiAgKTtcbiAgY29uc3QgZGlkSW5pdGlhbGl6ZSA9IFJlYWN0Mi51c2VSZWYoZmFsc2UpO1xuICBSZWFjdDIudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXVzZXJNYW5hZ2VyIHx8IGRpZEluaXRpYWxpemUuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRJbml0aWFsaXplLmN1cnJlbnQgPSB0cnVlO1xuICAgIHZvaWQgKGFzeW5jICgpID0+IHtcbiAgICAgIGxldCB1c2VyID0gbnVsbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChoYXNBdXRoUGFyYW1zKCkgJiYgIXNraXBTaWduaW5DYWxsYmFjaykge1xuICAgICAgICAgIHVzZXIgPSBhd2FpdCB1c2VyTWFuYWdlci5zaWduaW5DYWxsYmFjaygpO1xuICAgICAgICAgIG9uU2lnbmluQ2FsbGJhY2sgJiYgYXdhaXQgb25TaWduaW5DYWxsYmFjayh1c2VyKTtcbiAgICAgICAgfVxuICAgICAgICB1c2VyID0gIXVzZXIgPyBhd2FpdCB1c2VyTWFuYWdlci5nZXRVc2VyKCkgOiB1c2VyO1xuICAgICAgICBkaXNwYXRjaCh7IHR5cGU6IFwiSU5JVElBTElTRURcIiwgdXNlciB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGRpc3BhdGNoKHsgdHlwZTogXCJFUlJPUlwiLCBlcnJvcjogbG9naW5FcnJvcihlcnJvcikgfSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBpZiAobWF0Y2hTaWdub3V0Q2FsbGJhY2sgJiYgbWF0Y2hTaWdub3V0Q2FsbGJhY2sodXNlck1hbmFnZXIuc2V0dGluZ3MpKSB7XG4gICAgICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHVzZXJNYW5hZ2VyLnNpZ25vdXRDYWxsYmFjaygpO1xuICAgICAgICAgIG9uU2lnbm91dENhbGxiYWNrICYmIGF3YWl0IG9uU2lnbm91dENhbGxiYWNrKHJlc3ApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBkaXNwYXRjaCh7IHR5cGU6IFwiRVJST1JcIiwgZXJyb3I6IHNpZ25vdXRFcnJvcihlcnJvcikgfSk7XG4gICAgICB9XG4gICAgfSkoKTtcbiAgfSwgW3VzZXJNYW5hZ2VyLCBza2lwU2lnbmluQ2FsbGJhY2ssIG9uU2lnbmluQ2FsbGJhY2ssIG9uU2lnbm91dENhbGxiYWNrLCBtYXRjaFNpZ25vdXRDYWxsYmFja10pO1xuICBSZWFjdDIudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXVzZXJNYW5hZ2VyKVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICBjb25zdCBoYW5kbGVVc2VyTG9hZGVkID0gKHVzZXIpID0+IHtcbiAgICAgIGRpc3BhdGNoKHsgdHlwZTogXCJVU0VSX0xPQURFRFwiLCB1c2VyIH0pO1xuICAgIH07XG4gICAgdXNlck1hbmFnZXIuZXZlbnRzLmFkZFVzZXJMb2FkZWQoaGFuZGxlVXNlckxvYWRlZCk7XG4gICAgY29uc3QgaGFuZGxlVXNlclVubG9hZGVkID0gKCkgPT4ge1xuICAgICAgZGlzcGF0Y2goeyB0eXBlOiBcIlVTRVJfVU5MT0FERURcIiB9KTtcbiAgICB9O1xuICAgIHVzZXJNYW5hZ2VyLmV2ZW50cy5hZGRVc2VyVW5sb2FkZWQoaGFuZGxlVXNlclVubG9hZGVkKTtcbiAgICBjb25zdCBoYW5kbGVVc2VyU2lnbmVkT3V0ID0gKCkgPT4ge1xuICAgICAgZGlzcGF0Y2goeyB0eXBlOiBcIlVTRVJfU0lHTkVEX09VVFwiIH0pO1xuICAgIH07XG4gICAgdXNlck1hbmFnZXIuZXZlbnRzLmFkZFVzZXJTaWduZWRPdXQoaGFuZGxlVXNlclNpZ25lZE91dCk7XG4gICAgY29uc3QgaGFuZGxlU2lsZW50UmVuZXdFcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgZGlzcGF0Y2goeyB0eXBlOiBcIkVSUk9SXCIsIGVycm9yIH0pO1xuICAgIH07XG4gICAgdXNlck1hbmFnZXIuZXZlbnRzLmFkZFNpbGVudFJlbmV3RXJyb3IoaGFuZGxlU2lsZW50UmVuZXdFcnJvcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHVzZXJNYW5hZ2VyLmV2ZW50cy5yZW1vdmVVc2VyTG9hZGVkKGhhbmRsZVVzZXJMb2FkZWQpO1xuICAgICAgdXNlck1hbmFnZXIuZXZlbnRzLnJlbW92ZVVzZXJVbmxvYWRlZChoYW5kbGVVc2VyVW5sb2FkZWQpO1xuICAgICAgdXNlck1hbmFnZXIuZXZlbnRzLnJlbW92ZVVzZXJTaWduZWRPdXQoaGFuZGxlVXNlclNpZ25lZE91dCk7XG4gICAgICB1c2VyTWFuYWdlci5ldmVudHMucmVtb3ZlU2lsZW50UmVuZXdFcnJvcihoYW5kbGVTaWxlbnRSZW5ld0Vycm9yKTtcbiAgICB9O1xuICB9LCBbdXNlck1hbmFnZXJdKTtcbiAgY29uc3QgcmVtb3ZlVXNlciA9IFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICB1c2VyTWFuYWdlciA/ICgpID0+IHVzZXJNYW5hZ2VyLnJlbW92ZVVzZXIoKS50aGVuKG9uUmVtb3ZlVXNlcikgOiB1bnN1cHBvcnRlZEVudmlyb25tZW50KFwicmVtb3ZlVXNlclwiKSxcbiAgICBbdXNlck1hbmFnZXIsIG9uUmVtb3ZlVXNlcl1cbiAgKTtcbiAgY29uc3Qgc2lnbm91dFJlZGlyZWN0ID0gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgIChhcmdzKSA9PiB1c2VyTWFuYWdlckNvbnRleHQuc2lnbm91dFJlZGlyZWN0KGFyZ3MpLnRoZW4ob25TaWdub3V0UmVkaXJlY3QpLFxuICAgIFt1c2VyTWFuYWdlckNvbnRleHQuc2lnbm91dFJlZGlyZWN0LCBvblNpZ25vdXRSZWRpcmVjdF1cbiAgKTtcbiAgY29uc3Qgc2lnbm91dFBvcHVwID0gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgIChhcmdzKSA9PiB1c2VyTWFuYWdlckNvbnRleHQuc2lnbm91dFBvcHVwKGFyZ3MpLnRoZW4ob25TaWdub3V0UG9wdXApLFxuICAgIFt1c2VyTWFuYWdlckNvbnRleHQuc2lnbm91dFBvcHVwLCBvblNpZ25vdXRQb3B1cF1cbiAgKTtcbiAgY29uc3Qgc2lnbm91dFNpbGVudCA9IFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICAoYXJncykgPT4gdXNlck1hbmFnZXJDb250ZXh0LnNpZ25vdXRTaWxlbnQoYXJncyksXG4gICAgW3VzZXJNYW5hZ2VyQ29udGV4dC5zaWdub3V0U2lsZW50XVxuICApO1xuICBjb25zdCBjb250ZXh0VmFsdWUgPSBSZWFjdDIudXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgLi4udXNlck1hbmFnZXJDb250ZXh0LFxuICAgICAgcmVtb3ZlVXNlcixcbiAgICAgIHNpZ25vdXRSZWRpcmVjdCxcbiAgICAgIHNpZ25vdXRQb3B1cCxcbiAgICAgIHNpZ25vdXRTaWxlbnRcbiAgICB9O1xuICB9LCBbc3RhdGUsIHVzZXJNYW5hZ2VyQ29udGV4dCwgcmVtb3ZlVXNlcl0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KEF1dGhDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0VmFsdWUgfSwgY2hpbGRyZW4pO1xufTtcblxuLy8gc3JjL3VzZUF1dGgudHNcbmltcG9ydCBSZWFjdDMgZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlQXV0aCA9ICgpID0+IHtcbiAgY29uc3QgY29udGV4dCA9IFJlYWN0My51c2VDb250ZXh0KEF1dGhDb250ZXh0KTtcbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgY29uc29sZS53YXJuKFwiQXV0aFByb3ZpZGVyIGNvbnRleHQgaXMgdW5kZWZpbmVkLCBwbGVhc2UgdmVyaWZ5IHlvdSBhcmUgY2FsbGluZyB1c2VBdXRoKCkgYXMgY2hpbGQgb2YgYSA8QXV0aFByb3ZpZGVyPiBjb21wb25lbnQuXCIpO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufTtcblxuLy8gc3JjL3dpdGhBdXRoLnRzeFxuaW1wb3J0IFJlYWN0NCBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHdpdGhBdXRoKENvbXBvbmVudCkge1xuICBjb25zdCBkaXNwbGF5TmFtZSA9IGB3aXRoQXV0aCgke0NvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZX0pYDtcbiAgY29uc3QgQyA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IGF1dGggPSB1c2VBdXRoKCk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDQuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIHsgLi4ucHJvcHMsIGF1dGggfSk7XG4gIH07XG4gIEMuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgcmV0dXJuIEM7XG59XG5cbi8vIHNyYy93aXRoQXV0aGVudGljYXRpb25SZXF1aXJlZC50c3hcbmltcG9ydCBSZWFjdDUgZnJvbSBcInJlYWN0XCI7XG52YXIgd2l0aEF1dGhlbnRpY2F0aW9uUmVxdWlyZWQgPSAoQ29tcG9uZW50LCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgeyBPblJlZGlyZWN0aW5nID0gKCkgPT4gLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFJlYWN0NS5GcmFnbWVudCwgbnVsbCksIG9uQmVmb3JlU2lnbmluLCBzaWduaW5SZWRpcmVjdEFyZ3MgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGRpc3BsYXlOYW1lID0gYHdpdGhBdXRoZW50aWNhdGlvblJlcXVpcmVkKCR7Q29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lfSlgO1xuICBjb25zdCBDID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgYXV0aCA9IHVzZUF1dGgoKTtcbiAgICBSZWFjdDUudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGlmIChoYXNBdXRoUGFyYW1zKCkgfHwgYXV0aC5pc0xvYWRpbmcgfHwgYXV0aC5hY3RpdmVOYXZpZ2F0b3IgfHwgYXV0aC5pc0F1dGhlbnRpY2F0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdm9pZCAoYXN5bmMgKCkgPT4ge1xuICAgICAgICBvbkJlZm9yZVNpZ25pbiAmJiBhd2FpdCBvbkJlZm9yZVNpZ25pbigpO1xuICAgICAgICBhd2FpdCBhdXRoLnNpZ25pblJlZGlyZWN0KHNpZ25pblJlZGlyZWN0QXJncyk7XG4gICAgICB9KSgpO1xuICAgIH0sIFthdXRoLmlzTG9hZGluZywgYXV0aC5pc0F1dGhlbnRpY2F0ZWQsIGF1dGhdKTtcbiAgICByZXR1cm4gYXV0aC5pc0F1dGhlbnRpY2F0ZWQgPyAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCB7IC4uLnByb3BzIH0pIDogT25SZWRpcmVjdGluZygpO1xuICB9O1xuICBDLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gIHJldHVybiBDO1xufTtcbmV4cG9ydCB7XG4gIEF1dGhDb250ZXh0LFxuICBBdXRoUHJvdmlkZXIsXG4gIGhhc0F1dGhQYXJhbXMsXG4gIHVzZUF1dGgsXG4gIHdpdGhBdXRoLFxuICB3aXRoQXV0aGVudGljYXRpb25SZXF1aXJlZFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LW9pZGMtY29udGV4dC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-oidc-context/dist/esm/react-oidc-context.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/utils/oidcConfigSigninConfig.js":
/*!*********************************************!*\
  !*** ./src/utils/oidcConfigSigninConfig.js ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   oidcConfigSignInConfig: () => (/* binding */ oidcConfigSignInConfig)\n/* harmony export */ });\nconst uri =  true ? \"http://localhost:3000\" : 0;\nconst oidcConfigSignInConfig = {\n    authority: \"https://cognito-idp.ap-southeast-1.amazonaws.com/ap-southeast-1_YBwkpRQN4\",\n    client_id: \"3j99l5kkd0g4dije4dg8r9enn7\",\n    redirect_uri: \"\".concat(uri, \"/callback\"),\n    response_type: \"code\",\n    scope: \"email openid phone profile\"\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9vaWRjQ29uZmlnU2lnbmluQ29uZmlnLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNQSxNQUNKQyxLQUF3QixHQUNwQkEsdUJBQTZCLEdBQzdCQSxDQUE0QjtBQUUzQixNQUFNSyx5QkFBeUI7SUFDcENDLFdBQVdOLDJFQUE2QjtJQUN4Q1EsV0FBV1IsNEJBQTZCO0lBQ3hDVSxjQUFjLEdBQU8sT0FBSlgsS0FBSTtJQUNyQlksZUFBZTtJQUNmQyxPQUFPO0FBQ1QsRUFBRSIsInNvdXJjZXMiOlsiRDpcXFRXRSBHS0VcXHRvdXJ3aXRoZWFzZS1na2UtaGFja2F0aG9uXFxmcm9udGVuZFxcbXktYXBwXFxzcmNcXHV0aWxzXFxvaWRjQ29uZmlnU2lnbmluQ29uZmlnLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHVyaSA9XHJcbiAgcHJvY2Vzcy5lbnYuRU5WID09IFwiRGV2XCJcclxuICAgID8gcHJvY2Vzcy5lbnYuQ09HTklUT19MT0NBTF9VUkxcclxuICAgIDogcHJvY2Vzcy5lbnYuQ09HTklUT19QUk9EX1VSTDtcclxuXHJcbmV4cG9ydCBjb25zdCBvaWRjQ29uZmlnU2lnbkluQ29uZmlnID0ge1xyXG4gIGF1dGhvcml0eTogcHJvY2Vzcy5lbnYuQ09HTklUT19BVVRIT1JJVFksXHJcbiAgY2xpZW50X2lkOiBwcm9jZXNzLmVudi5DT0dOSVRPX0NMSUVOVF9JRCxcclxuICByZWRpcmVjdF91cmk6IGAke3VyaX0vY2FsbGJhY2tgLFxyXG4gIHJlc3BvbnNlX3R5cGU6IFwiY29kZVwiLFxyXG4gIHNjb3BlOiBcImVtYWlsIG9wZW5pZCBwaG9uZSBwcm9maWxlXCIsXHJcbn07XHJcbiJdLCJuYW1lcyI6WyJ1cmkiLCJwcm9jZXNzIiwiZW52IiwiRU5WIiwiQ09HTklUT19MT0NBTF9VUkwiLCJDT0dOSVRPX1BST0RfVVJMIiwib2lkY0NvbmZpZ1NpZ25JbkNvbmZpZyIsImF1dGhvcml0eSIsIkNPR05JVE9fQVVUSE9SSVRZIiwiY2xpZW50X2lkIiwiQ09HTklUT19DTElFTlRfSUQiLCJyZWRpcmVjdF91cmkiLCJyZXNwb25zZV90eXBlIiwic2NvcGUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/oidcConfigSigninConfig.js\n"));

/***/ }),

/***/ "?8495":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* (ignored) */

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5CTWE%20GKE%5C%5Ctourwithease-gke-hackathon%5C%5Cfrontend%5C%5Cmy-app%5C%5Capp%5C%5Cglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5CTWE%20GKE%5C%5Ctourwithease-gke-hackathon%5C%5Cfrontend%5C%5Cmy-app%5C%5Ccomponents%5C%5CAuthWrapper.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);